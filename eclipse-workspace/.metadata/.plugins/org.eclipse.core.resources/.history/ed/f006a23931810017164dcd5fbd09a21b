package processing.opengl;

import java.io.File;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;
import processing.core.PApplet;
import processing.core.PFont;
import processing.core.PFont.Glyph;
import processing.core.PGraphics;
import processing.core.PGraphics.AsyncImageSaver;
import processing.core.PImage;
import processing.core.PMatrix;
import processing.core.PMatrix2D;
import processing.core.PMatrix3D;
import processing.core.PShape;
import processing.core.PSurface;
import processing.core.PVector;



























public class PGraphicsOpenGL
  extends PGraphics
{
  public PGL pgl;
  public PGraphicsOpenGL currentPG;
  protected WeakHashMap<PFont, FontTexture> fontMap;
  public boolean initialized;
  protected static final int FLUSH_CONTINUOUSLY = 0;
  protected static final int FLUSH_WHEN_FULL = 1;
  protected static final int IMMEDIATE = 0;
  protected static final int RETAINED = 1;
  protected int flushMode = 1;
  
  protected VertexBuffer bufPolyVertex;
  
  protected VertexBuffer bufPolyColor;
  
  protected VertexBuffer bufPolyNormal;
  
  protected VertexBuffer bufPolyTexcoord;
  
  protected VertexBuffer bufPolyAmbient;
  protected VertexBuffer bufPolySpecular;
  protected VertexBuffer bufPolyEmissive;
  protected VertexBuffer bufPolyShininess;
  protected VertexBuffer bufPolyIndex;
  protected boolean polyBuffersCreated = false;
  
  protected int polyBuffersContext;
  protected VertexBuffer bufLineVertex;
  protected VertexBuffer bufLineColor;
  protected VertexBuffer bufLineAttrib;
  protected VertexBuffer bufLineIndex;
  protected boolean lineBuffersCreated = false;
  
  protected int lineBuffersContext;
  protected VertexBuffer bufPointVertex;
  protected VertexBuffer bufPointColor;
  protected VertexBuffer bufPointAttrib;
  protected VertexBuffer bufPointIndex;
  protected boolean pointBuffersCreated = false;
  

  protected int pointBuffersContext;
  

  protected AttributeMap polyAttribs;
  

  protected static final int INIT_VERTEX_BUFFER_SIZE = 256;
  
  protected static final int INIT_INDEX_BUFFER_SIZE = 512;
  
  protected static boolean glParamsRead = false;
  
  public static boolean npotTexSupported;
  
  public static boolean autoMipmapGenSupported;
  
  public static boolean fboMultisampleSupported;
  
  public static boolean packedDepthStencilSupported;
  
  public static boolean anisoSamplingSupported;
  
  public static boolean blendEqSupported;
  
  public static boolean readBufferSupported;
  
  public static boolean drawBufferSupported;
  
  public static int maxTextureSize;
  
  public static int maxSamples;
  
  public static float maxAnisoAmount;
  
  public static int depthBits;
  public static int stencilBits;
  public static String OPENGL_VENDOR;
  public static String OPENGL_RENDERER;
  public static String OPENGL_VERSION;
  public static String OPENGL_EXTENSIONS;
  public static String GLSL_VERSION;
  protected static URL defColorShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/ColorVert.glsl");
  
  protected static URL defTextureShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/TexVert.glsl");
  
  protected static URL defLightShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/LightVert.glsl");
  
  protected static URL defTexlightShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/TexLightVert.glsl");
  
  protected static URL defColorShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/ColorFrag.glsl");
  
  protected static URL defTextureShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/TexFrag.glsl");
  
  protected static URL defLightShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/LightFrag.glsl");
  
  protected static URL defTexlightShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/TexLightFrag.glsl");
  

  protected static URL defLineShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/LineVert.glsl");
  
  protected static URL defLineShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/LineFrag.glsl");
  
  protected static URL defPointShaderVertURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/PointVert.glsl");
  
  protected static URL defPointShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/PointFrag.glsl");
  
  protected static URL maskShaderFragURL = PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/MaskFrag.glsl");
  

  protected PShader defColorShader;
  

  protected PShader defTextureShader;
  

  protected PShader defLightShader;
  

  protected PShader defTexlightShader;
  
  protected PShader defLineShader;
  
  protected PShader defPointShader;
  
  protected PShader maskShader;
  
  protected PShader polyShader;
  
  protected PShader lineShader;
  
  protected PShader pointShader;
  
  protected InGeometry inGeo;
  
  protected TessGeometry tessGeo;
  
  protected TexCache texCache;
  
  protected Tessellator tessellator;
  
  protected DepthSorter sorter;
  
  protected boolean isDepthSortingEnabled;
  
  protected AsyncPixelReader asyncPixelReader;
  
  protected boolean asyncPixelReaderInitialized;
  
  protected static final Set<AsyncPixelReader> ongoingPixelTransfers = new HashSet();
  
  protected static final List<AsyncPixelReader> ongoingPixelTransfersIterable = new ArrayList();
  
  public float cameraFOV;
  
  public float cameraX;
  
  public float cameraY;
  
  public float cameraZ;
  
  public float cameraNear;
  
  public float cameraFar;
  
  public float cameraAspect;
  
  protected float eyeDist;
  
  protected boolean manipulatingCamera;
  
  public PMatrix3D projection;
  
  public PMatrix3D camera;
  
  public PMatrix3D cameraInv;
  
  public PMatrix3D modelview;
  
  public PMatrix3D modelviewInv;
  
  public PMatrix3D projmodelview;
  
  protected float[] glProjection;
  
  protected float[] glModelview;
  
  protected float[] glProjmodelview;
  
  protected float[] glNormal;
  protected static PMatrix3D identity = new PMatrix3D();
  

  protected boolean sized;
  

  protected static final int MATRIX_STACK_DEPTH = 32;
  

  protected int modelviewStackDepth;
  

  protected int projectionStackDepth;
  
  protected float[][] modelviewStack = new float[32][16];
  

  protected float[][] modelviewInvStack = new float[32][16];
  

  protected float[][] cameraStack = new float[32][16];
  

  protected float[][] cameraInvStack = new float[32][16];
  

  protected float[][] projectionStack = new float[32][16];
  


  public boolean lights;
  

  public int lightCount = 0;
  


  public int[] lightType;
  


  public float[] lightPosition;
  


  public float[] lightNormal;
  


  public float[] lightAmbient;
  


  public float[] lightDiffuse;
  


  public float[] lightSpecular;
  


  public float[] lightFalloffCoefficients;
  

  public float[] lightSpotParameters;
  

  public float[] currentLightSpecular;
  

  public float currentLightFalloffConstant;
  

  public float currentLightFalloffLinear;
  

  public float currentLightFalloffQuadratic;
  

  protected int textureWrap = 0;
  protected int textureSampling = 5;
  




  protected boolean clip = false;
  

  protected int[] clipRect = new int[4];
  


  FontTexture textTex;
  

  protected static final int FB_STACK_DEPTH = 16;
  

  protected int fbStackDepth;
  

  protected FrameBuffer[] fbStack;
  

  protected FrameBuffer drawFramebuffer;
  

  protected FrameBuffer readFramebuffer;
  

  protected FrameBuffer currentFramebuffer;
  

  protected FrameBuffer offscreenFramebuffer;
  

  protected FrameBuffer multisampleFramebuffer;
  

  protected boolean offscreenMultisample;
  

  protected boolean pixOpChangedFB;
  

  protected Texture texture = null;
  

  protected Texture ptexture = null;
  

  protected IntBuffer pixelBuffer;
  

  protected int[] nativePixels;
  

  protected IntBuffer nativePixelBuffer;
  

  protected Texture filterTexture = null;
  



  protected PImage filterImage;
  



  protected boolean drawing = false;
  

  protected boolean smoothDisabled = false;
  protected int smoothCallCount = 0;
  protected int lastSmoothCall = -10;
  


  protected int lastBlendMode = -1;
  
  protected static final int OP_NONE = 0;
  
  protected static final int OP_READ = 1;
  protected static final int OP_WRITE = 2;
  protected int pixelsOp = 0;
  

  protected IntBuffer viewport;
  
  protected boolean openContour = false;
  protected boolean breakShape = false;
  protected boolean defaultEdges = false;
  

  protected static final int EDGE_MIDDLE = 0;
  

  protected static final int EDGE_START = 1;
  

  protected static final int EDGE_STOP = 2;
  

  protected static final int EDGE_SINGLE = 3;
  

  protected static final int EDGE_CLOSE = -1;
  

  protected static final int MIN_POINT_ACCURACY = 20;
  

  protected static final int MAX_POINT_ACCURACY = 200;
  

  protected static final float POINT_ACCURACY_FACTOR = 10.0F;
  
  protected static final float[][] QUAD_POINT_SIGNS = { { -1.0F, 1.0F }, { -1.0F, -1.0F }, { 1.0F, -1.0F }, { 1.0F, 1.0F } };
  

  protected static IntBuffer intBuffer;
  

  protected static FloatBuffer floatBuffer;
  

  static final String OPENGL_THREAD_ERROR = "Cannot run the OpenGL renderer outside the main thread, change your code\nso the drawing calls are all inside the main thread, \nor use the default renderer instead.";
  

  static final String BLEND_DRIVER_ERROR = "blendMode(%1$s) is not supported by this hardware (or driver)";
  

  static final String BLEND_RENDERER_ERROR = "blendMode(%1$s) is not supported by this renderer";
  

  static final String ALREADY_BEGAN_CONTOUR_ERROR = "Already called beginContour()";
  

  static final String NO_BEGIN_CONTOUR_ERROR = "Need to call beginContour() first";
  

  static final String UNSUPPORTED_SMOOTH_LEVEL_ERROR = "Smooth level %1$s is not available. Using %2$s instead";
  

  static final String UNSUPPORTED_SMOOTH_ERROR = "Smooth is not supported by this hardware (or driver)";
  

  static final String TOO_MANY_SMOOTH_CALLS_ERROR = "The smooth/noSmooth functions are being called too often.\nThis results in screen flickering, so they will be disabled\nfor the rest of the sketch's execution";
  

  static final String UNSUPPORTED_SHAPE_FORMAT_ERROR = "Unsupported shape format";
  

  static final String MISSING_UV_TEXCOORDS_ERROR = "No uv texture coordinates supplied with vertex() call";
  

  static final String INVALID_FILTER_SHADER_ERROR = "Your shader cannot be used as a filter because is of type POINT or LINES";
  

  static final String INCONSISTENT_SHADER_TYPES = "The vertex and fragment shaders have different types";
  

  static final String WRONG_SHADER_TYPE_ERROR = "shader() called with a wrong shader";
  

  static final String SHADER_NEED_LIGHT_ATTRIBS = "The provided shader needs light attributes (ambient, diffuse, etc.), but the current scene is unlit, so the default shader will be used instead";
  

  static final String MISSING_FRAGMENT_SHADER = "The fragment shader is missing, cannot create shader object";
  

  static final String MISSING_VERTEX_SHADER = "The vertex shader is missing, cannot create shader object";
  

  static final String UNKNOWN_SHADER_KIND_ERROR = "Unknown shader kind";
  
  static final String NO_TEXLIGHT_SHADER_ERROR = "Your shader needs to be of TEXLIGHT type to render this geometry properly, using default shader instead.";
  
  static final String NO_LIGHT_SHADER_ERROR = "Your shader needs to be of LIGHT type to render this geometry properly, using default shader instead.";
  
  static final String NO_TEXTURE_SHADER_ERROR = "Your shader needs to be of TEXTURE type to render this geometry properly, using default shader instead.";
  
  static final String NO_COLOR_SHADER_ERROR = "Your shader needs to be of COLOR type to render this geometry properly, using default shader instead.";
  
  static final String TESSELLATION_ERROR = "Tessellation Error: %1$s";
  
  static final String GL_THREAD_NOT_CURRENT = "You are trying to draw outside OpenGL's animation thread.\nPlace all drawing commands in the draw() function, or inside\nyour own functions as long as they are called from draw(),\nbut not in event handling functions such as keyPressed()\nor mousePressed().";
  
  private static final int MAX_DRAIN_GLRES_ITERATIONS = 10;
  

  public PGraphicsOpenGL()
  {
    pgl = createPGL(this);
    
    if (intBuffer == null) {
      intBuffer = PGL.allocateIntBuffer(2);
      floatBuffer = PGL.allocateFloatBuffer(2);
    }
    
    viewport = PGL.allocateIntBuffer(4);
    
    polyAttribs = newAttributeMap();
    inGeo = newInGeometry(this, polyAttribs, 0);
    tessGeo = newTessGeometry(this, polyAttribs, 0);
    texCache = newTexCache(this);
    
    projection = new PMatrix3D();
    camera = new PMatrix3D();
    cameraInv = new PMatrix3D();
    modelview = new PMatrix3D();
    modelviewInv = new PMatrix3D();
    projmodelview = new PMatrix3D();
    
    lightType = new int[PGL.MAX_LIGHTS];
    lightPosition = new float[4 * PGL.MAX_LIGHTS];
    lightNormal = new float[3 * PGL.MAX_LIGHTS];
    lightAmbient = new float[3 * PGL.MAX_LIGHTS];
    lightDiffuse = new float[3 * PGL.MAX_LIGHTS];
    lightSpecular = new float[3 * PGL.MAX_LIGHTS];
    lightFalloffCoefficients = new float[3 * PGL.MAX_LIGHTS];
    lightSpotParameters = new float[2 * PGL.MAX_LIGHTS];
    currentLightSpecular = new float[3];
    
    initialized = false;
  }
  

  public void setParent(PApplet parent)
  {
    super.setParent(parent);
    if (pgl != null) {
      pgl.sketch = parent;
    }
  }
  

  public void setPrimary(boolean primary)
  {
    super.setPrimary(primary);
    pgl.setPrimary(primary);
    format = 2;
    if (primary) {
      fbStack = new FrameBuffer[16];
      fontMap = new WeakHashMap();
      tessellator = new Tessellator();
    } else {
      tessellator = getPrimaryPGtessellator;
    }
  }
  







  public void setSize(int iwidth, int iheight)
  {
    width = iwidth;
    height = iheight;
    updatePixelSize();
    

    cameraFOV = 1.0471976F;
    cameraX = (width / 2.0F);
    cameraY = (height / 2.0F);
    cameraZ = (cameraY / (float)Math.tan(cameraFOV / 2.0F));
    cameraNear = (cameraZ / 10.0F);
    cameraFar = (cameraZ * 10.0F);
    cameraAspect = (width / height);
    
    sized = true;
  }
  

  public void dispose()
  {
    if (asyncPixelReader != null) {
      asyncPixelReader.dispose();
      asyncPixelReader = null;
    }
    
    if (!primaryGraphics) {
      deleteSurfaceTextures();
      FrameBuffer ofb = offscreenFramebuffer;
      FrameBuffer mfb = multisampleFramebuffer;
      if (ofb != null) {
        ofb.dispose();
      }
      if (mfb != null) {
        mfb.dispose();
      }
    }
    
    pgl.dispose();
    
    super.dispose();
  }
  
  protected void setFlushMode(int mode)
  {
    flushMode = mode;
  }
  
  protected void updatePixelSize()
  {
    float f = pgl.getPixelScale();
    pixelWidth = ((int)(width * f));
    pixelHeight = ((int)(height * f));
  }
  






  protected PGL createPGL(PGraphicsOpenGL pg)
  {
    return new PJOGL(pg);
  }
  

































  public PSurface createSurface()
  {
    return this.surface = new PSurfaceJOGL(this);
  }
  


  public boolean saveImpl(String filename)
  {
    if (getHint(12))
    {
      if (primaryGraphics) {
        int prevFormat = this.format;
        this.format = 1;
        boolean result = super.save(filename);
        this.format = prevFormat;
        return result;
      }
      
      return super.save(filename);
    }
    
    if (asyncImageSaver == null) {
      asyncImageSaver = new PGraphics.AsyncImageSaver();
    }
    
    if (!asyncPixelReaderInitialized)
    {
      if ((pgl.hasPBOs()) && (pgl.hasSynchronization())) {
        asyncPixelReader = new AsyncPixelReader();
      }
      asyncPixelReaderInitialized = true;
    }
    
    if ((asyncPixelReader != null) && (!loaded)) {
      boolean needEndDraw = false;
      if (!drawing) {
        beginDraw();
        needEndDraw = true;
      }
      flush();
      updatePixelSize();
      

      asyncPixelReader.readAndSaveAsync(parent.sketchFile(filename));
      
      if (needEndDraw) endDraw();
    }
    else
    {
      if (!loaded) loadPixels();
      int format = primaryGraphics ? 1 : 2;
      PImage target = asyncImageSaver.getAvailableTarget(pixelWidth, pixelHeight, 
        format);
      if (target == null) return false;
      int count = PApplet.min(pixels.length, pixels.length);
      System.arraycopy(pixels, 0, pixels, 0, count);
      asyncImageSaver.saveTargetAsync(this, target, parent.sketchFile(filename));
    }
    
    return true;
  }
  






  public void setCache(PImage image, Object storage)
  {
    if ((image instanceof PGraphicsOpenGL))
    {

      getPrimaryPGcacheMap.put(image, new WeakReference(storage));
      return;
    }
    getPrimaryPGcacheMap.put(image, storage);
  }
  


  public Object getCache(PImage image)
  {
    Object storage = getPrimaryPGcacheMap.get(image);
    if ((storage != null) && (storage.getClass() == WeakReference.class))
    {
      return ((WeakReference)storage).get();
    }
    return storage;
  }
  

  public void removeCache(PImage image)
  {
    getPrimaryPGcacheMap.remove(image);
  }
  



  protected void setFontTexture(PFont font, FontTexture fontTexture)
  {
    getPrimaryPGfontMap.put(font, fontTexture);
  }
  
  protected FontTexture getFontTexture(PFont font)
  {
    return (FontTexture)getPrimaryPGfontMap.get(font);
  }
  
  protected void removeFontTexture(PFont font)
  {
    getPrimaryPGfontMap.remove(font);
  }
  



  protected static class GLResourceTexture
    extends WeakReference<Texture>
  {
    int glName;
    

    private PGL pgl;
    

    private int context;
    

    private static ReferenceQueue<Texture> refQueue = new ReferenceQueue();
    private static List<GLResourceTexture> refList = new ArrayList();
    
    static void drainRefQueueBounded() {
      ReferenceQueue<Texture> refQueue = referenceQueue();
      int iterations = 0;
      while (iterations < 10) {
        GLResourceTexture res = (GLResourceTexture)refQueue.poll();
        if (res == null) {
          break;
        }
        res.dispose();
        iterations++;
      }
    }
    
    static ReferenceQueue<Texture> referenceQueue() {
      return refQueue;
    }
    
    public GLResourceTexture(Texture tex) {
      super(refQueue);
      
      drainRefQueueBounded();
      
      pgl = pg.getPrimaryPGL();
      pgl.genTextures(1, PGraphicsOpenGL.intBuffer);
      glName = PGraphicsOpenGL.intBuffer.get(0);
      
      glName = glName;
      context = context;
      
      refList.add(this);
    }
    
    private void disposeNative() {
      if (pgl != null) {
        if (glName != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glName);
          pgl.deleteTextures(1, PGraphicsOpenGL.intBuffer);
          glName = 0;
        }
        pgl = null;
      }
    }
    
    void dispose() {
      refList.remove(this);
      disposeNative();
    }
    
    public boolean equals(Object obj)
    {
      GLResourceTexture other = (GLResourceTexture)obj;
      return (glName == glName) && 
        (context == context);
    }
    
    public int hashCode()
    {
      int result = 17;
      result = 31 * result + glName;
      result = 31 * result + context;
      return result;
    }
  }
  

  protected static class GLResourceVertexBuffer
    extends WeakReference<VertexBuffer>
  {
    int glId;
    private PGL pgl;
    private int context;
    private static ReferenceQueue<VertexBuffer> refQueue = new ReferenceQueue();
    private static List<GLResourceVertexBuffer> refList = new ArrayList();
    
    static void drainRefQueueBounded() {
      ReferenceQueue<VertexBuffer> refQueue = referenceQueue();
      int iterations = 0;
      while (iterations < 10) {
        GLResourceVertexBuffer res = (GLResourceVertexBuffer)refQueue.poll();
        if (res == null) {
          break;
        }
        res.dispose();
        iterations++;
      }
    }
    
    static ReferenceQueue<VertexBuffer> referenceQueue() {
      return refQueue;
    }
    
    public GLResourceVertexBuffer(VertexBuffer vbo) {
      super(refQueue);
      
      drainRefQueueBounded();
      
      pgl = pgl.graphics.getPrimaryPGL();
      pgl.genBuffers(1, PGraphicsOpenGL.intBuffer);
      glId = PGraphicsOpenGL.intBuffer.get(0);
      
      glId = glId;
      context = context;
      
      refList.add(this);
    }
    
    private void disposeNative() {
      if (pgl != null) {
        if (glId != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glId);
          pgl.deleteBuffers(1, PGraphicsOpenGL.intBuffer);
          glId = 0;
        }
        pgl = null;
      }
    }
    
    void dispose() {
      refList.remove(this);
      disposeNative();
    }
    
    public boolean equals(Object obj)
    {
      GLResourceVertexBuffer other = (GLResourceVertexBuffer)obj;
      return (glId == glId) && 
        (context == context);
    }
    
    public int hashCode()
    {
      int result = 17;
      result = 31 * result + glId;
      result = 31 * result + context;
      return result;
    }
  }
  

  protected static class GLResourceShader
    extends WeakReference<PShader>
  {
    int glProgram;
    int glVertex;
    int glFragment;
    private PGL pgl;
    private int context;
    private static ReferenceQueue<PShader> refQueue = new ReferenceQueue();
    private static List<GLResourceShader> refList = new ArrayList();
    
    static void drainRefQueueBounded() {
      ReferenceQueue<PShader> refQueue = referenceQueue();
      int iterations = 0;
      while (iterations < 10) {
        GLResourceShader res = (GLResourceShader)refQueue.poll();
        if (res == null) {
          break;
        }
        res.dispose();
        iterations++;
      }
    }
    
    static ReferenceQueue<PShader> referenceQueue() {
      return refQueue;
    }
    
    public GLResourceShader(PShader sh) {
      super(refQueue);
      
      drainRefQueueBounded();
      
      pgl = pgl.graphics.getPrimaryPGL();
      glProgram = pgl.createProgram();
      glVertex = pgl.createShader(PGL.VERTEX_SHADER);
      glFragment = pgl.createShader(PGL.FRAGMENT_SHADER);
      
      glProgram = glProgram;
      glVertex = glVertex;
      glFragment = glFragment;
      
      context = context;
      
      refList.add(this);
    }
    
    private void disposeNative() {
      if (pgl != null) {
        if (glFragment != 0) {
          pgl.deleteShader(glFragment);
          glFragment = 0;
        }
        if (glVertex != 0) {
          pgl.deleteShader(glVertex);
          glVertex = 0;
        }
        if (glProgram != 0) {
          pgl.deleteProgram(glProgram);
          glProgram = 0;
        }
        pgl = null;
      }
    }
    
    void dispose() {
      refList.remove(this);
      disposeNative();
    }
    
    public boolean equals(Object obj)
    {
      GLResourceShader other = (GLResourceShader)obj;
      return (glProgram == glProgram) && 
        (glVertex == glVertex) && 
        (glFragment == glFragment) && 
        (context == context);
    }
    
    public int hashCode()
    {
      int result = 17;
      result = 31 * result + glProgram;
      result = 31 * result + glVertex;
      result = 31 * result + glFragment;
      result = 31 * result + context;
      return result;
    }
  }
  

  protected static class GLResourceFrameBuffer
    extends WeakReference<FrameBuffer>
  {
    int glFbo;
    int glDepth;
    int glStencil;
    int glDepthStencil;
    int glMultisample;
    private PGL pgl;
    private int context;
    private static ReferenceQueue<FrameBuffer> refQueue = new ReferenceQueue();
    private static List<GLResourceFrameBuffer> refList = new ArrayList();
    
    static void drainRefQueueBounded() {
      ReferenceQueue<FrameBuffer> refQueue = referenceQueue();
      int iterations = 0;
      while (iterations < 10) {
        GLResourceFrameBuffer res = (GLResourceFrameBuffer)refQueue.poll();
        if (res == null) {
          break;
        }
        res.dispose();
        iterations++;
      }
    }
    
    static ReferenceQueue<FrameBuffer> referenceQueue() {
      return refQueue;
    }
    
    public GLResourceFrameBuffer(FrameBuffer fb) {
      super(refQueue);
      
      drainRefQueueBounded();
      
      pgl = pg.getPrimaryPGL();
      if (!screenFb) {
        pgl.genFramebuffers(1, PGraphicsOpenGL.intBuffer);
        glFbo = PGraphicsOpenGL.intBuffer.get(0);
        
        if (multisample) {
          pgl.genRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glMultisample = PGraphicsOpenGL.intBuffer.get(0);
        }
        
        if (packedDepthStencil) {
          pgl.genRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glDepthStencil = PGraphicsOpenGL.intBuffer.get(0);
        } else {
          if (depthBits > 0) {
            pgl.genRenderbuffers(1, PGraphicsOpenGL.intBuffer);
            glDepth = PGraphicsOpenGL.intBuffer.get(0);
          }
          if (stencilBits > 0) {
            pgl.genRenderbuffers(1, PGraphicsOpenGL.intBuffer);
            glStencil = PGraphicsOpenGL.intBuffer.get(0);
          }
        }
        
        glFbo = glFbo;
        glDepth = glDepth;
        glStencil = glStencil;
        glDepthStencil = glDepthStencil;
        glMultisample = glMultisample;
      }
      
      context = context;
      
      refList.add(this);
    }
    
    private void disposeNative() {
      if (pgl != null) {
        if (glFbo != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glFbo);
          pgl.deleteFramebuffers(1, PGraphicsOpenGL.intBuffer);
          glFbo = 0;
        }
        if (glDepth != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glDepth);
          pgl.deleteRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glDepth = 0;
        }
        if (glStencil != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glStencil);
          pgl.deleteRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glStencil = 0;
        }
        if (glDepthStencil != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glDepthStencil);
          pgl.deleteRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glDepthStencil = 0;
        }
        if (glMultisample != 0) {
          PGraphicsOpenGL.intBuffer.put(0, glMultisample);
          pgl.deleteRenderbuffers(1, PGraphicsOpenGL.intBuffer);
          glMultisample = 0;
        }
        pgl = null;
      }
    }
    
    void dispose() {
      refList.remove(this);
      disposeNative();
    }
    
    public boolean equals(Object obj)
    {
      GLResourceFrameBuffer other = (GLResourceFrameBuffer)obj;
      return (glFbo == glFbo) && 
        (glDepth == glDepth) && 
        (glStencil == glStencil) && 
        (glDepthStencil == glDepthStencil) && 
        (glMultisample == glMultisample) && 
        (context == context);
    }
    
    public int hashCode()
    {
      int result = 17;
      result = 31 * result + glFbo;
      result = 31 * result + glDepth;
      result = 31 * result + glStencil;
      result = 31 * result + glDepthStencil;
      result = 31 * result + glMultisample;
      result = 31 * result + context;
      return result;
    }
  }
  





  protected void pushFramebuffer()
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    if (fbStackDepth == 16) {
      throw new RuntimeException("Too many pushFramebuffer calls");
    }
    fbStack[fbStackDepth] = currentFramebuffer;
    fbStackDepth += 1;
  }
  
  protected void setFramebuffer(FrameBuffer fbo)
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    if (currentFramebuffer != fbo) {
      currentFramebuffer = fbo;
      if (currentFramebuffer != null) currentFramebuffer.bind();
    }
  }
  
  protected void popFramebuffer()
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    if (fbStackDepth == 0) {
      throw new RuntimeException("popFramebuffer call is unbalanced.");
    }
    fbStackDepth -= 1;
    FrameBuffer fbo = fbStack[fbStackDepth];
    if (currentFramebuffer != fbo) {
      currentFramebuffer.finish();
      currentFramebuffer = fbo;
      if (currentFramebuffer != null) currentFramebuffer.bind();
    }
  }
  
  protected FrameBuffer getCurrentFB()
  {
    return getPrimaryPGcurrentFramebuffer;
  }
  





  protected void createPolyBuffers()
  {
    if ((!polyBuffersCreated) || (polyBuffersContextIsOutdated())) {
      polyBuffersContext = pgl.getCurrentContext();
      
      bufPolyVertex = new VertexBuffer(this, PGL.ARRAY_BUFFER, 3, PGL.SIZEOF_FLOAT);
      bufPolyColor = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufPolyNormal = new VertexBuffer(this, PGL.ARRAY_BUFFER, 3, PGL.SIZEOF_FLOAT);
      bufPolyTexcoord = new VertexBuffer(this, PGL.ARRAY_BUFFER, 2, PGL.SIZEOF_FLOAT);
      bufPolyAmbient = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufPolySpecular = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufPolyEmissive = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufPolyShininess = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_FLOAT);
      pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
      bufPolyIndex = new VertexBuffer(this, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
      pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
      
      polyBuffersCreated = true;
    }
    
    boolean created = false;
    for (String name : polyAttribs.keySet()) {
      VertexAttribute attrib = (VertexAttribute)polyAttribs.get(name);
      if ((!attrib.bufferCreated()) || (polyBuffersContextIsOutdated())) {
        attrib.createBuffer(pgl);
        created = true;
      }
    }
    if (created) { pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    }
  }
  
  protected void updatePolyBuffers(boolean lit, boolean tex, boolean needNormals, boolean needTexCoords)
  {
    createPolyBuffers();
    
    int size = tessGeo.polyVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    
    tessGeo.updatePolyVerticesBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.polyVerticesBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updatePolyColorsBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.polyColorsBuffer, PGL.STATIC_DRAW);
    
    if (lit) {
      tessGeo.updatePolyAmbientBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyAmbient.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
        tessGeo.polyAmbientBuffer, PGL.STATIC_DRAW);
      
      tessGeo.updatePolySpecularBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolySpecular.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
        tessGeo.polySpecularBuffer, PGL.STATIC_DRAW);
      
      tessGeo.updatePolyEmissiveBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyEmissive.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
        tessGeo.polyEmissiveBuffer, PGL.STATIC_DRAW);
      
      tessGeo.updatePolyShininessBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyShininess.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, sizef, 
        tessGeo.polyShininessBuffer, PGL.STATIC_DRAW);
    }
    
    if ((lit) || (needNormals)) {
      tessGeo.updatePolyNormalsBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyNormal.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, 3 * sizef, 
        tessGeo.polyNormalsBuffer, PGL.STATIC_DRAW);
    }
    
    if ((tex) || (needTexCoords)) {
      tessGeo.updatePolyTexCoordsBuffer();
      pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyTexcoord.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, 2 * sizef, 
        tessGeo.polyTexCoordsBuffer, PGL.STATIC_DRAW);
    }
    
    for (String name : polyAttribs.keySet()) {
      VertexAttribute attrib = (VertexAttribute)polyAttribs.get(name);
      tessGeo.updateAttribBuffer(name);
      pgl.bindBuffer(PGL.ARRAY_BUFFER, buf.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, attrib.sizeInBytes(size), 
        (Buffer)tessGeo.polyAttribBuffers.get(name), PGL.STATIC_DRAW);
    }
    
    tessGeo.updatePolyIndicesBuffer();
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufPolyIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.polyIndexCount * PGL.SIZEOF_INDEX, tessGeo.polyIndicesBuffer, 
      PGL.STATIC_DRAW);
  }
  
  protected void unbindPolyBuffers()
  {
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected boolean polyBuffersContextIsOutdated()
  {
    return !pgl.contextIsCurrent(polyBuffersContext);
  }
  
  protected void createLineBuffers()
  {
    if ((!lineBuffersCreated) || (lineBufferContextIsOutdated())) {
      lineBuffersContext = pgl.getCurrentContext();
      
      bufLineVertex = new VertexBuffer(this, PGL.ARRAY_BUFFER, 3, PGL.SIZEOF_FLOAT);
      bufLineColor = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufLineAttrib = new VertexBuffer(this, PGL.ARRAY_BUFFER, 4, PGL.SIZEOF_FLOAT);
      pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
      bufLineIndex = new VertexBuffer(this, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
      pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
      
      lineBuffersCreated = true;
    }
  }
  
  protected void updateLineBuffers()
  {
    createLineBuffers();
    
    int size = tessGeo.lineVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    


    tessGeo.updateLineVerticesBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, tessGeo.lineVerticesBuffer, 
      PGL.STATIC_DRAW);
    
    tessGeo.updateLineColorsBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.lineColorsBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updateLineDirectionsBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineAttrib.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.lineDirectionsBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updateLineIndicesBuffer();
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufLineIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.lineIndexCount * PGL.SIZEOF_INDEX, 
      tessGeo.lineIndicesBuffer, PGL.STATIC_DRAW);
  }
  
  protected void unbindLineBuffers()
  {
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected boolean lineBufferContextIsOutdated()
  {
    return !pgl.contextIsCurrent(lineBuffersContext);
  }
  
  protected void createPointBuffers()
  {
    if ((!pointBuffersCreated) || (pointBuffersContextIsOutdated())) {
      pointBuffersContext = pgl.getCurrentContext();
      
      bufPointVertex = new VertexBuffer(this, PGL.ARRAY_BUFFER, 3, PGL.SIZEOF_FLOAT);
      bufPointColor = new VertexBuffer(this, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
      bufPointAttrib = new VertexBuffer(this, PGL.ARRAY_BUFFER, 2, PGL.SIZEOF_FLOAT);
      pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
      bufPointIndex = new VertexBuffer(this, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
      pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
      
      pointBuffersCreated = true;
    }
  }
  
  protected void updatePointBuffers()
  {
    createPointBuffers();
    
    int size = tessGeo.pointVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    
    tessGeo.updatePointVerticesBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.pointVerticesBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updatePointColorsBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.pointColorsBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updatePointOffsetsBuffer();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointAttrib.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 2 * sizef, 
      tessGeo.pointOffsetsBuffer, PGL.STATIC_DRAW);
    
    tessGeo.updatePointIndicesBuffer();
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufPointIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.pointIndexCount * PGL.SIZEOF_INDEX, 
      tessGeo.pointIndicesBuffer, PGL.STATIC_DRAW);
  }
  
  protected void unbindPointBuffers()
  {
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected boolean pointBuffersContextIsOutdated()
  {
    return !pgl.contextIsCurrent(pointBuffersContext);
  }
  

  public void beginDraw()
  {
    if (primaryGraphics) {
      if (!initialized) {
        initPrimary();
      }
      setCurrentPG(this);
    } else {
      pgl.getGL(getPrimaryPGL());
      getPrimaryPG().setCurrentPG(this);
    }
    
    if (!pgl.threadIsCurrent()) {
      PGraphics.showWarning("You are trying to draw outside OpenGL's animation thread.\nPlace all drawing commands in the draw() function, or inside\nyour own functions as long as they are called from draw(),\nbut not in event handling functions such as keyPressed()\nor mousePressed().");
      return;
    }
    


    report("top beginDraw()");
    
    if (!checkGLThread()) {
      return;
    }
    
    if (drawing) {
      return;
    }
    
    if ((!primaryGraphics) && (getPrimaryPGtexCache.containsTexture(this)))
    {


      getPrimaryPG().flush();
    }
    
    if (!glParamsRead) {
      getGLParameters();
    }
    
    setViewport();
    if (primaryGraphics) {
      beginOnscreenDraw();
    } else {
      beginOffscreenDraw();
    }
    checkSettings();
    
    drawing = true;
    
    report("bot beginDraw()");
  }
  

  public void endDraw()
  {
    report("top endDraw()");
    
    if (!drawing) {
      return;
    }
    

    flush();
    
    if (primaryGraphics) {
      endOnscreenDraw();
    } else {
      endOffscreenDraw();
    }
    
    if (primaryGraphics) {
      setCurrentPG(null);
    } else {
      getPrimaryPG().setCurrentPG();
    }
    drawing = false;
    
    report("bot endDraw()");
  }
  
  protected PGraphicsOpenGL getPrimaryPG()
  {
    if (primaryGraphics) {
      return this;
    }
    return (PGraphicsOpenGL)parent.g;
  }
  
  protected void setCurrentPG(PGraphicsOpenGL pg)
  {
    currentPG = pg;
  }
  
  protected void setCurrentPG() {
    currentPG = this;
  }
  
  protected PGraphicsOpenGL getCurrentPG() {
    return currentPG;
  }
  
  protected PGL getPrimaryPGL() {
    if (primaryGraphics) {
      return pgl;
    }
    return parent.g).pgl;
  }
  


  public PGL beginPGL()
  {
    flush();
    pgl.beginGL();
    return pgl;
  }
  

  public void endPGL()
  {
    pgl.endGL();
    restoreGL();
  }
  
  public void updateProjmodelview()
  {
    projmodelview.set(projection);
    projmodelview.apply(modelview);
  }
  
  protected void restartPGL()
  {
    initialized = false;
  }
  
  protected void restoreGL()
  {
    blendMode(blendMode);
    
    if (hints[2] != 0) {
      pgl.disable(PGL.DEPTH_TEST);
    } else {
      pgl.enable(PGL.DEPTH_TEST);
    }
    pgl.depthFunc(PGL.LEQUAL);
    
    if (!OPENGL_RENDERER.equals("VideoCore IV HW"))
    {

      if (smooth < 1) {
        pgl.disable(PGL.MULTISAMPLE);
      } else if (1 <= smooth) {
        pgl.enable(PGL.MULTISAMPLE);
        pgl.disable(PGL.POLYGON_SMOOTH);
      }
    }
    pgl.viewport(viewport.get(0), viewport.get(1), 
      viewport.get(2), viewport.get(3));
    if (clip) {
      pgl.enable(PGL.SCISSOR_TEST);
      pgl.scissor(clipRect[0], clipRect[1], clipRect[2], clipRect[3]);
    } else {
      pgl.disable(PGL.SCISSOR_TEST);
    }
    
    pgl.frontFace(PGL.CW);
    pgl.disable(PGL.CULL_FACE);
    
    pgl.activeTexture(PGL.TEXTURE0);
    
    if (hints[5] != 0) {
      pgl.depthMask(false);
    } else {
      pgl.depthMask(true);
    }
    
    FrameBuffer fb = getCurrentFB();
    if (fb != null) {
      fb.bind();
      if (drawBufferSupported) { pgl.drawBuffer(fb.getDefaultDrawBuffer());
      }
    }
  }
  
  protected void beginBindFramebuffer(int target, int framebuffer) {}
  
  protected void endBindFramebuffer(int target, int framebuffer)
  {
    FrameBuffer fb = getCurrentFB();
    if ((framebuffer == 0) && (fb != null) && (glFbo != 0))
    {

      fb.bind();
    }
  }
  
  protected void beginReadPixels() {
    beginPixelsOp(1);
  }
  
  protected void endReadPixels() {
    endPixelsOp();
  }
  
  protected void beginPixelsOp(int op) {
    FrameBuffer pixfb = null;
    if (primaryGraphics) {
      if (op == 1) {
        if ((pgl.isFBOBacked()) && (pgl.isMultisampled()))
        {
          pgl.syncBackTexture();
          

          pixfb = readFramebuffer;
        } else {
          pixfb = drawFramebuffer;
        }
      } else if (op == 2)
      {

        pixfb = drawFramebuffer;
      }
    } else {
      FrameBuffer ofb = offscreenFramebuffer;
      FrameBuffer mfb = multisampleFramebuffer;
      if (op == 1) {
        if (offscreenMultisample)
        {
          int mask = PGL.COLOR_BUFFER_BIT;
          if (hints[10] != 0) {
            mask |= PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT;
          }
          if ((ofb != null) && (mfb != null)) {
            mfb.copy(ofb, mask);
          }
        }
        
        pixfb = ofb;
      } else if (op == 2)
      {

        pixfb = offscreenMultisample ? mfb : ofb;
      }
    }
    

    if ((pixfb != null) && (pixfb != getCurrentFB())) {
      pushFramebuffer();
      setFramebuffer(pixfb);
      pixOpChangedFB = true;
    }
    

    if (op == 1) {
      if (readBufferSupported) pgl.readBuffer(getCurrentFB().getDefaultDrawBuffer());
    } else if ((op == 2) && 
      (drawBufferSupported)) { pgl.drawBuffer(getCurrentFB().getDefaultDrawBuffer());
    }
    
    pixelsOp = op;
  }
  

  protected void endPixelsOp()
  {
    if (pixOpChangedFB) {
      popFramebuffer();
      pixOpChangedFB = false;
    }
    

    if (readBufferSupported) pgl.readBuffer(getCurrentFB().getDefaultReadBuffer());
    if (drawBufferSupported) { pgl.drawBuffer(getCurrentFB().getDefaultDrawBuffer());
    }
    pixelsOp = 0;
  }
  
  protected void updateGLProjection()
  {
    if (glProjection == null) {
      glProjection = new float[16];
    }
    
    glProjection[0] = projection.m00;
    glProjection[1] = projection.m10;
    glProjection[2] = projection.m20;
    glProjection[3] = projection.m30;
    
    glProjection[4] = projection.m01;
    glProjection[5] = projection.m11;
    glProjection[6] = projection.m21;
    glProjection[7] = projection.m31;
    
    glProjection[8] = projection.m02;
    glProjection[9] = projection.m12;
    glProjection[10] = projection.m22;
    glProjection[11] = projection.m32;
    
    glProjection[12] = projection.m03;
    glProjection[13] = projection.m13;
    glProjection[14] = projection.m23;
    glProjection[15] = projection.m33;
  }
  
  protected void updateGLModelview()
  {
    if (glModelview == null) {
      glModelview = new float[16];
    }
    
    glModelview[0] = modelview.m00;
    glModelview[1] = modelview.m10;
    glModelview[2] = modelview.m20;
    glModelview[3] = modelview.m30;
    
    glModelview[4] = modelview.m01;
    glModelview[5] = modelview.m11;
    glModelview[6] = modelview.m21;
    glModelview[7] = modelview.m31;
    
    glModelview[8] = modelview.m02;
    glModelview[9] = modelview.m12;
    glModelview[10] = modelview.m22;
    glModelview[11] = modelview.m32;
    
    glModelview[12] = modelview.m03;
    glModelview[13] = modelview.m13;
    glModelview[14] = modelview.m23;
    glModelview[15] = modelview.m33;
  }
  
  protected void updateGLProjmodelview()
  {
    if (glProjmodelview == null) {
      glProjmodelview = new float[16];
    }
    
    glProjmodelview[0] = projmodelview.m00;
    glProjmodelview[1] = projmodelview.m10;
    glProjmodelview[2] = projmodelview.m20;
    glProjmodelview[3] = projmodelview.m30;
    
    glProjmodelview[4] = projmodelview.m01;
    glProjmodelview[5] = projmodelview.m11;
    glProjmodelview[6] = projmodelview.m21;
    glProjmodelview[7] = projmodelview.m31;
    
    glProjmodelview[8] = projmodelview.m02;
    glProjmodelview[9] = projmodelview.m12;
    glProjmodelview[10] = projmodelview.m22;
    glProjmodelview[11] = projmodelview.m32;
    
    glProjmodelview[12] = projmodelview.m03;
    glProjmodelview[13] = projmodelview.m13;
    glProjmodelview[14] = projmodelview.m23;
    glProjmodelview[15] = projmodelview.m33;
  }
  
  protected void updateGLNormal()
  {
    if (glNormal == null) {
      glNormal = new float[9];
    }
    




    glNormal[0] = modelviewInv.m00;
    glNormal[1] = modelviewInv.m01;
    glNormal[2] = modelviewInv.m02;
    
    glNormal[3] = modelviewInv.m10;
    glNormal[4] = modelviewInv.m11;
    glNormal[5] = modelviewInv.m12;
    
    glNormal[6] = modelviewInv.m20;
    glNormal[7] = modelviewInv.m21;
    glNormal[8] = modelviewInv.m22;
  }
  








  protected void defaultSettings()
  {
    super.defaultSettings();
    
    manipulatingCamera = false;
    

    textureMode(2);
    

    ambient(255);
    specular(125);
    emissive(0);
    shininess(1.0F);
    

    setAmbient = false;
  }
  








  public void hint(int which)
  {
    boolean oldValue = hints[PApplet.abs(which)];
    super.hint(which);
    boolean newValue = hints[PApplet.abs(which)];
    
    if (oldValue == newValue) {
      return;
    }
    
    if (which == 2) {
      flush();
      pgl.disable(PGL.DEPTH_TEST);
    } else if (which == -2) {
      flush();
      pgl.enable(PGL.DEPTH_TEST);
    } else if (which == 5) {
      flush();
      pgl.depthMask(false);
    } else if (which == -5) {
      flush();
      pgl.depthMask(true);
    } else if (which == -6) {
      flush();
      setFlushMode(1);
    } else if (which == 6) {
      if (is2D()) {
        PGraphics.showWarning("Optimized strokes can only be disabled in 3D");
      } else {
        flush();
        setFlushMode(0);
      }
    } else if (which == -7) {
      if ((tessGeo.lineVertexCount > 0) && (tessGeo.lineIndexCount > 0))
      {
        flush();
      }
    } else if (which == 7) {
      if ((tessGeo.lineVertexCount > 0) && (tessGeo.lineIndexCount > 0))
      {
        flush();
      }
    } else if (which == 3) {
      if (is3D()) {
        flush();
        if (sorter == null) sorter = new DepthSorter(this);
        isDepthSortingEnabled = true;
      } else {
        PGraphics.showWarning("Depth sorting can only be enabled in 3D");
      }
    } else if (which == -3) {
      if (is3D()) {
        flush();
        isDepthSortingEnabled = false;
      }
    } else if (which == 10) {
      restartPGL();
    } else if (which == -10) {
      restartPGL();
    }
  }
  
  protected boolean getHint(int which)
  {
    if (which > 0) {
      return hints[which];
    }
    return hints[(-which)] == 0;
  }
  







  protected PShape createShapeFamily(int type)
  {
    PShape shape = new PShapeOpenGL(this, type);
    if (is3D()) {
      shape.set3D(true);
    }
    return shape;
  }
  

  protected PShape createShapePrimitive(int kind, float... p)
  {
    PShape shape = new PShapeOpenGL(this, kind, p);
    if (is3D()) {
      shape.set3D(true);
    }
    return shape;
  }
  







  public void beginShape(int kind)
  {
    shape = kind;
    inGeo.clear();
    
    curveVertexCount = 0;
    breakShape = false;
    defaultEdges = true;
    

    super.noTexture();
    
    normalMode = 0;
  }
  

  public void endShape(int mode)
  {
    tessellate(mode);
    
    if ((flushMode == 0) || (
      (flushMode == 1) && (tessGeo.isFull()))) {
      flush();
    }
    else {
      loaded = false;
    }
  }
  
  protected void endShape(int[] indices)
  {
    if ((shape != 8) && (shape != 9)) {
      throw new RuntimeException("Indices and edges can only be set for TRIANGLE shapes");
    }
    

    tessellate(indices);
    
    if ((flushMode == 0) || (
      (flushMode == 1) && (tessGeo.isFull()))) {
      flush();
    }
    else {
      loaded = false;
    }
  }
  

  public void textureWrap(int wrap)
  {
    textureWrap = wrap;
  }
  
  public void textureSampling(int sampling)
  {
    textureSampling = sampling;
  }
  

  public void beginContour()
  {
    if (openContour) {
      PGraphics.showWarning("Already called beginContour()");
      return;
    }
    openContour = true;
    breakShape = true;
  }
  

  public void endContour()
  {
    if (!openContour) {
      PGraphics.showWarning("Need to call beginContour() first");
      return;
    }
    openContour = false;
  }
  

  public void vertex(float x, float y)
  {
    vertexImpl(x, y, 0.0F, 0.0F, 0.0F);
    if (textureImage != null) { PGraphics.showWarning("No uv texture coordinates supplied with vertex() call");
    }
  }
  
  public void vertex(float x, float y, float u, float v)
  {
    vertexImpl(x, y, 0.0F, u, v);
  }
  

  public void vertex(float x, float y, float z)
  {
    vertexImpl(x, y, z, 0.0F, 0.0F);
    if (textureImage != null) { PGraphics.showWarning("No uv texture coordinates supplied with vertex() call");
    }
  }
  
  public void vertex(float x, float y, float z, float u, float v)
  {
    vertexImpl(x, y, z, u, v);
  }
  

  public void attribPosition(String name, float x, float y, float z)
  {
    VertexAttribute attrib = attribImpl(name, 0, 
      PGL.FLOAT, 3);
    if (attrib != null) { attrib.set(x, y, z);
    }
  }
  
  public void attribNormal(String name, float nx, float ny, float nz)
  {
    VertexAttribute attrib = attribImpl(name, 1, 
      PGL.FLOAT, 3);
    if (attrib != null) { attrib.set(nx, ny, nz);
    }
  }
  
  public void attribColor(String name, int color)
  {
    VertexAttribute attrib = attribImpl(name, 2, PGL.INT, 1);
    if (attrib != null) { attrib.set(new int[] { color });
    }
  }
  
  public void attrib(String name, float... values)
  {
    VertexAttribute attrib = attribImpl(name, 3, 
      PGL.FLOAT, values.length);
    if (attrib != null) { attrib.set(values);
    }
  }
  
  public void attrib(String name, int... values)
  {
    VertexAttribute attrib = attribImpl(name, 3, 
      PGL.INT, values.length);
    if (attrib != null) { attrib.set(values);
    }
  }
  
  public void attrib(String name, boolean... values)
  {
    VertexAttribute attrib = attribImpl(name, 3, 
      PGL.BOOL, values.length);
    if (attrib != null) attrib.set(values);
  }
  
  protected VertexAttribute attribImpl(String name, int kind, int type, int size)
  {
    if (4 < size) {
      PGraphics.showWarning("Vertex attributes cannot have more than 4 values");
      return null;
    }
    VertexAttribute attrib = (VertexAttribute)polyAttribs.get(name);
    if (attrib == null) {
      attrib = new VertexAttribute(this, name, kind, type, size);
      polyAttribs.put(name, attrib);
      inGeo.initAttrib(attrib);
      tessGeo.initAttrib(attrib);
    }
    if (kind != kind) {
      PGraphics.showWarning("The attribute kind cannot be changed after creation");
      return null;
    }
    if (type != type) {
      PGraphics.showWarning("The attribute type cannot be changed after creation");
      return null;
    }
    if (size != size) {
      PGraphics.showWarning("New value for vertex attribute has wrong number of values");
      return null;
    }
    return attrib;
  }
  
  protected void vertexImpl(float x, float y, float z, float u, float v)
  {
    boolean textured = textureImage != null;
    int fcolor = 0;
    if ((fill) || (textured)) {
      if (!textured) {
        fcolor = fillColor;
      }
      else if (tint) {
        fcolor = tintColor;
      } else {
        fcolor = -1;
      }
    }
    

    int scolor = 0;
    float sweight = 0.0F;
    if (stroke) {
      scolor = strokeColor;
      sweight = strokeWeight;
    }
    
    if ((textured) && (textureMode == 2)) {
      u /= textureImage.width;
      v /= textureImage.height;
    }
    
    inGeo.addVertex(x, y, z, 
      fcolor, 
      normalX, normalY, normalZ, 
      u, v, 
      scolor, sweight, 
      ambientColor, specularColor, emissiveColor, shininess, 
      0, vertexBreak());
  }
  
  protected boolean vertexBreak()
  {
    if (breakShape) {
      breakShape = false;
      return true;
    }
    return false;
  }
  

  protected void clipImpl(float x1, float y1, float x2, float y2)
  {
    flush();
    pgl.enable(PGL.SCISSOR_TEST);
    
    float h = y2 - y1;
    clipRect[0] = ((int)x1);
    clipRect[1] = ((int)(height - y1 - h));
    clipRect[2] = ((int)(x2 - x1));
    clipRect[3] = ((int)h);
    pgl.scissor(clipRect[0], clipRect[1], clipRect[2], clipRect[3]);
    
    clip = true;
  }
  

  public void noClip()
  {
    if (clip) {
      flush();
      pgl.disable(PGL.SCISSOR_TEST);
      clip = false;
    }
  }
  









  protected void tessellate(int mode)
  {
    tessellator.setInGeometry(inGeo);
    tessellator.setTessGeometry(tessGeo);
    tessellator.setFill((fill) || (textureImage != null));
    tessellator.setTexCache(texCache, textureImage);
    tessellator.setStroke(stroke);
    tessellator.setStrokeColor(strokeColor);
    tessellator.setStrokeWeight(strokeWeight);
    tessellator.setStrokeCap(strokeCap);
    tessellator.setStrokeJoin(strokeJoin);
    tessellator.setRenderer(this);
    tessellator.setTransform(modelview);
    tessellator.set3D(is3D());
    
    if (shape == 3) {
      tessellator.tessellatePoints();
    } else if (shape == 5) {
      tessellator.tessellateLines();
    } else if (shape == 50) {
      tessellator.tessellateLineStrip();
    } else if (shape == 51) {
      tessellator.tessellateLineLoop();
    } else if ((shape == 8) || (shape == 9)) {
      if ((stroke) && (defaultEdges)) inGeo.addTrianglesEdges();
      if (normalMode == 0) inGeo.calcTrianglesNormals();
      tessellator.tessellateTriangles();
    } else if (shape == 11) {
      if ((stroke) && (defaultEdges)) inGeo.addTriangleFanEdges();
      if (normalMode == 0) inGeo.calcTriangleFanNormals();
      tessellator.tessellateTriangleFan();
    } else if (shape == 10) {
      if ((stroke) && (defaultEdges)) inGeo.addTriangleStripEdges();
      if (normalMode == 0) inGeo.calcTriangleStripNormals();
      tessellator.tessellateTriangleStrip();
    } else if ((shape == 16) || (shape == 17)) {
      if ((stroke) && (defaultEdges)) inGeo.addQuadsEdges();
      if (normalMode == 0) inGeo.calcQuadsNormals();
      tessellator.tessellateQuads();
    } else if (shape == 18) {
      if ((stroke) && (defaultEdges)) inGeo.addQuadStripEdges();
      if (normalMode == 0) inGeo.calcQuadStripNormals();
      tessellator.tessellateQuadStrip();
    } else if (shape == 20) {
      tessellator.tessellatePolygon(true, mode == 2, 
        normalMode == 0);
    }
  }
  
  protected void tessellate(int[] indices)
  {
    tessellator.setInGeometry(inGeo);
    tessellator.setTessGeometry(tessGeo);
    tessellator.setFill((fill) || (textureImage != null));
    tessellator.setStroke(stroke);
    tessellator.setStrokeColor(strokeColor);
    tessellator.setStrokeWeight(strokeWeight);
    tessellator.setStrokeCap(strokeCap);
    tessellator.setStrokeJoin(strokeJoin);
    tessellator.setTexCache(texCache, textureImage);
    tessellator.setTransform(modelview);
    tessellator.set3D(is3D());
    
    if ((stroke) && (defaultEdges)) inGeo.addTrianglesEdges();
    if (normalMode == 0) inGeo.calcTrianglesNormals();
    tessellator.tessellateTriangles(indices);
  }
  

  public void flush()
  {
    boolean hasPolys = (tessGeo.polyVertexCount > 0) && (
      tessGeo.polyIndexCount > 0);
    boolean hasLines = (tessGeo.lineVertexCount > 0) && (
      tessGeo.lineIndexCount > 0);
    boolean hasPoints = (tessGeo.pointVertexCount > 0) && (
      tessGeo.pointIndexCount > 0);
    
    boolean hasPixels = (modified) && (pixels != null);
    
    if (hasPixels)
    {


      flushPixels();
    }
    
    if ((hasPoints) || (hasLines) || (hasPolys)) {
      PMatrix3D modelview0 = null;
      PMatrix3D modelviewInv0 = null;
      if (flushMode == 1)
      {





        modelview0 = modelview;
        modelviewInv0 = modelviewInv;
        modelview = (this.modelviewInv = identity);
        projmodelview.set(projection);
      }
      
      if ((hasPolys) && (!isDepthSortingEnabled)) {
        flushPolys();
        if (raw != null) {
          rawPolys();
        }
      }
      
      if (is3D()) {
        if (hasLines) {
          flushLines();
          if (raw != null) {
            rawLines();
          }
        }
        
        if (hasPoints) {
          flushPoints();
          if (raw != null) {
            rawPoints();
          }
        }
      }
      
      if ((hasPolys) && (isDepthSortingEnabled))
      {

        flushSortedPolys();
        if (raw != null) {
          rawSortedPolys();
        }
      }
      
      if (flushMode == 1) {
        modelview = modelview0;
        modelviewInv = modelviewInv0;
        updateProjmodelview();
      }
      
      loaded = false;
    }
    
    tessGeo.clear();
    texCache.clear();
  }
  
  protected void flushPixels()
  {
    drawPixels(mx1, my1, mx2 - mx1, my2 - my1);
    modified = false;
  }
  
  protected void flushPolys()
  {
    boolean customShader = polyShader != null;
    boolean needNormals = customShader ? polyShader.accessNormals() : false;
    boolean needTexCoords = customShader ? polyShader.accessTexCoords() : false;
    
    updatePolyBuffers(lights, texCache.hasTextures, needNormals, needTexCoords);
    
    for (int i = 0; i < texCache.size; i++) {
      Texture tex = texCache.getTexture(i);
      


      PShader shader = getPolyShader(lights, tex != null);
      shader.bind();
      
      int first = texCache.firstCache[i];
      int last = texCache.lastCache[i];
      IndexCache cache = tessGeo.polyIndexCache;
      int ioffset;
      for (int n = first; n <= last; n++) {
        ioffset = n == first ? texCache.firstIndex[i] : indexOffset[n];
        int icount = n == last ? texCache.lastIndex[i] - ioffset + 1 : 
          indexOffset[n] + indexCount[n] - ioffset;
        int voffset = vertexOffset[n];
        
        shader.setVertexAttribute(bufPolyVertex.glId, 4, PGL.FLOAT, 0, 
          4 * voffset * PGL.SIZEOF_FLOAT);
        shader.setColorAttribute(bufPolyColor.glId, 4, PGL.UNSIGNED_BYTE, 0, 
          4 * voffset * PGL.SIZEOF_BYTE);
        
        if (lights) {
          shader.setNormalAttribute(bufPolyNormal.glId, 3, PGL.FLOAT, 0, 
            3 * voffset * PGL.SIZEOF_FLOAT);
          shader.setAmbientAttribute(bufPolyAmbient.glId, 4, PGL.UNSIGNED_BYTE, 0, 
            4 * voffset * PGL.SIZEOF_BYTE);
          shader.setSpecularAttribute(bufPolySpecular.glId, 4, PGL.UNSIGNED_BYTE, 0, 
            4 * voffset * PGL.SIZEOF_BYTE);
          shader.setEmissiveAttribute(bufPolyEmissive.glId, 4, PGL.UNSIGNED_BYTE, 0, 
            4 * voffset * PGL.SIZEOF_BYTE);
          shader.setShininessAttribute(bufPolyShininess.glId, 1, PGL.FLOAT, 0, 
            voffset * PGL.SIZEOF_FLOAT);
        }
        
        if ((lights) || (needNormals)) {
          shader.setNormalAttribute(bufPolyNormal.glId, 3, PGL.FLOAT, 0, 
            3 * voffset * PGL.SIZEOF_FLOAT);
        }
        
        if ((tex != null) || (needTexCoords)) {
          shader.setTexcoordAttribute(bufPolyTexcoord.glId, 2, PGL.FLOAT, 0, 
            2 * voffset * PGL.SIZEOF_FLOAT);
          shader.setTexture(tex);
        }
        
        for (VertexAttribute attrib : polyAttribs.values()) {
          if (attrib.active(shader)) {
            attrib.bind(pgl);
            shader.setAttributeVBO(glLoc, buf.glId, 
              tessSize, type, 
              attrib.isColor(), 0, attrib.sizeInBytes(voffset));
          }
        }
        shader.draw(bufPolyIndex.glId, icount, ioffset);
      }
      
      for (VertexAttribute attrib : polyAttribs.values()) {
        if (attrib.active(shader)) attrib.unbind(pgl);
      }
      shader.unbind();
    }
    unbindPolyBuffers();
  }
  
  protected void flushSortedPolys() {
    boolean customShader = polyShader != null;
    boolean needNormals = customShader ? polyShader.accessNormals() : false;
    boolean needTexCoords = customShader ? polyShader.accessTexCoords() : false;
    
    sorter.sort(tessGeo);
    
    int triangleCount = tessGeo.polyIndexCount / 3;
    int[] texMap = sorter.texMap;
    int[] voffsetMap = sorter.voffsetMap;
    
    int[] vertexOffset = tessGeo.polyIndexCache.vertexOffset;
    
    updatePolyBuffers(lights, texCache.hasTextures, needNormals, needTexCoords);
    
    int ti = 0;
    
    while (ti < triangleCount)
    {
      int startTi = ti;
      int texId = texMap[ti];
      int voffsetId = voffsetMap[ti];
      do
      {
        ti++;
      } while ((ti < triangleCount) && 
        (texId == texMap[ti]) && 
        (voffsetId == voffsetMap[ti]));
      
      int endTi = ti;
      
      Texture tex = texCache.getTexture(texId);
      
      int voffset = vertexOffset[voffsetId];
      
      int ioffset = 3 * startTi;
      int icount = 3 * (endTi - startTi);
      


      PShader shader = getPolyShader(lights, tex != null);
      shader.bind();
      
      shader.setVertexAttribute(bufPolyVertex.glId, 4, PGL.FLOAT, 0, 
        4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(bufPolyColor.glId, 4, PGL.UNSIGNED_BYTE, 0, 
        4 * voffset * PGL.SIZEOF_BYTE);
      
      if (lights) {
        shader.setNormalAttribute(bufPolyNormal.glId, 3, PGL.FLOAT, 0, 
          3 * voffset * PGL.SIZEOF_FLOAT);
        shader.setAmbientAttribute(bufPolyAmbient.glId, 4, PGL.UNSIGNED_BYTE, 0, 
          4 * voffset * PGL.SIZEOF_BYTE);
        shader.setSpecularAttribute(bufPolySpecular.glId, 4, PGL.UNSIGNED_BYTE, 0, 
          4 * voffset * PGL.SIZEOF_BYTE);
        shader.setEmissiveAttribute(bufPolyEmissive.glId, 4, PGL.UNSIGNED_BYTE, 0, 
          4 * voffset * PGL.SIZEOF_BYTE);
        shader.setShininessAttribute(bufPolyShininess.glId, 1, PGL.FLOAT, 0, 
          voffset * PGL.SIZEOF_FLOAT);
      }
      
      if ((lights) || (needNormals)) {
        shader.setNormalAttribute(bufPolyNormal.glId, 3, PGL.FLOAT, 0, 
          3 * voffset * PGL.SIZEOF_FLOAT);
      }
      
      if ((tex != null) || (needTexCoords)) {
        shader.setTexcoordAttribute(bufPolyTexcoord.glId, 2, PGL.FLOAT, 0, 
          2 * voffset * PGL.SIZEOF_FLOAT);
        shader.setTexture(tex);
      }
      
      for (VertexAttribute attrib : polyAttribs.values()) {
        if (attrib.active(shader)) {
          attrib.bind(pgl);
          shader.setAttributeVBO(glLoc, buf.glId, 
            tessSize, type, 
            attrib.isColor(), 0, attrib.sizeInBytes(voffset));
        }
      }
      shader.draw(bufPolyIndex.glId, icount, ioffset);
      
      for (VertexAttribute attrib : polyAttribs.values()) {
        if (attrib.active(shader)) attrib.unbind(pgl);
      }
      shader.unbind();
    }
    unbindPolyBuffers();
  }
  
  void rawPolys()
  {
    raw.colorMode(1);
    raw.noStroke();
    raw.beginShape(9);
    
    float[] vertices = tessGeo.polyVertices;
    int[] color = tessGeo.polyColors;
    float[] uv = tessGeo.polyTexCoords;
    short[] indices = tessGeo.polyIndices;
    
    for (int i = 0; i < texCache.size; i++) {
      PImage textureImage = texCache.getTextureImage(i);
      
      int first = texCache.firstCache[i];
      int last = texCache.lastCache[i];
      IndexCache cache = tessGeo.polyIndexCache;
      for (int n = first; n <= last; n++) {
        int ioffset = n == first ? texCache.firstIndex[i] : 
          indexOffset[n];
        int icount = n == last ? texCache.lastIndex[i] - ioffset + 1 : 
          indexOffset[n] + indexCount[n] - 
          ioffset;
        int voffset = vertexOffset[n];
        
        for (int tr = ioffset / 3; tr < (ioffset + icount) / 3; tr++) {
          int i0 = voffset + indices[(3 * tr + 0)];
          int i1 = voffset + indices[(3 * tr + 1)];
          int i2 = voffset + indices[(3 * tr + 2)];
          
          float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] pt1 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] pt2 = { 0.0F, 0.0F, 0.0F, 0.0F };
          int argb0 = PGL.nativeToJavaARGB(color[i0]);
          int argb1 = PGL.nativeToJavaARGB(color[i1]);
          int argb2 = PGL.nativeToJavaARGB(color[i2]);
          
          if (flushMode == 0) {
            float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
            float[] src1 = { 0.0F, 0.0F, 0.0F, 0.0F };
            float[] src2 = { 0.0F, 0.0F, 0.0F, 0.0F };
            PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i1, src1, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i2, src2, 0, 4);
            modelview.mult(src0, pt0);
            modelview.mult(src1, pt1);
            modelview.mult(src2, pt2);
          } else {
            PApplet.arrayCopy(vertices, 4 * i0, pt0, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i1, pt1, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i2, pt2, 0, 4);
          }
          
          if (textureImage != null) {
            raw.texture(textureImage);
            if (raw.is3D()) {
              raw.fill(argb0);
              raw.vertex(pt0[0], pt0[1], pt0[2], uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
              raw.fill(argb1);
              raw.vertex(pt1[0], pt1[1], pt1[2], uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
              raw.fill(argb2);
              raw.vertex(pt2[0], pt2[1], pt2[2], uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
            } else if (raw.is2D()) {
              float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
              float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
              float sx1 = screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
              float sy1 = screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
              float sx2 = screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
              float sy2 = screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
              raw.fill(argb0);
              raw.vertex(sx0, sy0, uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
              raw.fill(argb1);
              raw.vertex(sx1, sy1, uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
              raw.fill(argb1);
              raw.vertex(sx2, sy2, uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
            }
          }
          else if (raw.is3D()) {
            raw.fill(argb0);
            raw.vertex(pt0[0], pt0[1], pt0[2]);
            raw.fill(argb1);
            raw.vertex(pt1[0], pt1[1], pt1[2]);
            raw.fill(argb2);
            raw.vertex(pt2[0], pt2[1], pt2[2]);
          } else if (raw.is2D()) {
            float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sx1 = screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sy1 = screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sx2 = screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
            float sy2 = screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
            raw.fill(argb0);
            raw.vertex(sx0, sy0);
            raw.fill(argb1);
            raw.vertex(sx1, sy1);
            raw.fill(argb2);
            raw.vertex(sx2, sy2);
          }
        }
      }
    }
    


    raw.endShape();
  }
  
  void rawSortedPolys()
  {
    raw.colorMode(1);
    raw.noStroke();
    raw.beginShape(9);
    
    float[] vertices = tessGeo.polyVertices;
    int[] color = tessGeo.polyColors;
    float[] uv = tessGeo.polyTexCoords;
    short[] indices = tessGeo.polyIndices;
    
    sorter.sort(tessGeo);
    int[] triangleIndices = sorter.triangleIndices;
    int[] texMap = sorter.texMap;
    int[] voffsetMap = sorter.voffsetMap;
    
    int[] vertexOffset = tessGeo.polyIndexCache.vertexOffset;
    
    for (int i = 0; i < tessGeo.polyIndexCount / 3; i++) {
      int ti = triangleIndices[i];
      PImage tex = texCache.getTextureImage(texMap[ti]);
      int voffset = vertexOffset[voffsetMap[ti]];
      
      int i0 = voffset + indices[(3 * ti + 0)];
      int i1 = voffset + indices[(3 * ti + 1)];
      int i2 = voffset + indices[(3 * ti + 2)];
      
      float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
      float[] pt1 = { 0.0F, 0.0F, 0.0F, 0.0F };
      float[] pt2 = { 0.0F, 0.0F, 0.0F, 0.0F };
      int argb0 = PGL.nativeToJavaARGB(color[i0]);
      int argb1 = PGL.nativeToJavaARGB(color[i1]);
      int argb2 = PGL.nativeToJavaARGB(color[i2]);
      
      if (flushMode == 0) {
        float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] src1 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] src2 = { 0.0F, 0.0F, 0.0F, 0.0F };
        PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i1, src1, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i2, src2, 0, 4);
        modelview.mult(src0, pt0);
        modelview.mult(src1, pt1);
        modelview.mult(src2, pt2);
      } else {
        PApplet.arrayCopy(vertices, 4 * i0, pt0, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i1, pt1, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i2, pt2, 0, 4);
      }
      
      if (tex != null) {
        raw.texture(tex);
        if (raw.is3D()) {
          raw.fill(argb0);
          raw.vertex(pt0[0], pt0[1], pt0[2], uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
          raw.fill(argb1);
          raw.vertex(pt1[0], pt1[1], pt1[2], uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
          raw.fill(argb2);
          raw.vertex(pt2[0], pt2[1], pt2[2], uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
        } else if (raw.is2D()) {
          float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sx1 = screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
          float sy1 = screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
          float sx2 = screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
          float sy2 = screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
          raw.fill(argb0);
          raw.vertex(sx0, sy0, uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
          raw.fill(argb1);
          raw.vertex(sx1, sy1, uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
          raw.fill(argb1);
          raw.vertex(sx2, sy2, uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
        }
      }
      else if (raw.is3D()) {
        raw.fill(argb0);
        raw.vertex(pt0[0], pt0[1], pt0[2]);
        raw.fill(argb1);
        raw.vertex(pt1[0], pt1[1], pt1[2]);
        raw.fill(argb2);
        raw.vertex(pt2[0], pt2[1], pt2[2]);
      } else if (raw.is2D()) {
        float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
        float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
        float sx1 = screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
        float sy1 = screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
        float sx2 = screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
        float sy2 = screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
        raw.fill(argb0);
        raw.vertex(sx0, sy0);
        raw.fill(argb1);
        raw.vertex(sx1, sy1);
        raw.fill(argb2);
        raw.vertex(sx2, sy2);
      }
    }
    

    raw.endShape();
  }
  
  protected void flushLines()
  {
    updateLineBuffers();
    
    PShader shader = getLineShader();
    shader.bind();
    
    IndexCache cache = tessGeo.lineIndexCache;
    for (int n = 0; n < size; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      shader.setVertexAttribute(bufLineVertex.glId, 4, PGL.FLOAT, 0, 
        4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(bufLineColor.glId, 4, PGL.UNSIGNED_BYTE, 0, 
        4 * voffset * PGL.SIZEOF_BYTE);
      shader.setLineAttribute(bufLineAttrib.glId, 4, PGL.FLOAT, 0, 
        4 * voffset * PGL.SIZEOF_FLOAT);
      
      shader.draw(bufLineIndex.glId, icount, ioffset);
    }
    
    shader.unbind();
    unbindLineBuffers();
  }
  
  void rawLines()
  {
    raw.colorMode(1);
    raw.noFill();
    raw.strokeCap(strokeCap);
    raw.strokeJoin(strokeJoin);
    raw.beginShape(5);
    
    float[] vertices = tessGeo.lineVertices;
    int[] color = tessGeo.lineColors;
    float[] attribs = tessGeo.lineDirections;
    short[] indices = tessGeo.lineIndices;
    
    IndexCache cache = tessGeo.lineIndexCache;
    for (int n = 0; n < size; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      for (int ln = ioffset / 6; ln < (ioffset + icount) / 6; ln++)
      {




        int i0 = voffset + indices[(6 * ln + 0)];
        int i1 = voffset + indices[(6 * ln + 5)];
        float sw0 = 2.0F * attribs[(4 * i0 + 3)];
        float sw1 = 2.0F * attribs[(4 * i1 + 3)];
        
        if (!zero(sw0))
        {
          float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] pt1 = { 0.0F, 0.0F, 0.0F, 0.0F };
          int argb0 = PGL.nativeToJavaARGB(color[i0]);
          int argb1 = PGL.nativeToJavaARGB(color[i1]);
          
          if (flushMode == 0) {
            float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
            float[] src1 = { 0.0F, 0.0F, 0.0F, 0.0F };
            PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i1, src1, 0, 4);
            modelview.mult(src0, pt0);
            modelview.mult(src1, pt1);
          } else {
            PApplet.arrayCopy(vertices, 4 * i0, pt0, 0, 4);
            PApplet.arrayCopy(vertices, 4 * i1, pt1, 0, 4);
          }
          
          if (raw.is3D()) {
            raw.strokeWeight(sw0);
            raw.stroke(argb0);
            raw.vertex(pt0[0], pt0[1], pt0[2]);
            raw.strokeWeight(sw1);
            raw.stroke(argb1);
            raw.vertex(pt1[0], pt1[1], pt1[2]);
          } else if (raw.is2D()) {
            float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sx1 = screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sy1 = screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            raw.strokeWeight(sw0);
            raw.stroke(argb0);
            raw.vertex(sx0, sy0);
            raw.strokeWeight(sw1);
            raw.stroke(argb1);
            raw.vertex(sx1, sy1);
          }
        }
      }
    }
    raw.endShape();
  }
  
  protected void flushPoints()
  {
    updatePointBuffers();
    
    PShader shader = getPointShader();
    shader.bind();
    
    IndexCache cache = tessGeo.pointIndexCache;
    for (int n = 0; n < size; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      shader.setVertexAttribute(bufPointVertex.glId, 4, PGL.FLOAT, 0, 
        4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(bufPointColor.glId, 4, PGL.UNSIGNED_BYTE, 0, 
        4 * voffset * PGL.SIZEOF_BYTE);
      shader.setPointAttribute(bufPointAttrib.glId, 2, PGL.FLOAT, 0, 
        2 * voffset * PGL.SIZEOF_FLOAT);
      
      shader.draw(bufPointIndex.glId, icount, ioffset);
    }
    
    shader.unbind();
    unbindPointBuffers();
  }
  
  void rawPoints()
  {
    raw.colorMode(1);
    raw.noFill();
    raw.strokeCap(strokeCap);
    raw.beginShape(3);
    
    float[] vertices = tessGeo.pointVertices;
    int[] color = tessGeo.pointColors;
    float[] attribs = tessGeo.pointOffsets;
    short[] indices = tessGeo.pointIndices;
    
    IndexCache cache = tessGeo.pointIndexCache;
    for (int n = 0; n < size; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      int pt = ioffset;
      while (pt < (ioffset + icount) / 3) {
        float size = attribs[(2 * pt + 2)];
        int perim;
        float weight;
        int perim; if (0.0F < size) {
          float weight = size / 0.5F;
          perim = PApplet.min(200, PApplet.max(20, 
            (int)(6.2831855F * weight / 10.0F))) + 1;
        } else {
          weight = -size / 0.5F;
          perim = 5;
        }
        
        int i0 = voffset + indices[(3 * pt)];
        int argb0 = PGL.nativeToJavaARGB(color[i0]);
        float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        
        if (flushMode == 0) {
          float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
          PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
          modelview.mult(src0, pt0);
        } else {
          PApplet.arrayCopy(vertices, 4 * i0, pt0, 0, 4);
        }
        
        if (raw.is3D()) {
          raw.strokeWeight(weight);
          raw.stroke(argb0);
          raw.vertex(pt0[0], pt0[1], pt0[2]);
        } else if (raw.is2D()) {
          float sx0 = screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sy0 = screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          raw.strokeWeight(weight);
          raw.stroke(argb0);
          raw.vertex(sx0, sy0);
        }
        
        pt += perim;
      }
    }
    
    raw.endShape();
  }
  








  public void bezierVertex(float x2, float y2, float x3, float y3, float x4, float y4)
  {
    bezierVertexImpl(x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      x4, y4, 0.0F);
  }
  



  public void bezierVertex(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4)
  {
    bezierVertexImpl(x2, y2, z2, 
      x3, y3, z3, 
      x4, y4, z4);
  }
  


  protected void bezierVertexImpl(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4)
  {
    bezierVertexCheck(shape, inGeo.vertexCount);
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addBezierVertex(x2, y2, z2, 
      x3, y3, z3, 
      x4, y4, z4, vertexBreak());
  }
  


  public void quadraticVertex(float cx, float cy, float x3, float y3)
  {
    quadraticVertexImpl(cx, cy, 0.0F, 
      x3, y3, 0.0F);
  }
  


  public void quadraticVertex(float cx, float cy, float cz, float x3, float y3, float z3)
  {
    quadraticVertexImpl(cx, cy, cz, 
      x3, y3, z3);
  }
  

  protected void quadraticVertexImpl(float cx, float cy, float cz, float x3, float y3, float z3)
  {
    bezierVertexCheck(shape, inGeo.vertexCount);
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addQuadraticVertex(cx, cy, cz, 
      x3, y3, z3, vertexBreak());
  }
  






  public void curveVertex(float x, float y)
  {
    curveVertexImpl(x, y, 0.0F);
  }
  

  public void curveVertex(float x, float y, float z)
  {
    curveVertexImpl(x, y, z);
  }
  
  protected void curveVertexImpl(float x, float y, float z)
  {
    curveVertexCheck(shape);
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addCurveVertex(x, y, z, vertexBreak());
  }
  






  public void point(float x, float y)
  {
    pointImpl(x, y, 0.0F);
  }
  

  public void point(float x, float y, float z)
  {
    pointImpl(x, y, z);
  }
  
  protected void pointImpl(float x, float y, float z)
  {
    beginShape(3);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addPoint(x, y, z, fill, stroke);
    endShape();
  }
  

  public void line(float x1, float y1, float x2, float y2)
  {
    lineImpl(x1, y1, 0.0F, x2, y2, 0.0F);
  }
  


  public void line(float x1, float y1, float z1, float x2, float y2, float z2)
  {
    lineImpl(x1, y1, z1, x2, y2, z2);
  }
  

  protected void lineImpl(float x1, float y1, float z1, float x2, float y2, float z2)
  {
    beginShape(5);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addLine(x1, y1, z1, 
      x2, y2, z2, 
      fill, stroke);
    endShape();
  }
  


  public void triangle(float x1, float y1, float x2, float y2, float x3, float y3)
  {
    beginShape(9);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addTriangle(x1, y1, 0.0F, 
      x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      fill, stroke);
    endShape();
  }
  


  public void quad(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
  {
    beginShape(17);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addQuad(x1, y1, 0.0F, 
      x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      x4, y4, 0.0F, 
      stroke);
    endShape();
  }
  


  protected void rectImpl(float x1, float y1, float x2, float y2, float tl, float tr, float br, float bl)
  {
    beginShape(20);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addRect(x1, y1, x2, y2, tl, tr, br, bl, stroke);
    endShape(2);
  }
  






  public void ellipseImpl(float a, float b, float c, float d)
  {
    beginShape(11);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addEllipse(a, b, c, d, fill, stroke);
    endShape();
  }
  


  protected void arcImpl(float x, float y, float w, float h, float start, float stop, int mode)
  {
    beginShape(11);
    defaultEdges = false;
    normalMode = 1;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addArc(x, y, w, h, start, stop, fill, stroke, mode);
    endShape();
  }
  







  public void box(float w, float h, float d)
  {
    beginShape(17);
    defaultEdges = false;
    normalMode = 2;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.addBox(w, h, d, fill, stroke);
    endShape();
  }
  








  public void sphere(float r)
  {
    if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
      sphereDetail(30);
    }
    
    beginShape(9);
    defaultEdges = false;
    normalMode = 2;
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    int[] indices = inGeo.addSphere(r, sphereDetailU, sphereDetailV, 
      fill, stroke);
    endShape(indices);
  }
  



















































































































































  protected void shape(PShape shape, float x, float y, float z)
  {
    if (shape.isVisible()) {
      flush();
      
      pushMatrix();
      
      if (shapeMode == 3) {
        translate(x - shape.getWidth() / 2.0F, y - shape.getHeight() / 2.0F, 
          z - shape.getDepth() / 2.0F);
      }
      else if ((shapeMode == 0) || (shapeMode == 1)) {
        translate(x, y, z);
      }
      shape.draw(this);
      
      popMatrix();
    }
  }
  



  protected void shape(PShape shape, float x, float y, float z, float c, float d, float e)
  {
    if (shape.isVisible()) {
      flush();
      
      pushMatrix();
      
      if (shapeMode == 3)
      {
        translate(x - c / 2.0F, y - d / 2.0F, z - e / 2.0F);
        scale(c / shape.getWidth(), 
          d / shape.getHeight(), 
          e / shape.getDepth());
      }
      else if (shapeMode == 0) {
        translate(x, y, z);
        scale(c / shape.getWidth(), 
          d / shape.getHeight(), 
          e / shape.getDepth());
      }
      else if (shapeMode == 1)
      {
        c -= x;
        d -= y;
        e -= z;
        
        translate(x, y, z);
        scale(c / shape.getWidth(), 
          d / shape.getHeight(), 
          e / shape.getDepth());
      }
      shape.draw(this);
      
      popMatrix();
    }
  }
  






  public PShape loadShape(String filename)
  {
    String ext = PApplet.getExtension(filename);
    if (PGraphics2D.isSupportedExtension(ext))
      return PGraphics2D.loadShapeImpl(this, filename, ext);
    if (PGraphics3D.isSupportedExtension(ext)) {
      return PGraphics3D.loadShapeImpl(this, filename, ext);
    }
    PGraphics.showWarning("Unsupported shape format");
    return null;
  }
  






















  protected boolean textModeCheck(int mode)
  {
    return (mode == 4) || ((mode == 5) && (PGL.SHAPE_TEXT_SUPPORTED));
  }
  














  public float textAscent()
  {
    if (textFont == null) defaultFontOrDeath("textAscent");
    Object font = textFont.getNative();
    float ascent = 0.0F;
    if (font != null) ascent = pgl.getFontAscent(font);
    if (ascent == 0.0F) ascent = super.textAscent();
    return ascent;
  }
  

  public float textDescent()
  {
    if (textFont == null) defaultFontOrDeath("textDescent");
    Object font = textFont.getNative();
    float descent = 0.0F;
    if (font != null) descent = pgl.getFontDescent(font);
    if (descent == 0.0F) descent = super.textDescent();
    return descent;
  }
  

  protected float textWidthImpl(char[] buffer, int start, int stop)
  {
    Object font = textFont.getNative();
    float twidth = 0.0F;
    if (font != null) twidth = pgl.getTextWidth(font, buffer, start, stop);
    if (twidth == 0.0F) twidth = super.textWidthImpl(buffer, start, stop);
    return twidth;
  }
  

  protected void handleTextSize(float size)
  {
    Object font = textFont.getNative();
    if (font != null) {
      Object dfont = pgl.getDerivedFont(font, size);
      textFont.setNative(dfont);
    }
    super.handleTextSize(size);
  }
  





  protected void textLineImpl(char[] buffer, int start, int stop, float x, float y)
  {
    if (textMode == 4) {
      textTex = getFontTexture(textFont);
      
      if ((textTex == null) || (textTex.contextIsOutdated())) {
        textTex = new FontTexture(this, textFont, is3D());
        setFontTexture(textFont, textTex);
      }
      
      textTex.begin();
      

      int savedTextureMode = textureMode;
      boolean savedStroke = stroke;
      float savedNormalX = normalX;
      float savedNormalY = normalY;
      float savedNormalZ = normalZ;
      boolean savedTint = tint;
      int savedTintColor = tintColor;
      int savedBlendMode = blendMode;
      

      textureMode = 1;
      stroke = false;
      normalX = 0.0F;
      normalY = 0.0F;
      normalZ = 1.0F;
      tint = true;
      tintColor = fillColor;
      
      blendMode(1);
      
      super.textLineImpl(buffer, start, stop, x, y);
      

      textureMode = savedTextureMode;
      stroke = savedStroke;
      normalX = savedNormalX;
      normalY = savedNormalY;
      normalZ = savedNormalZ;
      tint = savedTint;
      tintColor = savedTintColor;
      




      blendMode(savedBlendMode);
      
      textTex.end();
    } else if (textMode == 5) {
      super.textLineImpl(buffer, start, stop, x, y);
    }
  }
  

  protected void textCharImpl(char ch, float x, float y)
  {
    PFont.Glyph glyph = textFont.getGlyph(ch);
    if (glyph != null) {
      if (textMode == 4) {
        FontTexture.TextureInfo tinfo = textTex.getTexInfo(glyph);
        
        if (tinfo == null)
        {
          tinfo = textTex.addToTexture(this, glyph);
        }
        
        float high = height / textFont.getSize();
        float bwidth = width / textFont.getSize();
        float lextent = leftExtent / textFont.getSize();
        float textent = topExtent / textFont.getSize();
        
        float x1 = x + lextent * textSize;
        float y1 = y - textent * textSize;
        float x2 = x1 + bwidth * textSize;
        float y2 = y1 + high * textSize;
        
        textCharModelImpl(tinfo, x1, y1, x2, y2);
      } else if (textMode == 5) {
        textCharShapeImpl(ch, x, y);
      }
    }
  }
  


  protected void textCharModelImpl(FontTexture.TextureInfo info, float x0, float y0, float x1, float y1)
  {
    beginShape(17);
    texture(textTex.getTexture(info));
    vertex(x0, y0, u0, v0);
    vertex(x1, y0, u1, v0);
    vertex(x1, y1, u1, v1);
    vertex(x0, y1, u0, v1);
    endShape();
  }
  































  protected void textCharShapeImpl(char ch, float x, float y)
  {
    boolean strokeSaved = stroke;
    stroke = false;
    
    PGL.FontOutline outline = pgl.createFontOutline(ch, textFont.getNative());
    

    float[] textPoints = new float[6];
    float lastX = 0.0F;
    float lastY = 0.0F;
    
    boolean open = false;
    beginShape();
    while (!outline.isDone()) {
      int type = outline.currentSegment(textPoints);
      if (!open) {
        beginContour();
        open = true;
      }
      if ((type == PGL.SEG_MOVETO) || (type == PGL.SEG_LINETO)) {
        vertex(x + textPoints[0], y + textPoints[1]);
        lastX = textPoints[0];
        lastY = textPoints[1];
      } else if (type == PGL.SEG_QUADTO) {
        for (int i = 1; i < bezierDetail; i++) {
          float t = i / bezierDetail;
          vertex(x + bezierPoint(lastX, 
            lastX + (float)((textPoints[0] - lastX) * 2.0F / 3.0D), 
            textPoints[2] + (float)((textPoints[0] - textPoints[2]) * 2.0F / 3.0D), 
            textPoints[2], t), 
            y + bezierPoint(lastY, 
            lastY + (float)((textPoints[1] - lastY) * 2.0F / 3.0D), 
            textPoints[3] + (float)((textPoints[1] - textPoints[3]) * 2.0F / 3.0D), 
            textPoints[3], t));
        }
        lastX = textPoints[2];
        lastY = textPoints[3];
      } else if (type == PGL.SEG_CUBICTO) {
        for (int i = 1; i < bezierDetail; i++) {
          float t = i / bezierDetail;
          vertex(x + bezierPoint(lastX, textPoints[0], 
            textPoints[2], textPoints[4], t), 
            y + bezierPoint(lastY, textPoints[1], 
            textPoints[3], textPoints[5], t));
        }
        lastX = textPoints[4];
        lastY = textPoints[5];
      } else if (type == PGL.SEG_CLOSE) {
        endContour();
        open = false;
      }
      outline.next();
    }
    endShape();
    

    stroke = strokeSaved;
  }
  






  public void pushMatrix()
  {
    if (modelviewStackDepth == 32) {
      throw new RuntimeException("Too many calls to pushMatrix().");
    }
    modelview.get(modelviewStack[modelviewStackDepth]);
    modelviewInv.get(modelviewInvStack[modelviewStackDepth]);
    camera.get(cameraStack[modelviewStackDepth]);
    cameraInv.get(cameraInvStack[modelviewStackDepth]);
    modelviewStackDepth += 1;
  }
  

  public void popMatrix()
  {
    if (modelviewStackDepth == 0) {
      throw new RuntimeException("Too many calls to popMatrix(), and not enough to pushMatrix().");
    }
    modelviewStackDepth -= 1;
    modelview.set(modelviewStack[modelviewStackDepth]);
    modelviewInv.set(modelviewInvStack[modelviewStackDepth]);
    camera.set(cameraStack[modelviewStackDepth]);
    cameraInv.set(cameraInvStack[modelviewStackDepth]);
    updateProjmodelview();
  }
  






  public void translate(float tx, float ty)
  {
    translateImpl(tx, ty, 0.0F);
  }
  

  public void translate(float tx, float ty, float tz)
  {
    translateImpl(tx, ty, tz);
  }
  
  protected void translateImpl(float tx, float ty, float tz)
  {
    modelview.translate(tx, ty, tz);
    invTranslate(modelviewInv, tx, ty, tz);
    projmodelview.translate(tx, ty, tz);
  }
  

  protected static void invTranslate(PMatrix3D matrix, float tx, float ty, float tz)
  {
    matrix.preApply(1.0F, 0.0F, 0.0F, -tx, 
      0.0F, 1.0F, 0.0F, -ty, 
      0.0F, 0.0F, 1.0F, -tz, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  



  protected static float matrixScale(PMatrix matrix)
  {
    float factor = 1.0F;
    
    if (matrix != null) {
      if ((matrix instanceof PMatrix2D)) {
        PMatrix2D tr = (PMatrix2D)matrix;
        float areaScaleFactor = Math.abs(m00 * m11 - m01 * m10);
        factor = (float)Math.sqrt(areaScaleFactor);
      } else if ((matrix instanceof PMatrix3D)) {
        PMatrix3D tr = (PMatrix3D)matrix;
        float volumeScaleFactor = 
          Math.abs(m00 * (m11 * m22 - m12 * m21) + 
          m01 * (m12 * m20 - m10 * m22) + 
          m02 * (m10 * m21 - m11 * m20));
        factor = (float)Math.pow(volumeScaleFactor, 0.3333333432674408D);
      }
    }
    return factor;
  }
  







  public void rotate(float angle)
  {
    rotateImpl(angle, 0.0F, 0.0F, 1.0F);
  }
  

  public void rotateX(float angle)
  {
    rotateImpl(angle, 1.0F, 0.0F, 0.0F);
  }
  

  public void rotateY(float angle)
  {
    rotateImpl(angle, 0.0F, 1.0F, 0.0F);
  }
  

  public void rotateZ(float angle)
  {
    rotateImpl(angle, 0.0F, 0.0F, 1.0F);
  }
  





  public void rotate(float angle, float v0, float v1, float v2)
  {
    rotateImpl(angle, v0, v1, v2);
  }
  
  protected void rotateImpl(float angle, float v0, float v1, float v2)
  {
    float norm2 = v0 * v0 + v1 * v1 + v2 * v2;
    if (zero(norm2))
    {
      return;
    }
    
    if (diff(norm2, 1.0F))
    {
      float norm = PApplet.sqrt(norm2);
      v0 /= norm;
      v1 /= norm;
      v2 /= norm;
    }
    
    modelview.rotate(angle, v0, v1, v2);
    invRotate(modelviewInv, angle, v0, v1, v2);
    updateProjmodelview();
  }
  

  private static void invRotate(PMatrix3D matrix, float angle, float v0, float v1, float v2)
  {
    float c = PApplet.cos(-angle);
    float s = PApplet.sin(-angle);
    float t = 1.0F - c;
    
    matrix.preApply(t * v0 * v0 + c, t * v0 * v1 - s * v2, t * v0 * v2 + s * v1, 0.0F, 
      t * v0 * v1 + s * v2, t * v1 * v1 + c, t * v1 * v2 - s * v0, 0.0F, 
      t * v0 * v2 - s * v1, t * v1 * v2 + s * v0, t * v2 * v2 + c, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  




  public void scale(float s)
  {
    scaleImpl(s, s, s);
  }
  




  public void scale(float sx, float sy)
  {
    scaleImpl(sx, sy, 1.0F);
  }
  




  public void scale(float sx, float sy, float sz)
  {
    scaleImpl(sx, sy, sz);
  }
  


  protected void scaleImpl(float sx, float sy, float sz)
  {
    modelview.scale(sx, sy, sz);
    invScale(modelviewInv, sx, sy, sz);
    projmodelview.scale(sx, sy, sz);
  }
  
  protected static void invScale(PMatrix3D matrix, float x, float y, float z)
  {
    matrix.preApply(1.0F / x, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F / y, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F / z, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F);
  }
  

  public void shearX(float angle)
  {
    float t = (float)Math.tan(angle);
    applyMatrixImpl(1.0F, t, 0.0F, 0.0F, 
      0.0F, 1.0F, 0.0F, 0.0F, 
      0.0F, 0.0F, 1.0F, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  

  public void shearY(float angle)
  {
    float t = (float)Math.tan(angle);
    applyMatrixImpl(1.0F, 0.0F, 0.0F, 0.0F, 
      t, 1.0F, 0.0F, 0.0F, 
      0.0F, 0.0F, 1.0F, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  






  public void resetMatrix()
  {
    modelview.reset();
    modelviewInv.reset();
    projmodelview.set(projection);
    


    camera.reset();
    cameraInv.reset();
  }
  

  public void applyMatrix(PMatrix2D source)
  {
    applyMatrixImpl(m00, m01, 0.0F, m02, 
      m10, m11, 0.0F, m12, 
      0.0F, 0.0F, 1.0F, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  


  public void applyMatrix(float n00, float n01, float n02, float n10, float n11, float n12)
  {
    applyMatrixImpl(n00, n01, 0.0F, n02, 
      n10, n11, 0.0F, n12, 
      0.0F, 0.0F, 1.0F, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
  }
  

  public void applyMatrix(PMatrix3D source)
  {
    applyMatrixImpl(m00, m01, m02, m03, 
      m10, m11, m12, m13, 
      m20, m21, m22, m23, 
      m30, m31, m32, m33);
  }
  







  public void applyMatrix(float n00, float n01, float n02, float n03, float n10, float n11, float n12, float n13, float n20, float n21, float n22, float n23, float n30, float n31, float n32, float n33)
  {
    applyMatrixImpl(n00, n01, n02, n03, 
      n10, n11, n12, n13, 
      n20, n21, n22, n23, 
      n30, n31, n32, n33);
  }
  



  protected void applyMatrixImpl(float n00, float n01, float n02, float n03, float n10, float n11, float n12, float n13, float n20, float n21, float n22, float n23, float n30, float n31, float n32, float n33)
  {
    modelview.apply(n00, n01, n02, n03, 
      n10, n11, n12, n13, 
      n20, n21, n22, n23, 
      n30, n31, n32, n33);
    modelviewInv.set(modelview);
    modelviewInv.invert();
    
    projmodelview.apply(n00, n01, n02, n03, 
      n10, n11, n12, n13, 
      n20, n21, n22, n23, 
      n30, n31, n32, n33);
  }
  




  protected void begin2D() {}
  



  protected void end2D() {}
  



  public PMatrix getMatrix()
  {
    return modelview.get();
  }
  




  public PMatrix3D getMatrix(PMatrix3D target)
  {
    if (target == null) {
      target = new PMatrix3D();
    }
    target.set(modelview);
    return target;
  }
  




  public void setMatrix(PMatrix2D source)
  {
    resetMatrix();
    applyMatrix(source);
  }
  




  public void setMatrix(PMatrix3D source)
  {
    resetMatrix();
    applyMatrix(source);
  }
  




  public void printMatrix()
  {
    modelview.print();
  }
  





  public void pushProjection()
  {
    if (projectionStackDepth == 32) {
      throw new RuntimeException("Too many calls to pushMatrix().");
    }
    projection.get(projectionStack[projectionStackDepth]);
    projectionStackDepth += 1;
  }
  
  public void popProjection()
  {
    flush();
    
    if (projectionStackDepth == 0) {
      throw new RuntimeException("Too many calls to popMatrix(), and not enough to pushMatrix().");
    }
    projectionStackDepth -= 1;
    projection.set(projectionStack[projectionStackDepth]);
    updateProjmodelview();
  }
  
  public void resetProjection()
  {
    flush();
    projection.reset();
    updateProjmodelview();
  }
  
  public void applyProjection(PMatrix3D mat)
  {
    flush();
    projection.apply(mat);
    updateProjmodelview();
  }
  



  public void applyProjection(float n00, float n01, float n02, float n03, float n10, float n11, float n12, float n13, float n20, float n21, float n22, float n23, float n30, float n31, float n32, float n33)
  {
    flush();
    projection.apply(n00, n01, n02, n03, 
      n10, n11, n12, n13, 
      n20, n21, n22, n23, 
      n30, n31, n32, n33);
    updateProjmodelview();
  }
  
  public void setProjection(PMatrix3D mat)
  {
    flush();
    projection.set(mat);
    updateProjmodelview();
  }
  





  protected boolean orthoProjection()
  {
    return (zero(projection.m01)) && (zero(projection.m02)) && 
      (zero(projection.m10)) && (zero(projection.m12)) && 
      (zero(projection.m20)) && (zero(projection.m21)) && 
      (zero(projection.m30)) && (zero(projection.m31)) && 
      (zero(projection.m32)) && (same(projection.m33, 1.0F));
  }
  
  protected boolean nonOrthoProjection()
  {
    return (nonZero(projection.m01)) || (nonZero(projection.m02)) || 
      (nonZero(projection.m10)) || (nonZero(projection.m12)) || 
      (nonZero(projection.m20)) || (nonZero(projection.m21)) || 
      (nonZero(projection.m30)) || (nonZero(projection.m31)) || 
      (nonZero(projection.m32)) || (diff(projection.m33, 1.0F));
  }
  





  protected static boolean same(float a, float b)
  {
    return Math.abs(a - b) < PGL.FLOAT_EPS;
  }
  
  protected static boolean diff(float a, float b)
  {
    return PGL.FLOAT_EPS <= Math.abs(a - b);
  }
  
  protected static boolean zero(float a)
  {
    return Math.abs(a) < PGL.FLOAT_EPS;
  }
  
  protected static boolean nonZero(float a)
  {
    return PGL.FLOAT_EPS <= Math.abs(a);
  }
  





















































  public void beginCamera()
  {
    if (manipulatingCamera) {
      throw new RuntimeException("beginCamera() cannot be called again before endCamera()");
    }
    
    manipulatingCamera = true;
  }
  










  public void endCamera()
  {
    if (!manipulatingCamera) {
      throw new RuntimeException("Cannot call endCamera() without first calling beginCamera()");
    }
    

    camera.set(modelview);
    cameraInv.set(modelviewInv);
    

    manipulatingCamera = false;
  }
  



































  public void camera()
  {
    camera(cameraX, cameraY, cameraZ, cameraX, cameraY, 0.0F, 0.0F, 1.0F, 0.0F);
  }
  




























































  public void camera(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)
  {
    float z0 = eyeX - centerX;
    float z1 = eyeY - centerY;
    float z2 = eyeZ - centerZ;
    eyeDist = PApplet.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    if (nonZero(eyeDist)) {
      z0 /= eyeDist;
      z1 /= eyeDist;
      z2 /= eyeDist;
    }
    

    float y0 = upX;
    float y1 = upY;
    float y2 = upZ;
    

    float x0 = y1 * z2 - y2 * z1;
    float x1 = -y0 * z2 + y2 * z0;
    float x2 = y0 * z1 - y1 * z0;
    

    y0 = z1 * x2 - z2 * x1;
    y1 = -z0 * x2 + z2 * x0;
    y2 = z0 * x1 - z1 * x0;
    


    float xmag = PApplet.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (nonZero(xmag)) {
      x0 /= xmag;
      x1 /= xmag;
      x2 /= xmag;
    }
    
    float ymag = PApplet.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (nonZero(ymag)) {
      y0 /= ymag;
      y1 /= ymag;
      y2 /= ymag;
    }
    
    modelview.set(x0, x1, x2, 0.0F, 
      y0, y1, y2, 0.0F, 
      z0, z1, z2, 0.0F, 
      0.0F, 0.0F, 0.0F, 1.0F);
    
    float tx = -eyeX;
    float ty = -eyeY;
    float tz = -eyeZ;
    modelview.translate(tx, ty, tz);
    
    modelviewInv.set(modelview);
    modelviewInv.invert();
    
    camera.set(modelview);
    cameraInv.set(modelviewInv);
    
    updateProjmodelview();
  }
  




  public void printCamera()
  {
    camera.print();
  }
  
  protected void defaultCamera()
  {
    camera();
  }
  










  public void ortho()
  {
    ortho(-width / 2.0F, width / 2.0F, -height / 2.0F, height / 2.0F, 0.0F, eyeDist * 10.0F);
  }
  






  public void ortho(float left, float right, float bottom, float top)
  {
    ortho(left, right, bottom, top, 0.0F, eyeDist * 10.0F);
  }
  







  public void ortho(float left, float right, float bottom, float top, float near, float far)
  {
    float w = right - left;
    float h = top - bottom;
    float d = far - near;
    

    flush();
    
    float x = 2.0F / w;
    float y = 2.0F / h;
    float z = -2.0F / d;
    
    float tx = -(right + left) / w;
    float ty = -(top + bottom) / h;
    float tz = -(far + near) / d;
    

    projection.set(x, 0.0F, 0.0F, tx, 
      0.0F, -y, 0.0F, ty, 
      0.0F, 0.0F, z, tz, 
      0.0F, 0.0F, 0.0F, 1.0F);
    
    updateProjmodelview();
  }
  





















  public void perspective()
  {
    perspective(cameraFOV, cameraAspect, cameraNear, cameraFar);
  }
  




  public void perspective(float fov, float aspect, float zNear, float zFar)
  {
    float ymax = zNear * (float)Math.tan(fov / 2.0F);
    float ymin = -ymax;
    float xmin = ymin * aspect;
    float xmax = ymax * aspect;
    frustum(xmin, xmax, ymin, ymax, zNear, zFar);
  }
  









  public void frustum(float left, float right, float bottom, float top, float znear, float zfar)
  {
    flush();
    
    float n2 = 2.0F * znear;
    float w = right - left;
    float h = top - bottom;
    float d = zfar - znear;
    
    projection.set(n2 / w, 0.0F, (right + left) / w, 0.0F, 
      0.0F, -n2 / h, (top + bottom) / h, 0.0F, 
      0.0F, 0.0F, -(zfar + znear) / d, -(n2 * zfar) / d, 
      0.0F, 0.0F, -1.0F, 0.0F);
    
    updateProjmodelview();
  }
  




  public void printProjection()
  {
    projection.print();
  }
  
  protected void defaultPerspective()
  {
    perspective();
  }
  






  public float screenX(float x, float y)
  {
    return screenXImpl(x, y, 0.0F);
  }
  

  public float screenY(float x, float y)
  {
    return screenYImpl(x, y, 0.0F);
  }
  

  public float screenX(float x, float y, float z)
  {
    return screenXImpl(x, y, z);
  }
  

  public float screenY(float x, float y, float z)
  {
    return screenYImpl(x, y, z);
  }
  

  public float screenZ(float x, float y, float z)
  {
    return screenZImpl(x, y, z);
  }
  
  protected float screenXImpl(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    return screenXImpl(ax, ay, az, aw);
  }
  
  protected float screenXImpl(float x, float y, float z, float w)
  {
    float ox = 
      projection.m00 * x + projection.m01 * y + projection.m02 * z + projection.m03 * w;
    float ow = 
      projection.m30 * x + projection.m31 * y + projection.m32 * z + projection.m33 * w;
    
    if (nonZero(ow)) {
      ox /= ow;
    }
    float sx = width * (1.0F + ox) / 2.0F;
    return sx;
  }
  
  protected float screenYImpl(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    return screenYImpl(ax, ay, az, aw);
  }
  
  protected float screenYImpl(float x, float y, float z, float w)
  {
    float oy = 
      projection.m10 * x + projection.m11 * y + projection.m12 * z + projection.m13 * w;
    float ow = 
      projection.m30 * x + projection.m31 * y + projection.m32 * z + projection.m33 * w;
    
    if (nonZero(ow)) {
      oy /= ow;
    }
    float sy = height * (1.0F + oy) / 2.0F;
    
    sy = height - sy;
    return sy;
  }
  
  protected float screenZImpl(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    return screenZImpl(ax, ay, az, aw);
  }
  
  protected float screenZImpl(float x, float y, float z, float w)
  {
    float oz = 
      projection.m20 * x + projection.m21 * y + projection.m22 * z + projection.m23 * w;
    float ow = 
      projection.m30 * x + projection.m31 * y + projection.m32 * z + projection.m33 * w;
    
    if (nonZero(ow)) {
      oz /= ow;
    }
    float sz = (oz + 1.0F) / 2.0F;
    return sz;
  }
  

  public float modelX(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    
    float ox = 
      cameraInv.m00 * ax + cameraInv.m01 * ay + cameraInv.m02 * az + cameraInv.m03 * aw;
    float ow = 
      cameraInv.m30 * ax + cameraInv.m31 * ay + cameraInv.m32 * az + cameraInv.m33 * aw;
    
    return nonZero(ow) ? ox / ow : ox;
  }
  

  public float modelY(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    
    float oy = 
      cameraInv.m10 * ax + cameraInv.m11 * ay + cameraInv.m12 * az + cameraInv.m13 * aw;
    float ow = 
      cameraInv.m30 * ax + cameraInv.m31 * ay + cameraInv.m32 * az + cameraInv.m33 * aw;
    
    return nonZero(ow) ? oy / ow : oy;
  }
  

  public float modelZ(float x, float y, float z)
  {
    float ax = 
      modelview.m00 * x + modelview.m01 * y + modelview.m02 * z + modelview.m03;
    float ay = 
      modelview.m10 * x + modelview.m11 * y + modelview.m12 * z + modelview.m13;
    float az = 
      modelview.m20 * x + modelview.m21 * y + modelview.m22 * z + modelview.m23;
    float aw = 
      modelview.m30 * x + modelview.m31 * y + modelview.m32 * z + modelview.m33;
    
    float oz = 
      cameraInv.m20 * ax + cameraInv.m21 * ay + cameraInv.m22 * az + cameraInv.m23 * aw;
    float ow = 
      cameraInv.m30 * ax + cameraInv.m31 * ay + cameraInv.m32 * az + cameraInv.m33 * aw;
    
    return nonZero(ow) ? oz / ow : oz;
  }
  







  public void popStyle()
  {
    boolean savedSetAmbient = setAmbient;
    super.popStyle();
    if (!savedSetAmbient) { setAmbient = false;
    }
  }
  































  public void strokeWeight(float weight)
  {
    strokeWeight = weight;
  }
  

  public void strokeJoin(int join)
  {
    strokeJoin = join;
  }
  

  public void strokeCap(int cap)
  {
    strokeCap = cap;
  }
  






  protected void fillFromCalc()
  {
    super.fillFromCalc();
    
    if (!setAmbient)
    {



      ambientFromCalc();
      

      setAmbient = false;
    }
  }
  








































































































  public void lights()
  {
    enableLighting();
    

    lightCount = 0;
    

    int colorModeSaved = colorMode;
    colorMode = 1;
    
    lightFalloff(1.0F, 0.0F, 0.0F);
    lightSpecular(0.0F, 0.0F, 0.0F);
    
    ambientLight(colorModeX * 0.5F, colorModeY * 0.5F, colorModeZ * 0.5F);
    directionalLight(colorModeX * 0.5F, colorModeY * 0.5F, colorModeZ * 0.5F, 
      0.0F, 0.0F, -1.0F);
    
    colorMode = colorModeSaved;
  }
  




  public void noLights()
  {
    disableLighting();
    lightCount = 0;
  }
  




  public void ambientLight(float r, float g, float b)
  {
    ambientLight(r, g, b, 0.0F, 0.0F, 0.0F);
  }
  






  public void ambientLight(float r, float g, float b, float x, float y, float z)
  {
    enableLighting();
    if (lightCount == PGL.MAX_LIGHTS) {
      throw new RuntimeException("can only create " + PGL.MAX_LIGHTS + 
        " lights");
    }
    
    lightType[lightCount] = 0;
    
    lightPosition(lightCount, x, y, z, false);
    lightNormal(lightCount, 0.0F, 0.0F, 0.0F);
    
    lightAmbient(lightCount, r, g, b);
    noLightDiffuse(lightCount);
    noLightSpecular(lightCount);
    noLightSpot(lightCount);
    lightFalloff(lightCount, currentLightFalloffConstant, 
      currentLightFalloffLinear, 
      currentLightFalloffQuadratic);
    
    lightCount += 1;
  }
  


  public void directionalLight(float r, float g, float b, float dx, float dy, float dz)
  {
    enableLighting();
    if (lightCount == PGL.MAX_LIGHTS) {
      throw new RuntimeException("can only create " + PGL.MAX_LIGHTS + 
        " lights");
    }
    
    lightType[lightCount] = 1;
    
    lightPosition(lightCount, 0.0F, 0.0F, 0.0F, true);
    lightNormal(lightCount, dx, dy, dz);
    
    noLightAmbient(lightCount);
    lightDiffuse(lightCount, r, g, b);
    lightSpecular(lightCount, currentLightSpecular[0], 
      currentLightSpecular[1], 
      currentLightSpecular[2]);
    noLightSpot(lightCount);
    noLightFalloff(lightCount);
    
    lightCount += 1;
  }
  


  public void pointLight(float r, float g, float b, float x, float y, float z)
  {
    enableLighting();
    if (lightCount == PGL.MAX_LIGHTS) {
      throw new RuntimeException("can only create " + PGL.MAX_LIGHTS + 
        " lights");
    }
    
    lightType[lightCount] = 2;
    
    lightPosition(lightCount, x, y, z, false);
    lightNormal(lightCount, 0.0F, 0.0F, 0.0F);
    
    noLightAmbient(lightCount);
    lightDiffuse(lightCount, r, g, b);
    lightSpecular(lightCount, currentLightSpecular[0], 
      currentLightSpecular[1], 
      currentLightSpecular[2]);
    noLightSpot(lightCount);
    lightFalloff(lightCount, currentLightFalloffConstant, 
      currentLightFalloffLinear, 
      currentLightFalloffQuadratic);
    
    lightCount += 1;
  }
  




  public void spotLight(float r, float g, float b, float x, float y, float z, float dx, float dy, float dz, float angle, float concentration)
  {
    enableLighting();
    if (lightCount == PGL.MAX_LIGHTS) {
      throw new RuntimeException("can only create " + PGL.MAX_LIGHTS + 
        " lights");
    }
    
    lightType[lightCount] = 3;
    
    lightPosition(lightCount, x, y, z, false);
    lightNormal(lightCount, dx, dy, dz);
    
    noLightAmbient(lightCount);
    lightDiffuse(lightCount, r, g, b);
    lightSpecular(lightCount, currentLightSpecular[0], 
      currentLightSpecular[1], 
      currentLightSpecular[2]);
    lightSpot(lightCount, angle, concentration);
    lightFalloff(lightCount, currentLightFalloffConstant, 
      currentLightFalloffLinear, 
      currentLightFalloffQuadratic);
    
    lightCount += 1;
  }
  





  public void lightFalloff(float constant, float linear, float quadratic)
  {
    currentLightFalloffConstant = constant;
    currentLightFalloffLinear = linear;
    currentLightFalloffQuadratic = quadratic;
  }
  




  public void lightSpecular(float x, float y, float z)
  {
    colorCalc(x, y, z);
    currentLightSpecular[0] = calcR;
    currentLightSpecular[1] = calcG;
    currentLightSpecular[2] = calcB;
  }
  
  protected void enableLighting()
  {
    flush();
    lights = true;
  }
  
  protected void disableLighting()
  {
    flush();
    lights = false;
  }
  

  protected void lightPosition(int num, float x, float y, float z, boolean dir)
  {
    lightPosition[(4 * num + 0)] = 
      (x * modelview.m00 + y * modelview.m01 + z * modelview.m02 + modelview.m03);
    lightPosition[(4 * num + 1)] = 
      (x * modelview.m10 + y * modelview.m11 + z * modelview.m12 + modelview.m13);
    lightPosition[(4 * num + 2)] = 
      (x * modelview.m20 + y * modelview.m21 + z * modelview.m22 + modelview.m23);
    

    lightPosition[(4 * num + 3)] = (dir ? 0 : 1);
  }
  


  protected void lightNormal(int num, float dx, float dy, float dz)
  {
    float nx = 
      dx * modelviewInv.m00 + dy * modelviewInv.m10 + dz * modelviewInv.m20;
    float ny = 
      dx * modelviewInv.m01 + dy * modelviewInv.m11 + dz * modelviewInv.m21;
    float nz = 
      dx * modelviewInv.m02 + dy * modelviewInv.m12 + dz * modelviewInv.m22;
    
    float d = PApplet.dist(0.0F, 0.0F, 0.0F, nx, ny, nz);
    if (0.0F < d) {
      float invn = 1.0F / d;
      lightNormal[(3 * num + 0)] = (invn * nx);
      lightNormal[(3 * num + 1)] = (invn * ny);
      lightNormal[(3 * num + 2)] = (invn * nz);
    } else {
      lightNormal[(3 * num + 0)] = 0.0F;
      lightNormal[(3 * num + 1)] = 0.0F;
      lightNormal[(3 * num + 2)] = 0.0F;
    }
  }
  
  protected void lightAmbient(int num, float r, float g, float b)
  {
    colorCalc(r, g, b);
    lightAmbient[(3 * num + 0)] = calcR;
    lightAmbient[(3 * num + 1)] = calcG;
    lightAmbient[(3 * num + 2)] = calcB;
  }
  
  protected void noLightAmbient(int num)
  {
    lightAmbient[(3 * num + 0)] = 0.0F;
    lightAmbient[(3 * num + 1)] = 0.0F;
    lightAmbient[(3 * num + 2)] = 0.0F;
  }
  
  protected void lightDiffuse(int num, float r, float g, float b)
  {
    colorCalc(r, g, b);
    lightDiffuse[(3 * num + 0)] = calcR;
    lightDiffuse[(3 * num + 1)] = calcG;
    lightDiffuse[(3 * num + 2)] = calcB;
  }
  
  protected void noLightDiffuse(int num)
  {
    lightDiffuse[(3 * num + 0)] = 0.0F;
    lightDiffuse[(3 * num + 1)] = 0.0F;
    lightDiffuse[(3 * num + 2)] = 0.0F;
  }
  
  protected void lightSpecular(int num, float r, float g, float b)
  {
    lightSpecular[(3 * num + 0)] = r;
    lightSpecular[(3 * num + 1)] = g;
    lightSpecular[(3 * num + 2)] = b;
  }
  
  protected void noLightSpecular(int num)
  {
    lightSpecular[(3 * num + 0)] = 0.0F;
    lightSpecular[(3 * num + 1)] = 0.0F;
    lightSpecular[(3 * num + 2)] = 0.0F;
  }
  
  protected void lightFalloff(int num, float c0, float c1, float c2)
  {
    lightFalloffCoefficients[(3 * num + 0)] = c0;
    lightFalloffCoefficients[(3 * num + 1)] = c1;
    lightFalloffCoefficients[(3 * num + 2)] = c2;
  }
  
  protected void noLightFalloff(int num)
  {
    lightFalloffCoefficients[(3 * num + 0)] = 1.0F;
    lightFalloffCoefficients[(3 * num + 1)] = 0.0F;
    lightFalloffCoefficients[(3 * num + 2)] = 0.0F;
  }
  
  protected void lightSpot(int num, float angle, float exponent)
  {
    lightSpotParameters[(2 * num + 0)] = Math.max(0.0F, PApplet.cos(angle));
    lightSpotParameters[(2 * num + 1)] = exponent;
  }
  
  protected void noLightSpot(int num)
  {
    lightSpotParameters[(2 * num + 0)] = 0.0F;
    lightSpotParameters[(2 * num + 1)] = 0.0F;
  }
  






  protected void backgroundImpl(PImage image)
  {
    backgroundImpl();
    set(0, 0, image);
    



    backgroundA = 1.0F;
    loaded = false;
  }
  

  protected void backgroundImpl()
  {
    flush();
    pgl.clearBackground(backgroundR, backgroundG, backgroundB, backgroundA, 
      hints[5] == 0);
    loaded = false;
  }
  












































  protected void report(String where)
  {
    if (hints[4] == 0) {
      int err = pgl.getError();
      if (err != 0) {
        String errString = pgl.errorString(err);
        String msg = "OpenGL error " + err + " at " + where + ": " + errString;
        PGraphics.showWarning(msg);
      }
    }
  }
  









  public boolean isGL()
  {
    return true;
  }
  








  public void loadPixels()
  {
    if ((primaryGraphics) && (sized))
    {

      return;
    }
    
    boolean needEndDraw = false;
    if (!drawing) {
      beginDraw();
      needEndDraw = true;
    }
    
    if (!loaded)
    {

      flush();
    }
    
    allocatePixels();
    
    if (!loaded) {
      readPixels();
    }
    

    loaded = true;
    

    if (needEndDraw) {
      endDraw();
    }
  }
  
  protected void allocatePixels()
  {
    updatePixelSize();
    if ((pixels == null) || (pixels.length != pixelWidth * pixelHeight)) {
      pixels = new int[pixelWidth * pixelHeight];
      pixelBuffer = PGL.allocateIntBuffer(pixels);
      loaded = false;
    }
  }
  
  protected void readPixels()
  {
    updatePixelSize();
    beginPixelsOp(1);
    



    try
    {
      pgl.readPixelsImpl(0, 0, pixelWidth, pixelHeight, PGL.RGBA, PGL.UNSIGNED_BYTE, 
        pixelBuffer);
    }
    catch (IndexOutOfBoundsException localIndexOutOfBoundsException) {}
    
    endPixelsOp();
    try
    {
      PGL.getIntArray(pixelBuffer, pixels);
      PGL.nativeToJavaARGB(pixels, pixelWidth, pixelHeight);
    }
    catch (ArrayIndexOutOfBoundsException localArrayIndexOutOfBoundsException) {}
  }
  
  protected void drawPixels(int x, int y, int w, int h)
  {
    int f = (int)pgl.getPixelScale();
    int len = f * w * f * h;
    if ((nativePixels == null) || (nativePixels.length < len)) {
      nativePixels = new int[len];
      nativePixelBuffer = PGL.allocateIntBuffer(nativePixels);
    }
    try
    {
      if ((x > 0) || (y > 0) || (w < width) || (h < height))
      {


        int offset0 = f * (y * width + x);
        int offset1 = 0;
        
        for (int yc = f * y; yc < f * (y + h); yc++) {
          System.arraycopy(pixels, offset0, nativePixels, offset1, f * w);
          offset0 += f * width;
          offset1 += f * w;
        }
      } else {
        PApplet.arrayCopy(pixels, 0, nativePixels, 0, len);
      }
      PGL.javaToNativeARGB(nativePixels, f * w, f * h);
    }
    catch (ArrayIndexOutOfBoundsException localArrayIndexOutOfBoundsException) {}
    PGL.putIntArray(nativePixelBuffer, nativePixels);
    
    if ((primaryGraphics) && (!pgl.isFBOBacked()))
    {

      loadTextureImpl(2, false);
    }
    
    boolean needToDrawTex = ((primaryGraphics) && ((!pgl.isFBOBacked()) || (
      (pgl.isFBOBacked()) && (pgl.isMultisampled())))) || 
      (offscreenMultisample);
    if (texture == null) return;
    if (needToDrawTex)
    {







      int tw = PApplet.min(texture.glWidth - f * x, f * w);
      int th = PApplet.min(texture.glHeight - f * y, f * h);
      pgl.copyToTexture(texture.glTarget, texture.glFormat, texture.glName, 
        f * x, f * y, tw, th, nativePixelBuffer);
      beginPixelsOp(2);
      drawTexture(x, y, w, h);
      endPixelsOp();

    }
    else
    {
      pgl.copyToTexture(texture.glTarget, texture.glFormat, texture.glName, 
        f * x, f * (height - (y + h)), f * w, f * h, nativePixelBuffer);
    }
  }
  






  public int get(int x, int y)
  {
    loadPixels();
    return super.get(x, y);
  }
  



  protected void getImpl(int sourceX, int sourceY, int sourceWidth, int sourceHeight, PImage target, int targetX, int targetY)
  {
    loadPixels();
    super.getImpl(sourceX, sourceY, sourceWidth, sourceHeight, 
      target, targetX, targetY);
  }
  

  public void set(int x, int y, int argb)
  {
    loadPixels();
    super.set(x, y, argb);
  }
  




  protected void setImpl(PImage sourceImage, int sourceX, int sourceY, int sourceWidth, int sourceHeight, int targetX, int targetY)
  {
    updatePixelSize();
    

    loadPixels();
    int sourceOffset = sourceY * pixelWidth + sourceX;
    int targetOffset = targetY * pixelWidth + targetX;
    for (int y = sourceY; y < sourceY + sourceHeight; y++) {
      System.arraycopy(pixels, sourceOffset, pixels, targetOffset, sourceWidth);
      sourceOffset += pixelWidth;
      targetOffset += pixelWidth;
    }
    


    copy(sourceImage, 
      sourceX, sourceY, sourceWidth, sourceHeight, 
      targetX, targetY, sourceWidth, sourceHeight);
  }
  






  public boolean save(String filename)
  {
    return saveImpl(filename);
  }
  

  protected void processImageBeforeAsyncSave(PImage image)
  {
    if (format == -1) {
      PGL.nativeToJavaARGB(pixels, width, height);
      format = 2;
    } else if (format == -2) {
      PGL.nativeToJavaRGB(pixels, width, height);
      format = 1;
    }
  }
  
  protected static void completeFinishedPixelTransfers()
  {
    ongoingPixelTransfersIterable.addAll(ongoingPixelTransfers);
    for (AsyncPixelReader pixelReader : ongoingPixelTransfersIterable)
    {

      if (!calledThisFrame) {
        pixelReader.completeFinishedTransfers();
      }
      calledThisFrame = false;
    }
    ongoingPixelTransfersIterable.clear();
  }
  
  protected static void completeAllPixelTransfers() {
    ongoingPixelTransfersIterable.addAll(ongoingPixelTransfers);
    for (AsyncPixelReader pixelReader : ongoingPixelTransfersIterable) {
      pixelReader.completeAllTransfers();
    }
    ongoingPixelTransfersIterable.clear();
  }
  

  protected void awaitAsyncSaveCompletion(String filename)
  {
    if (asyncPixelReader != null) {
      ongoingPixelTransfersIterable.addAll(ongoingPixelTransfers);
      File file = parent.sketchFile(filename);
      for (AsyncPixelReader pixelReader : ongoingPixelTransfersIterable) {
        pixelReader.awaitTransferCompletion(file);
      }
      ongoingPixelTransfersIterable.clear();
    }
    super.awaitAsyncSaveCompletion(filename);
  }
  


  protected class AsyncPixelReader
  {
    static final int OPENGL_NATIVE = -1;
    

    static final int OPENGL_NATIVE_OPAQUE = -2;
    

    static final int BUFFER_COUNT = 3;
    
    int[] pbos;
    
    long[] fences;
    
    File[] files;
    
    int[] widths;
    
    int[] heights;
    
    int head;
    
    int tail;
    
    int size;
    
    boolean supportsAsyncTransfers = (pgl.hasPBOs()) && (pgl.hasSynchronization());
    public AsyncPixelReader() { IntBuffer intBuffer; if (supportsAsyncTransfers) {
        pbos = new int[3];
        fences = new long[3];
        files = new File[3];
        widths = new int[3];
        heights = new int[3];
        
        intBuffer = PGL.allocateIntBuffer(3);
        intBuffer.rewind();
        pgl.genBuffers(3, intBuffer);
        for (int i = 0; i < 3; i++) {
          pbos[i] = intBuffer.get(i);
        }
      }
    }
    
    public void dispose()
    {
      if (fences != null) {
        while (size > 0) {
          pgl.deleteSync(fences[tail]);
          size -= 1;
          tail = ((tail + 1) % 3);
        }
        fences = null;
      }
      if (pbos != null) {
        for (int i = 0; i < 3; i++) {
          IntBuffer intBuffer = PGL.allocateIntBuffer(pbos);
          pgl.deleteBuffers(3, intBuffer);
        }
        pbos = null;
      }
      files = null;
      widths = null;
      heights = null;
      size = 0;
      head = 0;
      tail = 0;
      calledThisFrame = false;
      PGraphicsOpenGL.ongoingPixelTransfers.remove(this);
    }
    
    public void readAndSaveAsync(File file)
    {
      if (size > 0) {
        boolean shouldRead = size == 3;
        if (!shouldRead) shouldRead = isLastTransferComplete();
        if (shouldRead) endTransfer();
      } else {
        PGraphicsOpenGL.ongoingPixelTransfers.add(this);
      }
      beginTransfer(file);
      calledThisFrame = true;
    }
    
    public void completeFinishedTransfers()
    {
      if ((size <= 0) || (!PGraphicsOpenGL.asyncImageSaver.hasAvailableTarget())) { return;
      }
      boolean needEndDraw = false;
      if (!drawing) {
        beginDraw();
        needEndDraw = true;
      }
      
      while ((PGraphicsOpenGL.asyncImageSaver.hasAvailableTarget()) && 
        (isLastTransferComplete())) {
        endTransfer();
      }
      


      if (size <= 0) { PGraphicsOpenGL.ongoingPixelTransfers.remove(this);
      }
      if (needEndDraw) endDraw();
    }
    
    protected void completeAllTransfers()
    {
      if (size <= 0) return;
      completeTransfers(size);
    }
    
    protected void completeTransfers(int count)
    {
      if (size <= 0) return;
      if (count <= 0) { return;
      }
      boolean needEndDraw = false;
      if (!drawing) {
        beginDraw();
        needEndDraw = true;
      }
      
      while ((size > 0) && (count > 0)) {
        endTransfer();
        count--;
      }
      


      if (size <= 0) {
        PGraphicsOpenGL.ongoingPixelTransfers.remove(this);
      }
      
      if (needEndDraw) endDraw();
    }
    
    protected void awaitTransferCompletion(File file)
    {
      if (size <= 0) { return;
      }
      int i = tail;
      int j = 0;
      int lastIndex = 0;
      do {
        if (file.equals(files[i])) {
          lastIndex = j;
        }
        i = (i + 1) % 3;
        j++;
      } while (i != head);
      
      if (lastIndex <= 0) { return;
      }
      
      completeTransfers(lastIndex + 1);
    }
    


    public boolean isLastTransferComplete()
    {
      if (size <= 0) return false;
      int status = pgl.clientWaitSync(fences[tail], 0, 0L);
      return (status == PGL.ALREADY_SIGNALED) || 
        (status == PGL.CONDITION_SATISFIED);
    }
    

    public void beginTransfer(File file)
    {
      if ((widths[head] != pixelWidth) || (heights[head] != pixelHeight)) {
        if (widths[head] * heights[head] != pixelWidth * pixelHeight) {
          pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, pbos[head]);
          pgl.bufferData(PGL.PIXEL_PACK_BUFFER, 
            4 * pixelWidth * pixelHeight, 
            null, PGL.STREAM_READ);
        }
        widths[head] = pixelWidth;
        heights[head] = pixelHeight;
        pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, 0);
      }
      
      pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, pbos[head]);
      pgl.readPixels(0, 0, pixelWidth, pixelHeight, PGL.RGBA, PGL.UNSIGNED_BYTE, 0L);
      pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, 0);
      
      fences[head] = pgl.fenceSync(PGL.SYNC_GPU_COMMANDS_COMPLETE, 0);
      files[head] = file;
      
      head = ((head + 1) % 3);
      size += 1;
    }
    
    public void endTransfer()
    {
      pgl.deleteSync(fences[tail]);
      pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, pbos[tail]);
      ByteBuffer readBuffer = pgl.mapBuffer(PGL.PIXEL_PACK_BUFFER, 
        PGL.READ_ONLY);
      if (readBuffer != null) {
        int format = primaryGraphics ? -2 : -1;
        PImage target = PGraphicsOpenGL.asyncImageSaver.getAvailableTarget(widths[tail], 
          heights[tail], 
          format);
        if (target == null) return;
        readBuffer.rewind();
        readBuffer.asIntBuffer().get(pixels);
        pgl.unmapBuffer(PGL.PIXEL_PACK_BUFFER);
        PGraphicsOpenGL.asyncImageSaver.saveTargetAsync(PGraphicsOpenGL.this, target, 
          files[tail]);
      }
      
      pgl.bindBuffer(PGL.PIXEL_PACK_BUFFER, 0);
      
      size -= 1;
      tail = ((tail + 1) % 3);
    }
    



    boolean calledThisFrame;
  }
  



  public void loadTexture()
  {
    boolean needEndDraw = false;
    if (!drawing) {
      beginDraw();
      needEndDraw = true;
    }
    
    flush();
    
    if (primaryGraphics) {
      updatePixelSize();
      
      if (pgl.isFBOBacked())
      {

        pgl.syncBackTexture();
      } else {
        loadTextureImpl(2, false);
        



        if ((nativePixels == null) || (nativePixels.length < pixelWidth * pixelHeight)) {
          nativePixels = new int[pixelWidth * pixelHeight];
          nativePixelBuffer = PGL.allocateIntBuffer(nativePixels);
        }
        
        beginPixelsOp(1);
        try
        {
          pgl.readPixelsImpl(0, 0, pixelWidth, pixelHeight, PGL.RGBA, PGL.UNSIGNED_BYTE, 
            nativePixelBuffer);
        }
        catch (IndexOutOfBoundsException localIndexOutOfBoundsException) {}
        endPixelsOp();
        
        if (texture != null) {
          texture.setNative(nativePixelBuffer, 0, 0, pixelWidth, pixelHeight);
        }
      }
    } else if (offscreenMultisample)
    {

      FrameBuffer ofb = offscreenFramebuffer;
      FrameBuffer mfb = multisampleFramebuffer;
      if ((ofb != null) && (mfb != null)) {
        mfb.copyColor(ofb);
      }
    }
    
    if (needEndDraw) {
      endDraw();
    }
  }
  

  public void updateTexture()
  {
    if (texture != null) {
      texture.updateTexels();
    }
  }
  


  public void updateTexture(int x, int y, int w, int h)
  {
    if (texture != null) {
      texture.updateTexels(x, y, w, h);
    }
  }
  

  public void updateDisplay()
  {
    flush();
    beginPixelsOp(2);
    drawTexture();
    endPixelsOp();
  }
  
  protected void loadTextureImpl(int sampling, boolean mipmap)
  {
    updatePixelSize();
    if ((pixelWidth == 0) || (pixelHeight == 0)) return;
    if ((texture == null) || (texture.contextIsOutdated())) {
      Texture.Parameters params = new Texture.Parameters(2, 
        sampling, mipmap);
      texture = new Texture(this, pixelWidth, pixelHeight, params);
      texture.invertedY(true);
      texture.colorBuffer(true);
      setCache(this, texture);
    }
  }
  
  protected void createPTexture()
  {
    updatePixelSize();
    if (texture != null) {
      ptexture = new Texture(this, pixelWidth, pixelHeight, texture.getParameters());
      ptexture.invertedY(true);
      ptexture.colorBuffer(true);
    }
  }
  
  protected void swapOffscreenTextures()
  {
    FrameBuffer ofb = offscreenFramebuffer;
    if ((texture != null) && (ptexture != null) && (ofb != null)) {
      int temp = texture.glName;
      texture.glName = ptexture.glName;
      ptexture.glName = temp;
      ofb.setColorBuffer(texture);
    }
  }
  
  protected void drawTexture()
  {
    if (texture != null)
    {

      pgl.disable(PGL.BLEND);
      pgl.drawTexture(texture.glTarget, texture.glName, 
        texture.glWidth, texture.glHeight, 
        0, 0, width, height);
      pgl.enable(PGL.BLEND);
    }
  }
  
  protected void drawTexture(int x, int y, int w, int h)
  {
    if (texture != null)
    {

      pgl.disable(PGL.BLEND);
      pgl.drawTexture(texture.glTarget, texture.glName, 
        texture.glWidth, texture.glHeight, 
        0, 0, width, height, 
        x, y, x + w, y + h, 
        x, height - (y + h), x + w, height - y);
      pgl.enable(PGL.BLEND);
    }
  }
  
  protected void drawPTexture()
  {
    if (ptexture != null)
    {

      pgl.disable(PGL.BLEND);
      pgl.drawTexture(ptexture.glTarget, ptexture.glName, 
        ptexture.glWidth, ptexture.glHeight, 
        0, 0, width, height);
      pgl.enable(PGL.BLEND);
    }
  }
  














  public void mask(PImage alpha)
  {
    updatePixelSize();
    if ((width != pixelWidth) || (height != pixelHeight)) {
      throw new RuntimeException("The PImage used with mask() must be the same size as the applet.");
    }
    

    PGraphicsOpenGL ppg = getPrimaryPG();
    if (maskShader == null) {
      maskShader = new PShader(parent, defTextureShaderVertURL, 
        maskShaderFragURL);
    }
    maskShader.set("mask", alpha);
    filter(maskShader);
  }
  












  public void filter(int kind)
  {
    PImage temp = get();
    temp.filter(kind);
    set(0, 0, temp);
  }
  






  public void filter(int kind, float param)
  {
    PImage temp = get();
    temp.filter(kind, param);
    set(0, 0, temp);
  }
  

  public void filter(PShader shader)
  {
    if (!shader.isPolyShader()) {
      PGraphics.showWarning("Your shader cannot be used as a filter because is of type POINT or LINES");
      return;
    }
    
    boolean needEndDraw = false;
    if (primaryGraphics) {
      pgl.enableFBOLayer();
    } else if (!drawing) {
      beginDraw();
      needEndDraw = true;
    }
    loadTexture();
    
    if ((filterTexture == null) || (filterTexture.contextIsOutdated())) {
      filterTexture = new Texture(this, texture.width, texture.height, 
        texture.getParameters());
      filterTexture.invertedY(true);
      filterImage = wrapTexture(filterTexture);
    }
    filterTexture.set(texture);
    


    pgl.depthMask(false);
    

    pgl.disable(PGL.DEPTH_TEST);
    


    begin2D();
    


    boolean prevLights = lights;
    lights = false;
    int prevTextureMode = textureMode;
    textureMode = 1;
    boolean prevStroke = stroke;
    stroke = false;
    int prevBlendMode = blendMode;
    blendMode(0);
    PShader prevShader = polyShader;
    polyShader = shader;
    
    beginShape(17);
    texture(filterImage);
    vertex(0.0F, 0.0F, 0.0F, 0.0F);
    vertex(width, 0.0F, 1.0F, 0.0F);
    vertex(width, height, 1.0F, 1.0F);
    vertex(0.0F, height, 0.0F, 1.0F);
    endShape();
    end2D();
    

    polyShader = prevShader;
    stroke = prevStroke;
    lights = prevLights;
    textureMode = prevTextureMode;
    blendMode(prevBlendMode);
    
    if (hints[2] == 0) {
      pgl.enable(PGL.DEPTH_TEST);
    }
    if (hints[5] == 0) {
      pgl.depthMask(true);
    }
    
    if (needEndDraw) {
      endDraw();
    }
  }
  







  public void copy(int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh)
  {
    if (primaryGraphics) pgl.enableFBOLayer();
    loadTexture();
    if ((filterTexture == null) || (filterTexture.contextIsOutdated())) {
      filterTexture = new Texture(this, texture.width, texture.height, texture.getParameters());
      filterTexture.invertedY(true);
      filterImage = wrapTexture(filterTexture);
    }
    filterTexture.put(texture, sx, height - (sy + sh), sw, height - sy);
    copy(filterImage, sx, sy, sw, sh, dx, dy, dw, dh);
  }
  



  public void copy(PImage src, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh)
  {
    boolean needEndDraw = false;
    if (!drawing) {
      beginDraw();
      needEndDraw = true;
    }
    
    flush();
    
    Texture tex = getTexture(src);
    boolean invX = tex.invertedX();
    boolean invY = tex.invertedY();
    int scrX1;
    int scrX0;
    int scrX1; if (invX) {
      int scrX0 = dx + dw;
      scrX1 = dx;
    } else {
      scrX0 = dx;
      scrX1 = dx + dw;
    }
    
    int texX0 = sx;
    int texX1 = sx + sw;
    int texY1;
    int scrY0; int scrY1; int texY0; int texY1; if (invY) {
      int scrY0 = height - (dy + dh);
      int scrY1 = height - dy;
      int texY0 = height - (sy + sh);
      texY1 = height - sy;
    }
    else {
      scrY0 = height - dy;
      scrY1 = height - (dy + dh);
      texY0 = sy;
      texY1 = sy + sh;
    }
    
    pgl.drawTexture(glTarget, glName, glWidth, glHeight, 
      0, 0, width, height, 
      texX0, texY0, texX1, texY1, 
      scrX0, scrY0, scrX1, scrY1);
    

    if (needEndDraw) {
      endDraw();
    }
  }
  














  protected void blendModeImpl()
  {
    if (blendMode != lastBlendMode)
    {
      flush();
    }
    
    pgl.enable(PGL.BLEND);
    
    if (blendMode == 0) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE, PGL.ZERO);
    }
    else if (blendMode == 1) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_ADD, 
          PGL.FUNC_ADD);
      }
      pgl.blendFuncSeparate(PGL.SRC_ALPHA, PGL.ONE_MINUS_SRC_ALPHA, 
        PGL.ONE, PGL.ONE);
    }
    else if (blendMode == 2) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_ADD, 
          PGL.FUNC_ADD);
      }
      pgl.blendFuncSeparate(PGL.SRC_ALPHA, PGL.ONE, 
        PGL.ONE, PGL.ONE);
    }
    else if (blendMode == 4) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_REVERSE_SUBTRACT, 
          PGL.FUNC_ADD);
        pgl.blendFuncSeparate(PGL.SRC_ALPHA, PGL.ONE, 
          PGL.ONE, PGL.ONE);
      } else {
        PGraphics.showWarning("blendMode(%1$s) is not supported by this hardware (or driver)", new Object[] { "SUBTRACT" });
      }
    }
    else if (blendMode == 8) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_MAX, 
          PGL.FUNC_ADD);
        pgl.blendFuncSeparate(PGL.ONE, PGL.ONE, 
          PGL.ONE, PGL.ONE);
      } else {
        PGraphics.showWarning("blendMode(%1$s) is not supported by this hardware (or driver)", new Object[] { "LIGHTEST" });
      }
    }
    else if (blendMode == 16) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_MIN, 
          PGL.FUNC_ADD);
        pgl.blendFuncSeparate(PGL.ONE, PGL.ONE, 
          PGL.ONE, PGL.ONE);
      } else {
        PGraphics.showWarning("blendMode(%1$s) is not supported by this hardware (or driver)", new Object[] { "DARKEST" });
      }
    }
    else if (blendMode == 64) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_ADD, 
          PGL.FUNC_ADD);
      }
      pgl.blendFuncSeparate(PGL.ONE_MINUS_DST_COLOR, PGL.ONE_MINUS_SRC_COLOR, 
        PGL.ONE, PGL.ONE);
    }
    else if (blendMode == 128) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_ADD, 
          PGL.FUNC_ADD);
      }
      pgl.blendFuncSeparate(PGL.ZERO, PGL.SRC_COLOR, 
        PGL.ONE, PGL.ONE);
    }
    else if (blendMode == 256) {
      if (blendEqSupported) {
        pgl.blendEquationSeparate(PGL.FUNC_ADD, 
          PGL.FUNC_ADD);
      }
      pgl.blendFuncSeparate(PGL.ONE_MINUS_DST_COLOR, PGL.ONE, 
        PGL.ONE, PGL.ONE);
    }
    else if (blendMode == 32) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "DIFFERENCE" });
    }
    else if (blendMode == 512) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "OVERLAY" });
    }
    else if (blendMode == 1024) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "HARD_LIGHT" });
    }
    else if (blendMode == 2048) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "SOFT_LIGHT" });
    }
    else if (blendMode == 4096) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "DODGE" });
    }
    else if (blendMode == 8192) {
      PGraphics.showWarning("blendMode(%1$s) is not supported by this renderer", new Object[] { "BURN" });
    }
    lastBlendMode = blendMode;
  }
  


















  public Texture getTexture()
  {
    return getTexture(true);
  }
  



  public Texture getTexture(boolean load)
  {
    if (load) loadTexture();
    return texture;
  }
  







  public Texture getTexture(PImage img)
  {
    Texture tex = (Texture)initCache(img);
    if (tex == null) { return null;
    }
    if (img.isModified()) {
      if ((width != width) || (height != height)) {
        tex.init(width, height);
      }
      updateTexture(img, tex);
    }
    
    if (tex.hasBuffers()) {
      tex.bufferUpdate();
    }
    
    checkTexture(tex);
    
    return tex;
  }
  




  public FrameBuffer getFrameBuffer()
  {
    return getFrameBuffer(false);
  }
  
  public FrameBuffer getFrameBuffer(boolean multi)
  {
    if (multi) {
      return multisampleFramebuffer;
    }
    return offscreenFramebuffer;
  }
  

  protected Object initCache(PImage img)
  {
    if (!checkGLThread()) {
      return null;
    }
    
    Texture tex = (Texture)getCache(img);
    if ((tex == null) || (tex.contextIsOutdated())) {
      tex = addTexture(img);
      if (tex != null) {
        img.loadPixels();
        tex.set(pixels, format);
        img.setModified();
      }
    }
    return tex;
  }
  
  protected void bindFrontTexture()
  {
    if (primaryGraphics) {
      pgl.bindFrontTexture();
    } else {
      if (ptexture == null) {
        createPTexture();
      }
      ptexture.bind();
    }
  }
  
  protected void unbindFrontTexture()
  {
    if (primaryGraphics) {
      pgl.unbindFrontTexture();
    } else {
      ptexture.unbind();
    }
  }
  





  protected Texture addTexture(PImage img)
  {
    Texture.Parameters params = 
      new Texture.Parameters(2, textureSampling, 
      getHint(-8), textureWrap);
    return addTexture(img, params);
  }
  
  protected Texture addTexture(PImage img, Texture.Parameters params)
  {
    if ((width == 0) || (height == 0))
    {
      return null;
    }
    if (parent == null) {
      parent = parent;
    }
    Texture tex = new Texture(this, pixelWidth, pixelHeight, params);
    setCache(img, tex);
    return tex;
  }
  
  protected void checkTexture(Texture tex)
  {
    if ((!tex.colorBuffer()) && (
      (usingMipmaps == hints[8]) || 
      (tex.currentSampling() != textureSampling))) {
      if (hints[8] != 0) {
        tex.usingMipmaps(false, textureSampling);
      } else {
        tex.usingMipmaps(true, textureSampling);
      }
    }
    
    if (((usingRepeat) && (textureWrap == 0)) || (
      (!usingRepeat) && (textureWrap == 1))) {
      if (textureWrap == 0) {
        tex.usingRepeat(false);
      } else {
        tex.usingRepeat(true);
      }
    }
  }
  


  protected PImage wrapTexture(Texture tex)
  {
    PImage img = new PImage();
    parent = parent;
    width = width;
    height = height;
    format = 2;
    setCache(img, tex);
    return img;
  }
  
  protected void updateTexture(PImage img, Texture tex)
  {
    if ((tex != null) && 
      (img.isModified())) {
      int x = img.getModifiedX1();
      int y = img.getModifiedY1();
      int w = img.getModifiedX2() - x;
      int h = img.getModifiedY2() - y;
      tex.set(pixels, x, y, w, h, format);
    }
    
    img.setModified(false);
  }
  
  protected void deleteSurfaceTextures()
  {
    if (texture != null) {
      texture.dispose();
    }
    
    if (ptexture != null) {
      ptexture.dispose();
    }
    
    if (filterTexture != null) {
      filterTexture.dispose();
    }
  }
  
  protected boolean checkGLThread()
  {
    if (pgl.threadIsCurrent()) {
      return true;
    }
    PGraphics.showWarning("Cannot run the OpenGL renderer outside the main thread, change your code\nso the drawing calls are all inside the main thread, \nor use the default renderer instead.");
    return false;
  }
  







  public void resize(int wide, int high)
  {
    PGraphics.showMethodWarning("resize");
  }
  





  protected void initPrimary()
  {
    pgl.initSurface(smooth);
    if (texture != null) {
      removeCache(this);
      texture = null;
      ptexture = null;
    }
    initialized = true;
  }
  
  protected void beginOnscreenDraw()
  {
    updatePixelSize();
    
    pgl.beginRender();
    
    if (drawFramebuffer == null) {
      drawFramebuffer = new FrameBuffer(this, pixelWidth, pixelHeight, true);
    }
    drawFramebuffer.setFBO(pgl.getDrawFramebuffer());
    if (readFramebuffer == null) {
      readFramebuffer = new FrameBuffer(this, pixelWidth, pixelHeight, true);
    }
    readFramebuffer.setFBO(pgl.getReadFramebuffer());
    if (currentFramebuffer == null) {
      setFramebuffer(drawFramebuffer);
    }
    
    if (pgl.isFBOBacked()) {
      texture = pgl.wrapBackTexture(texture);
      ptexture = pgl.wrapFrontTexture(ptexture);
    }
  }
  
  protected void endOnscreenDraw()
  {
    pgl.endRender(parent.sketchWindowColor());
  }
  

  protected void initOffscreen()
  {
    loadTextureImpl(textureSampling, false);
    
    FrameBuffer ofb = offscreenFramebuffer;
    FrameBuffer mfb = multisampleFramebuffer;
    



    if (ofb != null) {
      ofb.dispose();
      ofb = null;
    }
    if (mfb != null) {
      mfb.dispose();
      mfb = null;
    }
    
    boolean packed = (depthBits == 24) && (stencilBits == 8) && 
      (packedDepthStencilSupported);
    if ((fboMultisampleSupported) && (1 < PGL.smoothToSamples(smooth))) {
      mfb = new FrameBuffer(this, texture.glWidth, texture.glHeight, PGL.smoothToSamples(smooth), 0, 
        depthBits, stencilBits, packed, false);
      mfb.clear();
      multisampleFramebuffer = mfb;
      offscreenMultisample = true;
      



      if (hints[10] != 0) {
        ofb = new FrameBuffer(this, texture.glWidth, texture.glHeight, 1, 1, 
          depthBits, stencilBits, packed, false);
      } else {
        ofb = new FrameBuffer(this, texture.glWidth, texture.glHeight, 1, 1, 
          0, 0, false, false);
      }
    } else {
      smooth = 0;
      ofb = new FrameBuffer(this, texture.glWidth, texture.glHeight, 1, 1, 
        depthBits, stencilBits, packed, false);
      offscreenMultisample = false;
    }
    ofb.setColorBuffer(texture);
    ofb.clear();
    offscreenFramebuffer = ofb;
    
    initialized = true;
  }
  
  protected void beginOffscreenDraw()
  {
    if (!initialized) {
      initOffscreen();
    } else {
      FrameBuffer ofb = offscreenFramebuffer;
      FrameBuffer mfb = multisampleFramebuffer;
      boolean outdated = (ofb != null) && (ofb.contextIsOutdated());
      boolean outdatedMulti = (mfb != null) && (mfb.contextIsOutdated());
      if ((outdated) || (outdatedMulti)) {
        restartPGL();
        initOffscreen();

      }
      else
      {
        swapOffscreenTextures();
      }
    }
    
    pushFramebuffer();
    if (offscreenMultisample) {
      FrameBuffer mfb = multisampleFramebuffer;
      if (mfb != null) {
        setFramebuffer(mfb);
      }
    } else {
      FrameBuffer ofb = offscreenFramebuffer;
      if (ofb != null) {
        setFramebuffer(ofb);
      }
    }
    

    drawPTexture();
    

    if (clip) {
      pgl.enable(PGL.SCISSOR_TEST);
      pgl.scissor(clipRect[0], clipRect[1], clipRect[2], clipRect[3]);
    } else {
      pgl.disable(PGL.SCISSOR_TEST);
    }
  }
  
  protected void endOffscreenDraw()
  {
    if (offscreenMultisample) {
      FrameBuffer ofb = offscreenFramebuffer;
      FrameBuffer mfb = multisampleFramebuffer;
      if ((ofb != null) && (mfb != null)) {
        mfb.copyColor(ofb);
      }
    }
    
    popFramebuffer();
    
    if (backgroundA == 1.0F)
    {


      pgl.colorMask(false, false, false, true);
      pgl.clearColor(0.0F, 0.0F, 0.0F, backgroundA);
      pgl.clear(PGL.COLOR_BUFFER_BIT);
      pgl.colorMask(true, true, true, true);
    }
    
    if (texture != null) {
      texture.updateTexels();
    }
    
    getPrimaryPG().restoreGL();
  }
  
  protected void setViewport()
  {
    viewport.put(0, 0);viewport.put(1, 0);
    viewport.put(2, width);viewport.put(3, height);
    pgl.viewport(viewport.get(0), viewport.get(1), 
      viewport.get(2), viewport.get(3));
  }
  

  protected void checkSettings()
  {
    super.checkSettings();
    setGLSettings();
  }
  
  protected void setGLSettings()
  {
    inGeo.clear();
    tessGeo.clear();
    texCache.clear();
    

    super.noTexture();
    

    blendModeImpl();
    

    if (hints[2] != 0) {
      pgl.disable(PGL.DEPTH_TEST);
    } else {
      pgl.enable(PGL.DEPTH_TEST);
    }
    
    pgl.depthFunc(PGL.LEQUAL);
    
    if (hints[6] != 0) {
      flushMode = 0;
    } else {
      flushMode = 1;
    }
    








    if (!OPENGL_RENDERER.equals("VideoCore IV HW"))
    {

      if (smooth < 1) {
        pgl.disable(PGL.MULTISAMPLE);
      } else if (1 <= smooth) {
        pgl.enable(PGL.MULTISAMPLE);
      }
    }
    if (!OPENGL_RENDERER.equals("VideoCore IV HW")) {
      pgl.disable(PGL.POLYGON_SMOOTH);
    }
    
    if (sized)
    {



      if (primaryGraphics) {
        background(backgroundColor);
      }
      else {
        background(backgroundColor & 0xFFFFFF);
      }
      




      defaultPerspective();
      defaultCamera();
      

      sized = false;
    }
    else
    {
      modelview.set(camera);
      modelviewInv.set(cameraInv);
      updateProjmodelview();
    }
    
    if (is3D()) {
      noLights();
      lightFalloff(1.0F, 0.0F, 0.0F);
      lightSpecular(0.0F, 0.0F, 0.0F);
    }
    






    pgl.frontFace(PGL.CW);
    pgl.disable(PGL.CULL_FACE);
    

    pgl.activeTexture(PGL.TEXTURE0);
    

    normalX = (this.normalY = 0.0F);
    normalZ = 1.0F;
    

    pgl.depthMask(true);
    pgl.clearDepth(1.0F);
    pgl.clearStencil(0);
    pgl.clear(PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT);
    
    if (hints[5] != 0) {
      pgl.depthMask(false);
    } else {
      pgl.depthMask(true);
    }
    
    pixelsOp = 0;
    
    modified = false;
    loaded = false;
  }
  
  protected void getGLParameters()
  {
    OPENGL_VENDOR = pgl.getString(PGL.VENDOR);
    OPENGL_RENDERER = pgl.getString(PGL.RENDERER);
    OPENGL_VERSION = pgl.getString(PGL.VERSION);
    OPENGL_EXTENSIONS = pgl.getString(PGL.EXTENSIONS);
    GLSL_VERSION = pgl.getString(PGL.SHADING_LANGUAGE_VERSION);
    
    npotTexSupported = pgl.hasNpotTexSupport();
    autoMipmapGenSupported = pgl.hasAutoMipmapGenSupport();
    fboMultisampleSupported = pgl.hasFboMultisampleSupport();
    packedDepthStencilSupported = pgl.hasPackedDepthStencilSupport();
    anisoSamplingSupported = pgl.hasAnisoSamplingSupport();
    readBufferSupported = pgl.hasReadBuffer();
    drawBufferSupported = pgl.hasDrawBuffer();
    try
    {
      pgl.blendEquation(PGL.FUNC_ADD);
      blendEqSupported = true;
    } catch (Exception localException) {
      blendEqSupported = false;
    }
    
    depthBits = pgl.getDepthBits();
    stencilBits = pgl.getStencilBits();
    
    pgl.getIntegerv(PGL.MAX_TEXTURE_SIZE, intBuffer);
    maxTextureSize = intBuffer.get(0);
    

    if (!OPENGL_RENDERER.equals("VideoCore IV HW")) {
      pgl.getIntegerv(PGL.MAX_SAMPLES, intBuffer);
      maxSamples = intBuffer.get(0);
    }
    
    if (anisoSamplingSupported) {
      pgl.getFloatv(PGL.MAX_TEXTURE_MAX_ANISOTROPY, floatBuffer);
      maxAnisoAmount = floatBuffer.get(0);
    }
    


    if ((OPENGL_RENDERER.equals("VideoCore IV HW")) || 
      (OPENGL_RENDERER.equals("Gallium 0.4 on VC4"))) {
      defLightShaderVertURL = 
        PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/LightVert-vc4.glsl");
      defTexlightShaderVertURL = 
        PGraphicsOpenGL.class.getResource("/processing/opengl/shaders/TexLightVert-vc4.glsl");
    }
    
    glParamsRead = true;
  }
  






  public PShader loadShader(String fragFilename)
  {
    if ((fragFilename == null) || (fragFilename.equals(""))) {
      PGraphics.showWarning("The fragment shader is missing, cannot create shader object");
      return null;
    }
    
    int type = PShader.getShaderType(parent.loadStrings(fragFilename), 
      2);
    PShader shader = new PShader(parent);
    shader.setType(type);
    shader.setFragmentShader(fragFilename);
    if (type == 0) {
      String[] vertSource = pgl.loadVertexShader(defPointShaderVertURL);
      shader.setVertexShader(vertSource);
    } else if (type == 1) {
      String[] vertSource = pgl.loadVertexShader(defLineShaderVertURL);
      shader.setVertexShader(vertSource);
    } else if (type == 6) {
      String[] vertSource = pgl.loadVertexShader(defTexlightShaderVertURL);
      shader.setVertexShader(vertSource);
    } else if (type == 4) {
      String[] vertSource = pgl.loadVertexShader(defLightShaderVertURL);
      shader.setVertexShader(vertSource);
    } else if (type == 5) {
      String[] vertSource = pgl.loadVertexShader(defTextureShaderVertURL);
      shader.setVertexShader(vertSource);
    } else if (type == 3) {
      String[] vertSource = pgl.loadVertexShader(defColorShaderVertURL);
      shader.setVertexShader(vertSource);
    } else {
      String[] vertSource = pgl.loadVertexShader(defTextureShaderVertURL);
      shader.setVertexShader(vertSource);
    }
    return shader;
  }
  

  public PShader loadShader(String fragFilename, String vertFilename)
  {
    PShader shader = null;
    if ((fragFilename == null) || (fragFilename.equals(""))) {
      PGraphics.showWarning("The fragment shader is missing, cannot create shader object");
    } else if ((vertFilename == null) || (vertFilename.equals(""))) {
      PGraphics.showWarning("The vertex shader is missing, cannot create shader object");
    } else {
      shader = new PShader(parent, vertFilename, fragFilename);
    }
    return shader;
  }
  

  public void shader(PShader shader)
  {
    flush();
    
    if (shader != null) shader.init();
    if (shader.isPolyShader()) { polyShader = shader;
    } else if (shader.isLineShader()) { lineShader = shader;
    } else if (shader.isPointShader()) pointShader = shader; else {
      PGraphics.showWarning("Unknown shader kind");
    }
  }
  
  public void shader(PShader shader, int kind)
  {
    flush();
    
    if (shader != null) shader.init();
    if (kind == 9) { polyShader = shader;
    } else if (kind == 5) { lineShader = shader;
    } else if (kind == 3) pointShader = shader; else {
      PGraphics.showWarning("Unknown shader kind");
    }
  }
  
  public void resetShader()
  {
    resetShader(9);
  }
  

  public void resetShader(int kind)
  {
    flush();
    
    if ((kind == 9) || (kind == 17) || (kind == 20)) {
      polyShader = null;
    } else if (kind == 5) {
      lineShader = null;
    } else if (kind == 3) {
      pointShader = null;
    } else {
      PGraphics.showWarning("Unknown shader kind");
    }
  }
  

  protected PShader getPolyShader(boolean lit, boolean tex)
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    boolean useDefault = polyShader == null;
    if (polyShader != null) {
      polyShader.setRenderer(this);
      polyShader.loadAttributes();
      polyShader.loadUniforms(); }
    PShader shader;
    PShader shader; if (lit) { PShader shader;
      if (tex) { PShader shader;
        if ((useDefault) || (!polyShader.checkPolyType(6))) {
          if (defTexlightShader == null) {
            String[] vertSource = pgl.loadVertexShader(defTexlightShaderVertURL);
            String[] fragSource = pgl.loadFragmentShader(defTexlightShaderFragURL);
            defTexlightShader = new PShader(parent, vertSource, fragSource);
          }
          shader = defTexlightShader;
        } else {
          shader = polyShader;
        }
      } else { PShader shader;
        if ((useDefault) || (!polyShader.checkPolyType(4))) {
          if (defLightShader == null) {
            String[] vertSource = pgl.loadVertexShader(defLightShaderVertURL);
            String[] fragSource = pgl.loadFragmentShader(defLightShaderFragURL);
            defLightShader = new PShader(parent, vertSource, fragSource);
          }
          shader = defLightShader;
        } else {
          shader = polyShader;
        }
      }
    } else {
      if ((polyShader != null) && (polyShader.accessLightAttribs())) {
        PGraphics.showWarning("The provided shader needs light attributes (ambient, diffuse, etc.), but the current scene is unlit, so the default shader will be used instead");
        useDefault = true;
      }
      PShader shader;
      if (tex) { PShader shader;
        if ((useDefault) || (!polyShader.checkPolyType(5))) {
          if (defTextureShader == null) {
            String[] vertSource = pgl.loadVertexShader(defTextureShaderVertURL);
            String[] fragSource = pgl.loadFragmentShader(defTextureShaderFragURL);
            defTextureShader = new PShader(parent, vertSource, fragSource);
          }
          shader = defTextureShader;
        } else {
          shader = polyShader;
        }
      } else { PShader shader;
        if ((useDefault) || (!polyShader.checkPolyType(3))) {
          if (defColorShader == null) {
            String[] vertSource = pgl.loadVertexShader(defColorShaderVertURL);
            String[] fragSource = pgl.loadFragmentShader(defColorShaderFragURL);
            defColorShader = new PShader(parent, vertSource, fragSource);
          }
          shader = defColorShader;
        } else {
          shader = polyShader;
        }
      }
    }
    if (shader != polyShader) {
      shader.setRenderer(this);
      shader.loadAttributes();
      shader.loadUniforms();
    }
    return shader;
  }
  

  protected PShader getLineShader()
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    PShader shader; PShader shader; if (lineShader == null) {
      if (defLineShader == null) {
        String[] vertSource = pgl.loadVertexShader(defLineShaderVertURL);
        String[] fragSource = pgl.loadFragmentShader(defLineShaderFragURL);
        defLineShader = new PShader(parent, vertSource, fragSource);
      }
      shader = defLineShader;
    } else {
      shader = lineShader;
    }
    shader.setRenderer(this);
    shader.loadAttributes();
    shader.loadUniforms();
    return shader;
  }
  

  protected PShader getPointShader()
  {
    PGraphicsOpenGL ppg = getPrimaryPG();
    PShader shader; PShader shader; if (pointShader == null) {
      if (defPointShader == null) {
        String[] vertSource = pgl.loadVertexShader(defPointShaderVertURL);
        String[] fragSource = pgl.loadFragmentShader(defPointShaderFragURL);
        defPointShader = new PShader(parent, vertSource, fragSource);
      }
      shader = defPointShader;
    } else {
      shader = pointShader;
    }
    shader.setRenderer(this);
    shader.loadAttributes();
    shader.loadUniforms();
    return shader;
  }
  




  protected static int expandArraySize(int currSize, int newMinSize)
  {
    int newSize = currSize;
    while (newSize < newMinSize) {
      newSize <<= 1;
    }
    return newSize;
  }
  




  protected static AttributeMap newAttributeMap()
  {
    return new AttributeMap();
  }
  
  protected static class AttributeMap extends HashMap<String, PGraphicsOpenGL.VertexAttribute>
  {
    public ArrayList<String> names = new ArrayList();
    public int numComp = 0;
    
    protected AttributeMap() {}
    
    public PGraphicsOpenGL.VertexAttribute put(String key, PGraphicsOpenGL.VertexAttribute value) { PGraphicsOpenGL.VertexAttribute prev = (PGraphicsOpenGL.VertexAttribute)super.put(key, value);
      names.add(key);
      if (kind == 2) numComp += 4; else
        numComp += size;
      return prev;
    }
    
    public PGraphicsOpenGL.VertexAttribute get(int i) {
      return (PGraphicsOpenGL.VertexAttribute)super.get(names.get(i));
    }
  }
  

  protected static class VertexAttribute
  {
    static final int POSITION = 0;
    
    static final int NORMAL = 1;
    
    static final int COLOR = 2;
    static final int OTHER = 3;
    PGraphicsOpenGL pg;
    String name;
    int kind;
    int type;
    int size;
    int tessSize;
    int elementSize;
    VertexBuffer buf;
    int glLoc;
    float[] fvalues;
    int[] ivalues;
    byte[] bvalues;
    boolean modified;
    int firstModified;
    int lastModified;
    boolean active;
    
    VertexAttribute(PGraphicsOpenGL pg, String name, int kind, int type, int size)
    {
      this.pg = pg;
      this.name = name;
      this.kind = kind;
      this.type = type;
      this.size = size;
      
      if (kind == 0) {
        tessSize = 4;
      } else {
        tessSize = size;
      }
      
      if (type == PGL.FLOAT) {
        elementSize = PGL.SIZEOF_FLOAT;
        fvalues = new float[size];
      } else if (type == PGL.INT) {
        elementSize = PGL.SIZEOF_INT;
        ivalues = new int[size];
      } else if (type == PGL.BOOL) {
        elementSize = PGL.SIZEOF_INT;
        bvalues = new byte[size];
      }
      
      buf = null;
      glLoc = -1;
      
      modified = false;
      firstModified = Integer.MAX_VALUE;
      lastModified = Integer.MIN_VALUE;
      
      active = true;
    }
    
    public boolean diff(VertexAttribute attr) {
      return (!name.equals(name)) || 
        (kind != kind) || 
        (type != type) || 
        (size != size) || 
        (tessSize != tessSize) || 
        (elementSize != elementSize);
    }
    
    boolean isPosition() {
      return kind == 0;
    }
    
    boolean isNormal() {
      return kind == 1;
    }
    
    boolean isColor() {
      return kind == 2;
    }
    
    boolean isOther() {
      return kind == 3;
    }
    
    boolean isFloat() {
      return type == PGL.FLOAT;
    }
    
    boolean isInt() {
      return type == PGL.INT;
    }
    
    boolean isBool() {
      return type == PGL.BOOL;
    }
    
    boolean bufferCreated() {
      return (buf != null) && (buf.glId > 0);
    }
    
    void createBuffer(PGL pgl) {
      buf = new VertexBuffer(pg, PGL.ARRAY_BUFFER, size, elementSize, false);
    }
    
    void deleteBuffer(PGL pgl) {
      if (buf.glId != 0) {
        PGraphicsOpenGL.intBuffer.put(0, buf.glId);
        if (pgl.threadIsCurrent()) pgl.deleteBuffers(1, PGraphicsOpenGL.intBuffer);
      }
    }
    
    void bind(PGL pgl) {
      pgl.enableVertexAttribArray(glLoc);
    }
    
    void unbind(PGL pgl) {
      pgl.disableVertexAttribArray(glLoc);
    }
    
    boolean active(PShader shader) {
      if ((active) && 
        (glLoc == -1)) {
        glLoc = shader.getAttributeLoc(name);
        if (glLoc == -1) { active = false;
        }
      }
      return active;
    }
    
    int sizeInBytes(int length) {
      return length * tessSize * elementSize;
    }
    
    void set(float x, float y, float z) {
      fvalues[0] = x;
      fvalues[1] = y;
      fvalues[2] = z;
    }
    
    void set(int c) {
      ivalues[0] = c;
    }
    
    void set(float[] values) {
      PApplet.arrayCopy(values, 0, fvalues, 0, size);
    }
    
    void set(int[] values) {
      PApplet.arrayCopy(values, 0, ivalues, 0, size);
    }
    
    void set(boolean[] values) {
      for (int i = 0; i < values.length; i++) {
        bvalues[i] = ((byte)(values[i] != 0 ? 1 : 0));
      }
    }
    
    void add(float[] dstValues, int dstIdx) {
      PApplet.arrayCopy(fvalues, 0, dstValues, dstIdx, size);
    }
    
    void add(int[] dstValues, int dstIdx) {
      PApplet.arrayCopy(ivalues, 0, dstValues, dstIdx, size);
    }
    
    void add(byte[] dstValues, int dstIdx) {
      PApplet.arrayCopy(bvalues, 0, dstValues, dstIdx, size);
    }
  }
  






  protected static InGeometry newInGeometry(PGraphicsOpenGL pg, AttributeMap attr, int mode)
  {
    return new InGeometry(pg, attr, mode);
  }
  

  protected static TessGeometry newTessGeometry(PGraphicsOpenGL pg, AttributeMap attr, int mode)
  {
    return new TessGeometry(pg, attr, mode);
  }
  
  protected static TexCache newTexCache(PGraphicsOpenGL pg)
  {
    return new TexCache(pg);
  }
  

  protected static class TexCache
  {
    PGraphicsOpenGL pg;
    int size;
    PImage[] textures;
    int[] firstIndex;
    int[] lastIndex;
    int[] firstCache;
    int[] lastCache;
    boolean hasTextures;
    
    TexCache(PGraphicsOpenGL pg)
    {
      this.pg = pg;
      allocate();
    }
    
    void allocate() {
      textures = new PImage[PGL.DEFAULT_IN_TEXTURES];
      firstIndex = new int[PGL.DEFAULT_IN_TEXTURES];
      lastIndex = new int[PGL.DEFAULT_IN_TEXTURES];
      firstCache = new int[PGL.DEFAULT_IN_TEXTURES];
      lastCache = new int[PGL.DEFAULT_IN_TEXTURES];
      size = 0;
      hasTextures = false;
    }
    
    void clear() {
      Arrays.fill(textures, 0, size, null);
      size = 0;
      hasTextures = false;
    }
    
    boolean containsTexture(PImage img) {
      for (int i = 0; i < size; i++) {
        if (textures[i] == img) return true;
      }
      return false;
    }
    
    PImage getTextureImage(int i) {
      return textures[i];
    }
    
    Texture getTexture(int i) {
      PImage img = textures[i];
      Texture tex = null;
      
      if (img != null) {
        tex = pg.getTexture(img);
      }
      
      return tex;
    }
    
    void addTexture(PImage img, int firsti, int firstb, int lasti, int lastb) {
      arrayCheck();
      
      textures[size] = img;
      firstIndex[size] = firsti;
      lastIndex[size] = lasti;
      firstCache[size] = firstb;
      lastCache[size] = lastb;
      

      hasTextures |= img != null;
      
      size += 1;
    }
    
    void setLastIndex(int lasti, int lastb) {
      lastIndex[(size - 1)] = lasti;
      lastCache[(size - 1)] = lastb;
    }
    
    void arrayCheck() {
      if (size == textures.length) {
        int newSize = size << 1;
        
        expandTextures(newSize);
        expandFirstIndex(newSize);
        expandLastIndex(newSize);
        expandFirstCache(newSize);
        expandLastCache(newSize);
      }
    }
    
    void expandTextures(int n) {
      PImage[] temp = new PImage[n];
      PApplet.arrayCopy(textures, 0, temp, 0, size);
      textures = temp;
    }
    
    void expandFirstIndex(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(firstIndex, 0, temp, 0, size);
      firstIndex = temp;
    }
    
    void expandLastIndex(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(lastIndex, 0, temp, 0, size);
      lastIndex = temp;
    }
    
    void expandFirstCache(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(firstCache, 0, temp, 0, size);
      firstCache = temp;
    }
    
    void expandLastCache(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(lastCache, 0, temp, 0, size);
      lastCache = temp;
    }
  }
  

  protected static class IndexCache
  {
    int size;
    
    int[] indexCount;
    int[] indexOffset;
    int[] vertexCount;
    int[] vertexOffset;
    int[] counter;
    
    IndexCache()
    {
      allocate();
    }
    
    void allocate() {
      size = 0;
      indexCount = new int[2];
      indexOffset = new int[2];
      vertexCount = new int[2];
      vertexOffset = new int[2];
      counter = null;
    }
    
    void clear() {
      size = 0;
    }
    
    int addNew() {
      arrayCheck();
      init(size);
      size += 1;
      return size - 1;
    }
    
    int addNew(int index) {
      arrayCheck();
      indexCount[size] = indexCount[index];
      indexOffset[size] = indexOffset[index];
      vertexCount[size] = vertexCount[index];
      vertexOffset[size] = vertexOffset[index];
      size += 1;
      return size - 1;
    }
    
    int getLast() {
      if (size == 0) {
        arrayCheck();
        init(0);
        size = 1;
      }
      return size - 1;
    }
    
    void setCounter(int[] counter) {
      this.counter = counter;
    }
    
    void incCounts(int index, int icount, int vcount) {
      indexCount[index] += icount;
      vertexCount[index] += vcount;
      if (counter != null) {
        counter[0] += icount;
        counter[1] += vcount;
      }
    }
    
    void init(int n) {
      if (n > 0) {
        indexOffset[n] = (indexOffset[(n - 1)] + indexCount[(n - 1)]);
        vertexOffset[n] = (vertexOffset[(n - 1)] + vertexCount[(n - 1)]);
      } else {
        indexOffset[n] = 0;
        vertexOffset[n] = 0;
      }
      indexCount[n] = 0;
      vertexCount[n] = 0;
    }
    
    void arrayCheck() {
      if (size == indexCount.length) {
        int newSize = size << 1;
        
        expandIndexCount(newSize);
        expandIndexOffset(newSize);
        expandVertexCount(newSize);
        expandVertexOffset(newSize);
      }
    }
    
    void expandIndexCount(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(indexCount, 0, temp, 0, size);
      indexCount = temp;
    }
    
    void expandIndexOffset(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(indexOffset, 0, temp, 0, size);
      indexOffset = temp;
    }
    
    void expandVertexCount(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(vertexCount, 0, temp, 0, size);
      vertexCount = temp;
    }
    
    void expandVertexOffset(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(vertexOffset, 0, temp, 0, size);
      vertexOffset = temp;
    }
  }
  

  protected static class InGeometry
  {
    PGraphicsOpenGL pg;
    
    int renderMode;
    
    PGraphicsOpenGL.AttributeMap attribs;
    
    int vertexCount;
    
    int codeCount;
    
    int edgeCount;
    
    float[] vertices;
    
    int[] colors;
    
    float[] normals;
    
    float[] texcoords;
    
    int[] strokeColors;
    float[] strokeWeights;
    int[] codes;
    int[][] edges;
    int[] ambient;
    int[] specular;
    int[] emissive;
    float[] shininess;
    HashMap<String, float[]> fattribs;
    HashMap<String, int[]> iattribs;
    HashMap<String, byte[]> battribs;
    int fillColor;
    int strokeColor;
    float strokeWeight;
    int ambientColor;
    int specularColor;
    int emissiveColor;
    float shininessFactor;
    float normalX;
    float normalY;
    float normalZ;
    
    InGeometry(PGraphicsOpenGL pg, PGraphicsOpenGL.AttributeMap attr, int mode)
    {
      this.pg = pg;
      attribs = attr;
      renderMode = mode;
      allocate();
    }
    



    void clear()
    {
      vertexCount = 0;
      codeCount = 0;
      edgeCount = 0;
    }
    
    void clearEdges() {
      edgeCount = 0;
    }
    
    void allocate() {
      vertices = new float[3 * PGL.DEFAULT_IN_VERTICES];
      colors = new int[PGL.DEFAULT_IN_VERTICES];
      normals = new float[3 * PGL.DEFAULT_IN_VERTICES];
      texcoords = new float[2 * PGL.DEFAULT_IN_VERTICES];
      strokeColors = new int[PGL.DEFAULT_IN_VERTICES];
      strokeWeights = new float[PGL.DEFAULT_IN_VERTICES];
      ambient = new int[PGL.DEFAULT_IN_VERTICES];
      specular = new int[PGL.DEFAULT_IN_VERTICES];
      emissive = new int[PGL.DEFAULT_IN_VERTICES];
      shininess = new float[PGL.DEFAULT_IN_VERTICES];
      edges = new int[PGL.DEFAULT_IN_EDGES][3];
      
      fattribs = new HashMap();
      iattribs = new HashMap();
      battribs = new HashMap();
      
      clear();
    }
    
    void initAttrib(PGraphicsOpenGL.VertexAttribute attrib) {
      if (type == PGL.FLOAT) {
        float[] temp = new float[size * PGL.DEFAULT_IN_VERTICES];
        fattribs.put(name, temp);
      } else if (type == PGL.INT) {
        int[] temp = new int[size * PGL.DEFAULT_IN_VERTICES];
        iattribs.put(name, temp);
      } else if (type == PGL.BOOL) {
        byte[] temp = new byte[size * PGL.DEFAULT_IN_VERTICES];
        battribs.put(name, temp);
      }
    }
    
    void vertexCheck() {
      if (vertexCount == vertices.length / 3) {
        int newSize = vertexCount << 1;
        
        expandVertices(newSize);
        expandColors(newSize);
        expandNormals(newSize);
        expandTexCoords(newSize);
        expandStrokeColors(newSize);
        expandStrokeWeights(newSize);
        expandAmbient(newSize);
        expandSpecular(newSize);
        expandEmissive(newSize);
        expandShininess(newSize);
        expandAttribs(newSize);
      }
    }
    
    void codeCheck() {
      if (codeCount == codes.length) {
        int newLen = codeCount << 1;
        
        expandCodes(newLen);
      }
    }
    
    void edgeCheck() {
      if (edgeCount == edges.length) {
        int newLen = edgeCount << 1;
        
        expandEdges(newLen);
      }
    }
    



    float getVertexX(int idx)
    {
      return vertices[(3 * idx + 0)];
    }
    
    float getVertexY(int idx) {
      return vertices[(3 * idx + 1)];
    }
    
    float getVertexZ(int idx) {
      return vertices[(3 * idx + 2)];
    }
    
    float getLastVertexX() {
      return vertices[(3 * (vertexCount - 1) + 0)];
    }
    
    float getLastVertexY() {
      return vertices[(3 * (vertexCount - 1) + 1)];
    }
    
    float getLastVertexZ() {
      return vertices[(3 * (vertexCount - 1) + 2)];
    }
    
    int getNumEdgeClosures() {
      int count = 0;
      for (int i = 0; i < edgeCount; i++) {
        if (edges[i][2] == -1) count++;
      }
      return count;
    }
    
    int getNumEdgeVertices(boolean bevel) {
      int segVert = edgeCount;
      int bevVert = 0;
      if (bevel) {
        for (int i = 0; i < edgeCount; i++) {
          int[] edge = edges[i];
          if ((edge[2] == 0) || (edge[2] == 1)) bevVert += 3;
          if (edge[2] == -1) {
            bevVert += 5;
            segVert--;
          }
        }
      } else {
        segVert -= getNumEdgeClosures();
      }
      return 4 * segVert + bevVert;
    }
    
    int getNumEdgeIndices(boolean bevel) {
      int segInd = edgeCount;
      int bevInd = 0;
      if (bevel) {
        for (int i = 0; i < edgeCount; i++) {
          int[] edge = edges[i];
          if ((edge[2] == 0) || (edge[2] == 1)) bevInd++;
          if (edge[2] == -1) {
            bevInd++;
            segInd--;
          }
        }
      } else {
        segInd -= getNumEdgeClosures();
      }
      return 6 * (segInd + bevInd);
    }
    
    void getVertexMin(PVector v)
    {
      for (int i = 0; i < vertexCount; i++) {
        int index = 4 * i;
        x = PApplet.min(x, vertices[(index++)]);
        y = PApplet.min(y, vertices[(index++)]);
        z = PApplet.min(z, vertices[index]);
      }
    }
    
    void getVertexMax(PVector v)
    {
      for (int i = 0; i < vertexCount; i++) {
        int index = 4 * i;
        x = PApplet.max(x, vertices[(index++)]);
        y = PApplet.max(y, vertices[(index++)]);
        z = PApplet.max(z, vertices[index]);
      }
    }
    
    int getVertexSum(PVector v)
    {
      for (int i = 0; i < vertexCount; i++) {
        int index = 4 * i;
        x += vertices[(index++)];
        y += vertices[(index++)];
        z += vertices[index];
      }
      return vertexCount;
    }
    
    double[] getAttribVector(int idx) {
      double[] vector = new double[attribs.numComp];
      int vidx = 0;
      for (int i = 0; i < attribs.size(); i++) {
        PGraphicsOpenGL.VertexAttribute attrib = attribs.get(i);
        String name = name;
        int aidx = size * idx;
        if (attrib.isColor()) {
          int[] iarray = (int[])iattribs.get(name);
          int col = iarray[aidx];
          vector[(vidx++)] = (col >> 24 & 0xFF);
          vector[(vidx++)] = (col >> 16 & 0xFF);
          vector[(vidx++)] = (col >> 8 & 0xFF);
          vector[(vidx++)] = (col >> 0 & 0xFF);
        }
        else if (attrib.isFloat()) {
          float[] farray = (float[])fattribs.get(name);
          for (int n = 0; n < size; n++) {
            vector[(vidx++)] = farray[(aidx++)];
          }
        } else if (attrib.isInt()) {
          int[] iarray = (int[])iattribs.get(name);
          for (int n = 0; n < size; n++) {
            vector[(vidx++)] = iarray[(aidx++)];
          }
        } else if (attrib.isBool()) {
          byte[] barray = (byte[])battribs.get(name);
          for (int n = 0; n < size; n++) {
            vector[(vidx++)] = barray[(aidx++)];
          }
        }
      }
      
      return vector;
    }
    



    void expandVertices(int n)
    {
      float[] temp = new float[3 * n];
      PApplet.arrayCopy(vertices, 0, temp, 0, 3 * vertexCount);
      vertices = temp;
    }
    
    void expandColors(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(colors, 0, temp, 0, vertexCount);
      colors = temp;
    }
    
    void expandNormals(int n) {
      float[] temp = new float[3 * n];
      PApplet.arrayCopy(normals, 0, temp, 0, 3 * vertexCount);
      normals = temp;
    }
    
    void expandTexCoords(int n) {
      float[] temp = new float[2 * n];
      PApplet.arrayCopy(texcoords, 0, temp, 0, 2 * vertexCount);
      texcoords = temp;
    }
    
    void expandStrokeColors(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(strokeColors, 0, temp, 0, vertexCount);
      strokeColors = temp;
    }
    
    void expandStrokeWeights(int n) {
      float[] temp = new float[n];
      PApplet.arrayCopy(strokeWeights, 0, temp, 0, vertexCount);
      strokeWeights = temp;
    }
    
    void expandAmbient(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(ambient, 0, temp, 0, vertexCount);
      ambient = temp;
    }
    
    void expandSpecular(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(specular, 0, temp, 0, vertexCount);
      specular = temp;
    }
    
    void expandEmissive(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(emissive, 0, temp, 0, vertexCount);
      emissive = temp;
    }
    
    void expandShininess(int n) {
      float[] temp = new float[n];
      PApplet.arrayCopy(shininess, 0, temp, 0, vertexCount);
      shininess = temp;
    }
    
    void expandAttribs(int n) {
      for (String name : attribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)attribs.get(name);
        if (type == PGL.FLOAT) {
          expandFloatAttrib(attrib, n);
        } else if (type == PGL.INT) {
          expandIntAttrib(attrib, n);
        } else if (type == PGL.BOOL) {
          expandBoolAttrib(attrib, n);
        }
      }
    }
    
    void expandFloatAttrib(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      float[] values = (float[])fattribs.get(name);
      float[] temp = new float[size * n];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      fattribs.put(name, temp);
    }
    
    void expandIntAttrib(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      int[] values = (int[])iattribs.get(name);
      int[] temp = new int[size * n];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      iattribs.put(name, temp);
    }
    
    void expandBoolAttrib(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      byte[] values = (byte[])battribs.get(name);
      byte[] temp = new byte[size * n];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      battribs.put(name, temp);
    }
    
    void expandCodes(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(codes, 0, temp, 0, codeCount);
      codes = temp;
    }
    
    void expandEdges(int n) {
      int[][] temp = new int[n][3];
      PApplet.arrayCopy(edges, 0, temp, 0, edgeCount);
      edges = temp;
    }
    



    void trim()
    {
      if ((vertexCount > 0) && (vertexCount < vertices.length / 3)) {
        trimVertices();
        trimColors();
        trimNormals();
        trimTexCoords();
        trimStrokeColors();
        trimStrokeWeights();
        trimAmbient();
        trimSpecular();
        trimEmissive();
        trimShininess();
        trimAttribs();
      }
      
      if ((codeCount > 0) && (codeCount < codes.length)) {
        trimCodes();
      }
      
      if ((edgeCount > 0) && (edgeCount < edges.length)) {
        trimEdges();
      }
    }
    
    void trimVertices() {
      float[] temp = new float[3 * vertexCount];
      PApplet.arrayCopy(vertices, 0, temp, 0, 3 * vertexCount);
      vertices = temp;
    }
    
    void trimColors() {
      int[] temp = new int[vertexCount];
      PApplet.arrayCopy(colors, 0, temp, 0, vertexCount);
      colors = temp;
    }
    
    void trimNormals() {
      float[] temp = new float[3 * vertexCount];
      PApplet.arrayCopy(normals, 0, temp, 0, 3 * vertexCount);
      normals = temp;
    }
    
    void trimTexCoords() {
      float[] temp = new float[2 * vertexCount];
      PApplet.arrayCopy(texcoords, 0, temp, 0, 2 * vertexCount);
      texcoords = temp;
    }
    
    void trimStrokeColors() {
      int[] temp = new int[vertexCount];
      PApplet.arrayCopy(strokeColors, 0, temp, 0, vertexCount);
      strokeColors = temp;
    }
    
    void trimStrokeWeights() {
      float[] temp = new float[vertexCount];
      PApplet.arrayCopy(strokeWeights, 0, temp, 0, vertexCount);
      strokeWeights = temp;
    }
    
    void trimAmbient() {
      int[] temp = new int[vertexCount];
      PApplet.arrayCopy(ambient, 0, temp, 0, vertexCount);
      ambient = temp;
    }
    
    void trimSpecular() {
      int[] temp = new int[vertexCount];
      PApplet.arrayCopy(specular, 0, temp, 0, vertexCount);
      specular = temp;
    }
    
    void trimEmissive() {
      int[] temp = new int[vertexCount];
      PApplet.arrayCopy(emissive, 0, temp, 0, vertexCount);
      emissive = temp;
    }
    
    void trimShininess() {
      float[] temp = new float[vertexCount];
      PApplet.arrayCopy(shininess, 0, temp, 0, vertexCount);
      shininess = temp;
    }
    
    void trimCodes() {
      int[] temp = new int[codeCount];
      PApplet.arrayCopy(codes, 0, temp, 0, codeCount);
      codes = temp;
    }
    
    void trimEdges() {
      int[][] temp = new int[edgeCount][3];
      PApplet.arrayCopy(edges, 0, temp, 0, edgeCount);
      edges = temp;
    }
    
    void trimAttribs() {
      for (String name : attribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)attribs.get(name);
        if (type == PGL.FLOAT) {
          trimFloatAttrib(attrib);
        } else if (type == PGL.INT) {
          trimIntAttrib(attrib);
        } else if (type == PGL.BOOL) {
          trimBoolAttrib(attrib);
        }
      }
    }
    
    void trimFloatAttrib(PGraphicsOpenGL.VertexAttribute attrib) {
      float[] values = (float[])fattribs.get(name);
      float[] temp = new float[size * vertexCount];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      fattribs.put(name, temp);
    }
    
    void trimIntAttrib(PGraphicsOpenGL.VertexAttribute attrib) {
      int[] values = (int[])iattribs.get(name);
      int[] temp = new int[size * vertexCount];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      iattribs.put(name, temp);
    }
    
    void trimBoolAttrib(PGraphicsOpenGL.VertexAttribute attrib) {
      byte[] values = (byte[])battribs.get(name);
      byte[] temp = new byte[size * vertexCount];
      PApplet.arrayCopy(values, 0, temp, 0, size * vertexCount);
      battribs.put(name, temp);
    }
    



    int addVertex(float x, float y, boolean brk)
    {
      return addVertex(x, y, 0.0F, 
        fillColor, 
        normalX, normalY, normalZ, 
        0.0F, 0.0F, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        0, brk);
    }
    
    int addVertex(float x, float y, int code, boolean brk)
    {
      return addVertex(x, y, 0.0F, 
        fillColor, 
        normalX, normalY, normalZ, 
        0.0F, 0.0F, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        code, brk);
    }
    

    int addVertex(float x, float y, float u, float v, boolean brk)
    {
      return addVertex(x, y, 0.0F, 
        fillColor, 
        normalX, normalY, normalZ, 
        u, v, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        0, brk);
    }
    

    int addVertex(float x, float y, float u, float v, int code, boolean brk)
    {
      return addVertex(x, y, 0.0F, 
        fillColor, 
        normalX, normalY, normalZ, 
        u, v, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        code, brk);
    }
    
    int addVertex(float x, float y, float z, boolean brk) {
      return addVertex(x, y, z, 
        fillColor, 
        normalX, normalY, normalZ, 
        0.0F, 0.0F, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        0, brk);
    }
    
    int addVertex(float x, float y, float z, int code, boolean brk) {
      return addVertex(x, y, z, 
        fillColor, 
        normalX, normalY, normalZ, 
        0.0F, 0.0F, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        code, brk);
    }
    

    int addVertex(float x, float y, float z, float u, float v, boolean brk)
    {
      return addVertex(x, y, z, 
        fillColor, 
        normalX, normalY, normalZ, 
        u, v, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        0, brk);
    }
    

    int addVertex(float x, float y, float z, float u, float v, int code, boolean brk)
    {
      return addVertex(x, y, z, 
        fillColor, 
        normalX, normalY, normalZ, 
        u, v, 
        strokeColor, strokeWeight, 
        ambientColor, specularColor, emissiveColor, shininessFactor, 
        code, brk);
    }
    





    int addVertex(float x, float y, float z, int fcolor, float nx, float ny, float nz, float u, float v, int scolor, float sweight, int am, int sp, int em, float shine, int code, boolean brk)
    {
      vertexCheck();
      

      int index = 3 * vertexCount;
      vertices[(index++)] = x;
      vertices[(index++)] = y;
      vertices[index] = z;
      
      colors[vertexCount] = PGL.javaToNativeARGB(fcolor);
      
      index = 3 * vertexCount;
      normals[(index++)] = nx;
      normals[(index++)] = ny;
      normals[index] = nz;
      
      index = 2 * vertexCount;
      texcoords[(index++)] = u;
      texcoords[index] = v;
      
      strokeColors[vertexCount] = PGL.javaToNativeARGB(scolor);
      strokeWeights[vertexCount] = sweight;
      
      ambient[vertexCount] = PGL.javaToNativeARGB(am);
      specular[vertexCount] = PGL.javaToNativeARGB(sp);
      emissive[vertexCount] = PGL.javaToNativeARGB(em);
      shininess[vertexCount] = shine;
      
      for (String name : attribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)attribs.get(name);
        index = size * vertexCount;
        if (type == PGL.FLOAT) {
          float[] values = (float[])fattribs.get(name);
          attrib.add(values, index);
        } else if (type == PGL.INT) {
          int[] values = (int[])iattribs.get(name);
          attrib.add(values, index);
        } else if (type == PGL.BOOL) {
          byte[] values = (byte[])battribs.get(name);
          attrib.add(values, index);
        }
      }
      
      if ((brk) || ((code == 0) && (codes != null)) || 
        (code == 1) || 
        (code == 2) || 
        (code == 3)) {
        if (codes == null) {
          codes = new int[PApplet.max(PGL.DEFAULT_IN_VERTICES, vertexCount)];
          Arrays.fill(codes, 0, vertexCount, 0);
          codeCount = vertexCount;
        }
        
        if (brk) {
          codeCheck();
          codes[codeCount] = 4;
          codeCount += 1;
        }
        
        if (code != -1) {
          codeCheck();
          codes[codeCount] = code;
          codeCount += 1;
        }
      }
      
      vertexCount += 1;
      
      return vertexCount - 1;
    }
    


    public void addBezierVertex(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, boolean brk)
    {
      addVertex(x2, y2, z2, 1, brk);
      addVertex(x3, y3, z3, -1, false);
      addVertex(x4, y4, z4, -1, false);
    }
    

    public void addQuadraticVertex(float cx, float cy, float cz, float x3, float y3, float z3, boolean brk)
    {
      addVertex(cx, cy, cz, 2, brk);
      addVertex(x3, y3, z3, -1, false);
    }
    
    public void addCurveVertex(float x, float y, float z, boolean brk) {
      addVertex(x, y, z, 3, brk);
    }
    
    float[][] getVertexData()
    {
      float[][] data = new float[vertexCount][37];
      for (int i = 0; i < vertexCount; i++) {
        float[] vert = data[i];
        
        vert[0] = vertices[(3 * i + 0)];
        vert[1] = vertices[(3 * i + 1)];
        vert[2] = vertices[(3 * i + 2)];
        
        vert[3] = ((colors[i] >> 16 & 0xFF) / 255.0F);
        vert[4] = ((colors[i] >> 8 & 0xFF) / 255.0F);
        vert[5] = ((colors[i] >> 0 & 0xFF) / 255.0F);
        vert[6] = ((colors[i] >> 24 & 0xFF) / 255.0F);
        
        vert[7] = texcoords[(2 * i + 0)];
        vert[8] = texcoords[(2 * i + 1)];
        
        vert[9] = normals[(3 * i + 0)];
        vert[10] = normals[(3 * i + 1)];
        vert[11] = normals[(3 * i + 2)];
        
        vert[13] = ((strokeColors[i] >> 16 & 0xFF) / 255.0F);
        vert[14] = ((strokeColors[i] >> 8 & 0xFF) / 255.0F);
        vert[15] = ((strokeColors[i] >> 0 & 0xFF) / 255.0F);
        vert[16] = ((strokeColors[i] >> 24 & 0xFF) / 255.0F);
        
        vert[17] = strokeWeights[i];
      }
      
      return data;
    }
    
    boolean hasBezierVertex() {
      for (int i = 0; i < codeCount; i++) {
        if (codes[i] == 1) return true;
      }
      return false;
    }
    
    boolean hasQuadraticVertex() {
      for (int i = 0; i < codeCount; i++) {
        if (codes[i] == 2) return true;
      }
      return false;
    }
    
    boolean hasCurveVertex() {
      for (int i = 0; i < codeCount; i++) {
        if (codes[i] == 3) return true;
      }
      return false;
    }
    



    int addEdge(int i, int j, boolean start, boolean end)
    {
      edgeCheck();
      
      int[] edge = edges[edgeCount];
      edge[0] = i;
      edge[1] = j;
      





      edge[2] = ((start ? 1 : 0) + 2 * (end ? 1 : 0));
      
      edgeCount += 1;
      
      return edgeCount - 1;
    }
    
    int closeEdge(int i, int j) {
      edgeCheck();
      
      int[] edge = edges[edgeCount];
      edge[0] = i;
      edge[1] = j;
      edge[2] = -1;
      
      edgeCount += 1;
      
      return edgeCount - 1;
    }
    
    void addTrianglesEdges() {
      for (int i = 0; i < vertexCount / 3; i++) {
        int i0 = 3 * i + 0;
        int i1 = 3 * i + 1;
        int i2 = 3 * i + 2;
        
        addEdge(i0, i1, true, false);
        addEdge(i1, i2, false, false);
        addEdge(i2, i0, false, false);
        closeEdge(i2, i0);
      }
    }
    
    void addTriangleFanEdges() {
      for (int i = 1; i < vertexCount - 1; i++) {
        int i0 = 0;
        int i1 = i;
        int i2 = i + 1;
        
        addEdge(i0, i1, true, false);
        addEdge(i1, i2, false, false);
        addEdge(i2, i0, false, false);
        closeEdge(i2, i0);
      }
    }
    
    void addTriangleStripEdges() {
      for (int i = 1; i < vertexCount - 1; i++) {
        int i0 = i;
        int i2;
        int i1; int i2; if (i % 2 == 0) {
          int i1 = i - 1;
          i2 = i + 1;
        } else {
          i1 = i + 1;
          i2 = i - 1;
        }
        
        addEdge(i0, i1, true, false);
        addEdge(i1, i2, false, false);
        addEdge(i2, i0, false, false);
        closeEdge(i2, i0);
      }
    }
    
    void addQuadsEdges() {
      for (int i = 0; i < vertexCount / 4; i++) {
        int i0 = 4 * i + 0;
        int i1 = 4 * i + 1;
        int i2 = 4 * i + 2;
        int i3 = 4 * i + 3;
        
        addEdge(i0, i1, true, false);
        addEdge(i1, i2, false, false);
        addEdge(i2, i3, false, false);
        addEdge(i3, i0, false, false);
        closeEdge(i3, i0);
      }
    }
    
    void addQuadStripEdges() {
      for (int qd = 1; qd < vertexCount / 2; qd++) {
        int i0 = 2 * (qd - 1);
        int i1 = 2 * (qd - 1) + 1;
        int i2 = 2 * qd + 1;
        int i3 = 2 * qd;
        
        addEdge(i0, i1, true, false);
        addEdge(i1, i2, false, false);
        addEdge(i2, i3, false, false);
        addEdge(i3, i0, false, true);
        closeEdge(i3, i0);
      }
    }
    






    void calcTriangleNormal(int i0, int i1, int i2)
    {
      int index = 3 * i0;
      float x0 = vertices[(index++)];
      float y0 = vertices[(index++)];
      float z0 = vertices[index];
      
      index = 3 * i1;
      float x1 = vertices[(index++)];
      float y1 = vertices[(index++)];
      float z1 = vertices[index];
      
      index = 3 * i2;
      float x2 = vertices[(index++)];
      float y2 = vertices[(index++)];
      float z2 = vertices[index];
      
      float v12x = x2 - x1;
      float v12y = y2 - y1;
      float v12z = z2 - z1;
      
      float v10x = x0 - x1;
      float v10y = y0 - y1;
      float v10z = z0 - z1;
      




      float nx = v12y * v10z - v10y * v12z;
      float ny = v12z * v10x - v10z * v12x;
      float nz = v12x * v10y - v10x * v12y;
      float d = PApplet.sqrt(nx * nx + ny * ny + nz * nz);
      nx /= d;
      ny /= d;
      nz /= d;
      
      index = 3 * i0;
      normals[(index++)] = nx;
      normals[(index++)] = ny;
      normals[index] = nz;
      
      index = 3 * i1;
      normals[(index++)] = nx;
      normals[(index++)] = ny;
      normals[index] = nz;
      
      index = 3 * i2;
      normals[(index++)] = nx;
      normals[(index++)] = ny;
      normals[index] = nz;
    }
    
    void calcTrianglesNormals() {
      for (int i = 0; i < vertexCount / 3; i++) {
        int i0 = 3 * i + 0;
        int i1 = 3 * i + 1;
        int i2 = 3 * i + 2;
        
        calcTriangleNormal(i0, i1, i2);
      }
    }
    
    void calcTriangleFanNormals() {
      for (int i = 1; i < vertexCount - 1; i++) {
        int i0 = 0;
        int i1 = i;
        int i2 = i + 1;
        
        calcTriangleNormal(i0, i1, i2);
      }
    }
    
    void calcTriangleStripNormals() {
      for (int i = 1; i < vertexCount - 1; i++) {
        int i1 = i;
        
        int i2;
        
        int i0;
        int i2;
        if (i % 2 == 1)
        {
          int i0 = i - 1;
          i2 = i + 1;
        }
        else {
          i0 = i + 1;
          i2 = i - 1;
        }
        calcTriangleNormal(i0, i1, i2);
      }
    }
    
    void calcQuadsNormals() {
      for (int i = 0; i < vertexCount / 4; i++) {
        int i0 = 4 * i + 0;
        int i1 = 4 * i + 1;
        int i2 = 4 * i + 2;
        int i3 = 4 * i + 3;
        
        calcTriangleNormal(i0, i1, i2);
        calcTriangleNormal(i2, i3, i0);
      }
    }
    
    void calcQuadStripNormals() {
      for (int qd = 1; qd < vertexCount / 2; qd++) {
        int i0 = 2 * (qd - 1);
        int i1 = 2 * (qd - 1) + 1;
        int i2 = 2 * qd;
        int i3 = 2 * qd + 1;
        






        calcTriangleNormal(i0, i1, i2);
        calcTriangleNormal(i2, i1, i3);
      }
    }
    





    void setMaterial(int fillColor, int strokeColor, float strokeWeight, int ambientColor, int specularColor, int emissiveColor, float shininessFactor)
    {
      this.fillColor = fillColor;
      this.strokeColor = strokeColor;
      this.strokeWeight = strokeWeight;
      this.ambientColor = ambientColor;
      this.specularColor = specularColor;
      this.emissiveColor = emissiveColor;
      this.shininessFactor = shininessFactor;
    }
    
    void setNormal(float normalX, float normalY, float normalZ) {
      this.normalX = normalX;
      this.normalY = normalY;
      this.normalZ = normalZ;
    }
    
    void addPoint(float x, float y, float z, boolean fill, boolean stroke) {
      addVertex(x, y, z, 0, true);
    }
    

    void addLine(float x1, float y1, float z1, float x2, float y2, float z2, boolean fill, boolean stroke)
    {
      int idx1 = addVertex(x1, y1, z1, 0, true);
      int idx2 = addVertex(x2, y2, z2, 0, false);
      if (stroke) { addEdge(idx1, idx2, true, true);
      }
    }
    

    void addTriangle(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, boolean fill, boolean stroke)
    {
      int idx1 = addVertex(x1, y1, z1, 0, true);
      int idx2 = addVertex(x2, y2, z2, 0, false);
      int idx3 = addVertex(x3, y3, z3, 0, false);
      if (stroke) {
        addEdge(idx1, idx2, true, false);
        addEdge(idx2, idx3, false, false);
        addEdge(idx3, idx1, false, false);
        closeEdge(idx3, idx1);
      }
    }
    



    void addQuad(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, boolean stroke)
    {
      int idx1 = addVertex(x1, y1, z1, 0.0F, 0.0F, 0, true);
      int idx2 = addVertex(x2, y2, z2, 1.0F, 0.0F, 0, false);
      int idx3 = addVertex(x3, y3, z3, 1.0F, 1.0F, 0, false);
      int idx4 = addVertex(x4, y4, z4, 0.0F, 1.0F, 0, false);
      if (stroke) {
        addEdge(idx1, idx2, true, false);
        addEdge(idx2, idx3, false, false);
        addEdge(idx3, idx4, false, false);
        addEdge(idx4, idx1, false, false);
        closeEdge(idx4, idx1);
      }
    }
    
    void addRect(float a, float b, float c, float d, boolean stroke)
    {
      addQuad(a, b, 0.0F, 
        c, b, 0.0F, 
        c, d, 0.0F, 
        a, d, 0.0F, 
        stroke);
    }
    

    void addRect(float a, float b, float c, float d, float tl, float tr, float br, float bl, boolean stroke)
    {
      if (PGraphicsOpenGL.nonZero(tr)) {
        addVertex(c - tr, b, 0, true);
        addQuadraticVertex(c, b, 0.0F, c, b + tr, 0.0F, false);
      } else {
        addVertex(c, b, 0, true);
      }
      if (PGraphicsOpenGL.nonZero(br)) {
        addVertex(c, d - br, 0, false);
        addQuadraticVertex(c, d, 0.0F, c - br, d, 0.0F, false);
      } else {
        addVertex(c, d, 0, false);
      }
      if (PGraphicsOpenGL.nonZero(bl)) {
        addVertex(a + bl, d, 0, false);
        addQuadraticVertex(a, d, 0.0F, a, d - bl, 0.0F, false);
      } else {
        addVertex(a, d, 0, false);
      }
      if (PGraphicsOpenGL.nonZero(tl)) {
        addVertex(a, b + tl, 0, false);
        addQuadraticVertex(a, b, 0.0F, a + tl, b, 0.0F, false);
      } else {
        addVertex(a, b, 0, false);
      }
    }
    
    void addEllipse(float x, float y, float w, float h, boolean fill, boolean stroke)
    {
      float radiusH = w / 2.0F;
      float radiusV = h / 2.0F;
      
      float centerX = x + radiusH;
      float centerY = y + radiusV;
      

      float sx1 = pg.screenX(x, y);
      float sy1 = pg.screenY(x, y);
      float sx2 = pg.screenX(x + w, y + h);
      float sy2 = pg.screenY(x + w, y + h);
      
      int accuracy = 
        PApplet.min(200, PApplet.max(20, 
        (int)(6.2831855F * PApplet.dist(sx1, sy1, sx2, sy2) / 
        10.0F)));
      float inc = 720.0F / accuracy;
      
      if (fill)
        addVertex(centerX, centerY, 0, true);
      int idx;
      int pidx;
      int idx0 = pidx = idx = 0;
      float val = 0.0F;
      for (int i = 0; i < accuracy; i++) {
        idx = addVertex(centerX + PGraphicsOpenGL.cosLUT[((int)val)] * radiusH, 
          centerY + PGraphicsOpenGL.sinLUT[((int)val)] * radiusV, 
          0, (i == 0) && (!fill));
        val = (val + inc) % 720.0F;
        
        if (i > 0) {
          if (stroke) addEdge(pidx, idx, i == 1, false);
        } else {
          idx0 = idx;
        }
        
        pidx = idx;
      }
      
      addVertex(centerX + PGraphicsOpenGL.cosLUT[0] * radiusH, 
        centerY + PGraphicsOpenGL.sinLUT[0] * radiusV, 
        0, false);
      if (stroke) {
        addEdge(idx, idx0, false, false);
        closeEdge(idx, idx0);
      }
    }
    


    void addArc(float x, float y, float w, float h, float start, float stop, boolean fill, boolean stroke, int arcMode)
    {
      float hr = w / 2.0F;
      float vr = h / 2.0F;
      
      float centerX = x + hr;
      float centerY = y + vr;
      
      int startLUT = (int)(0.5F + start / 6.2831855F * 720.0F);
      int stopLUT = (int)(0.5F + stop / 6.2831855F * 720.0F);
      

      int length = PApplet.constrain(stopLUT - startLUT, 0, 720);
      
      boolean fullCircle = length == 720;
      
      if ((fullCircle) && (arcMode == 2))
      {

        length--;
        stopLUT--;
      }
      

      startLUT %= 720;
      if (startLUT < 0) { startLUT += 720;
      }
      stopLUT %= 720;
      if (stopLUT < 0) { stopLUT += 720;
      }
      int idx0;
      int idx0;
      if ((arcMode == 2) || (arcMode == 1))
      {

        float relX = (PGraphicsOpenGL.cosLUT[startLUT] + PGraphicsOpenGL.cosLUT[stopLUT]) * 0.5F * hr;
        float relY = (PGraphicsOpenGL.sinLUT[startLUT] + PGraphicsOpenGL.sinLUT[stopLUT]) * 0.5F * vr;
        idx0 = addVertex(centerX + relX, centerY + relY, 0, true);
      } else {
        idx0 = addVertex(centerX, centerY, 0, true);
      }
      


      float sx1 = pg.screenX(x, y);
      float sy1 = pg.screenY(x, y);
      float sx2 = pg.screenX(x + w, y + h);
      float sy2 = pg.screenY(x + w, y + h);
      
      int accuracy = 
        PApplet.min(200, PApplet.max(20, 
        (int)(6.2831855F * PApplet.dist(sx1, sy1, sx2, sy2) / 
        10.0F)));
      int inc = PApplet.max(1, 720 / accuracy);
      

      int idx = idx0;
      

      int i = -inc;
      

      int pidx;
      
      do
      {
        i += inc;
        i = PApplet.min(i, length);
        
        int ii = startLUT + i;
        if (ii >= 720) { ii -= 720;
        }
        pidx = idx;
        idx = addVertex(centerX + PGraphicsOpenGL.cosLUT[ii] * hr, 
          centerY + PGraphicsOpenGL.sinLUT[ii] * vr, 
          0, (i == 0) && (!fill));
        
        if (stroke) {
          if ((arcMode == 2) || (arcMode == 3)) {
            addEdge(pidx, idx, i == 0, false);
          } else if (i > 0)
          {
            addEdge(pidx, idx, i == PApplet.min(inc, length), 
              (i == length) && (!fullCircle));
          }
        }
      } while (
      



















        i < length);
      


      if (stroke) {
        if ((arcMode == 2) || (arcMode == 3)) {
          addEdge(idx, idx0, false, false);
          closeEdge(idx, idx0);
        } else if (fullCircle) {
          closeEdge(pidx, idx);
        }
      }
    }
    




    void addBox(float w, float h, float d, boolean fill, boolean stroke)
    {
      boolean invertNormX = (h > 0.0F ? 1 : 0) ^ (d > 0.0F ? 1 : 0);
      boolean invertNormY = (w > 0.0F ? 1 : 0) ^ (d > 0.0F ? 1 : 0);
      boolean invertNormZ = (w > 0.0F ? 1 : 0) ^ (h > 0.0F ? 1 : 0);
      
      int normX = invertNormX ? -1 : 1;
      int normY = invertNormY ? -1 : 1;
      int normZ = invertNormZ ? -1 : 1;
      
      float x1 = -w / 2.0F;float x2 = w / 2.0F;
      float y1 = -h / 2.0F;float y2 = h / 2.0F;
      float z1 = -d / 2.0F;float z2 = d / 2.0F;
      
      int idx1 = 0;int idx2 = 0;int idx3 = 0;int idx4 = 0;
      if ((fill) || (stroke))
      {
        setNormal(0.0F, 0.0F, -normZ);
        idx1 = addVertex(x1, y1, z1, 0.0F, 0.0F, 0, true);
        idx2 = addVertex(x1, y2, z1, 0.0F, 1.0F, 0, false);
        idx3 = addVertex(x2, y2, z1, 1.0F, 1.0F, 0, false);
        idx4 = addVertex(x2, y1, z1, 1.0F, 0.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
        

        setNormal(0.0F, 0.0F, normZ);
        idx1 = addVertex(x1, y2, z2, 1.0F, 1.0F, 0, false);
        idx2 = addVertex(x1, y1, z2, 1.0F, 0.0F, 0, false);
        idx3 = addVertex(x2, y1, z2, 0.0F, 0.0F, 0, false);
        idx4 = addVertex(x2, y2, z2, 0.0F, 1.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
        

        setNormal(normX, 0.0F, 0.0F);
        idx1 = addVertex(x2, y1, z1, 0.0F, 0.0F, 0, false);
        idx2 = addVertex(x2, y2, z1, 0.0F, 1.0F, 0, false);
        idx3 = addVertex(x2, y2, z2, 1.0F, 1.0F, 0, false);
        idx4 = addVertex(x2, y1, z2, 1.0F, 0.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
        

        setNormal(-normX, 0.0F, 0.0F);
        idx1 = addVertex(x1, y2, z1, 1.0F, 1.0F, 0, false);
        idx2 = addVertex(x1, y1, z1, 1.0F, 0.0F, 0, false);
        idx3 = addVertex(x1, y1, z2, 0.0F, 0.0F, 0, false);
        idx4 = addVertex(x1, y2, z2, 0.0F, 1.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
        

        setNormal(0.0F, -normY, 0.0F);
        idx1 = addVertex(x2, y1, z1, 1.0F, 1.0F, 0, false);
        idx2 = addVertex(x2, y1, z2, 1.0F, 0.0F, 0, false);
        idx3 = addVertex(x1, y1, z2, 0.0F, 0.0F, 0, false);
        idx4 = addVertex(x1, y1, z1, 0.0F, 1.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
        

        setNormal(0.0F, normY, 0.0F);
        idx1 = addVertex(x1, y2, z1, 0.0F, 0.0F, 0, false);
        idx2 = addVertex(x1, y2, z2, 0.0F, 1.0F, 0, false);
        idx3 = addVertex(x2, y2, z2, 1.0F, 1.0F, 0, false);
        idx4 = addVertex(x2, y2, z1, 1.0F, 0.0F, 0, false);
        if (stroke) {
          addEdge(idx1, idx2, true, false);
          addEdge(idx2, idx3, false, false);
          addEdge(idx3, idx4, false, false);
          addEdge(idx4, idx1, false, false);
          closeEdge(idx4, idx1);
        }
      }
    }
    


    int[] addSphere(float r, int detailU, int detailV, boolean fill, boolean stroke)
    {
      int nind = 3 * detailU + (6 * detailU + 3) * (detailV - 2) + 3 * detailU;
      int[] indices = new int[nind];
      
      int vertCount = 0;
      int indCount = 0;
      


      float du = 1.0F / detailU;
      float dv = 1.0F / detailV;
      





      float u = 1.0F;float v = 1.0F;
      for (int i = 0; i < detailU; i++) {
        setNormal(0.0F, 1.0F, 0.0F);
        addVertex(0.0F, r, 0.0F, u, v, 0, true);
        u -= du;
      }
      vertCount = detailU;
      int vert0 = vertCount;
      u = 1.0F;v -= dv;
      for (int i = 0; i < detailU; i++) {
        setNormal(pg.sphereX[i], pg.sphereY[i], pg.sphereZ[i]);
        addVertex(r * pg.sphereX[i], r * pg.sphereY[i], r * pg.sphereZ[i], u, v, 
          0, false);
        u -= du;
      }
      vertCount += detailU;
      int vert1 = vertCount;
      setNormal(pg.sphereX[0], pg.sphereY[0], pg.sphereZ[0]);
      addVertex(r * pg.sphereX[0], r * pg.sphereY[0], r * pg.sphereZ[0], u, v, 
        0, false);
      vertCount++;
      
      for (int i = 0; i < detailU; i++) {
        int i1 = vert0 + i;
        int i0 = vert0 + i - detailU;
        
        indices[(3 * i + 0)] = i1;
        indices[(3 * i + 1)] = i0;
        indices[(3 * i + 2)] = (i1 + 1);
        
        addEdge(i0, i1, true, true);
        addEdge(i1, i1 + 1, true, true);
      }
      indCount += 3 * detailU;
      


      int offset = 0;
      for (int j = 2; j < detailV; j++) {
        offset += detailU;
        vert0 = vertCount;
        u = 1.0F;v -= dv;
        for (int i = 0; i < detailU; i++) {
          int ioff = offset + i;
          setNormal(pg.sphereX[ioff], pg.sphereY[ioff], pg.sphereZ[ioff]);
          addVertex(r * pg.sphereX[ioff], r * pg.sphereY[ioff], r * pg.sphereZ[ioff], 
            u, v, 0, false);
          u -= du;
        }
        vertCount += detailU;
        vert1 = vertCount;
        setNormal(pg.sphereX[offset], pg.sphereY[offset], pg.sphereZ[offset]);
        addVertex(r * pg.sphereX[offset], r * pg.sphereY[offset], r * pg.sphereZ[offset], 
          u, v, 0, false);
        vertCount++;
        
        for (int i = 0; i < detailU; i++) {
          int i1 = vert0 + i;
          int i0 = vert0 + i - detailU - 1;
          
          indices[(indCount + 6 * i + 0)] = i1;
          indices[(indCount + 6 * i + 1)] = i0;
          indices[(indCount + 6 * i + 2)] = (i0 + 1);
          
          indices[(indCount + 6 * i + 3)] = i1;
          indices[(indCount + 6 * i + 4)] = (i0 + 1);
          indices[(indCount + 6 * i + 5)] = (i1 + 1);
          
          addEdge(i0, i1, true, true);
          addEdge(i1, i1 + 1, true, true);
          addEdge(i0 + 1, i1, true, true);
        }
        indCount += 6 * detailU;
        indices[(indCount + 0)] = vert1;
        indices[(indCount + 1)] = (vert1 - detailU);
        indices[(indCount + 2)] = (vert1 - 1);
        indCount += 3;
      }
      





      u = 1.0F;v = 0.0F;
      for (int i = 0; i < detailU; i++) {
        setNormal(0.0F, -1.0F, 0.0F);
        addVertex(0.0F, -r, 0.0F, u, v, 0, false);
        u -= du;
      }
      vertCount += detailU;
      
      for (int i = 0; i < detailU; i++) {
        int i0 = vert0 + i;
        int i1 = vert0 + i + detailU + 1;
        
        indices[(indCount + 3 * i + 0)] = i1;
        indices[(indCount + 3 * i + 1)] = i0;
        indices[(indCount + 3 * i + 2)] = (i0 + 1);
        
        addEdge(i0, i0 + 1, true, true);
        addEdge(i0, i1, true, true);
      }
      indCount += 3 * detailU;
      
      return indices;
    }
  }
  

  protected static class TessGeometry
  {
    int renderMode;
    
    PGraphicsOpenGL pg;
    
    PGraphicsOpenGL.AttributeMap polyAttribs;
    
    int polyVertexCount;
    
    int firstPolyVertex;
    
    int lastPolyVertex;
    
    FloatBuffer polyVerticesBuffer;
    
    IntBuffer polyColorsBuffer;
    FloatBuffer polyNormalsBuffer;
    FloatBuffer polyTexCoordsBuffer;
    IntBuffer polyAmbientBuffer;
    IntBuffer polySpecularBuffer;
    IntBuffer polyEmissiveBuffer;
    FloatBuffer polyShininessBuffer;
    HashMap<String, Buffer> polyAttribBuffers = new HashMap();
    
    int polyIndexCount;
    int firstPolyIndex;
    int lastPolyIndex;
    ShortBuffer polyIndicesBuffer;
    PGraphicsOpenGL.IndexCache polyIndexCache = new PGraphicsOpenGL.IndexCache();
    
    int lineVertexCount;
    
    int firstLineVertex;
    
    int lastLineVertex;
    FloatBuffer lineVerticesBuffer;
    IntBuffer lineColorsBuffer;
    FloatBuffer lineDirectionsBuffer;
    int lineIndexCount;
    int firstLineIndex;
    int lastLineIndex;
    ShortBuffer lineIndicesBuffer;
    PGraphicsOpenGL.IndexCache lineIndexCache = new PGraphicsOpenGL.IndexCache();
    
    int pointVertexCount;
    
    int firstPointVertex;
    
    int lastPointVertex;
    FloatBuffer pointVerticesBuffer;
    IntBuffer pointColorsBuffer;
    FloatBuffer pointOffsetsBuffer;
    int pointIndexCount;
    int firstPointIndex;
    int lastPointIndex;
    ShortBuffer pointIndicesBuffer;
    PGraphicsOpenGL.IndexCache pointIndexCache = new PGraphicsOpenGL.IndexCache();
    
    float[] polyVertices;
    
    int[] polyColors;
    
    float[] polyNormals;
    float[] polyTexCoords;
    int[] polyAmbient;
    int[] polySpecular;
    int[] polyEmissive;
    float[] polyShininess;
    short[] polyIndices;
    float[] lineVertices;
    int[] lineColors;
    float[] lineDirections;
    short[] lineIndices;
    float[] pointVertices;
    int[] pointColors;
    float[] pointOffsets;
    short[] pointIndices;
    HashMap<String, float[]> fpolyAttribs = new HashMap();
    HashMap<String, int[]> ipolyAttribs = new HashMap();
    HashMap<String, byte[]> bpolyAttribs = new HashMap();
    
    TessGeometry(PGraphicsOpenGL pg, PGraphicsOpenGL.AttributeMap attr, int mode) {
      this.pg = pg;
      polyAttribs = attr;
      renderMode = mode;
      allocate();
    }
    



    void allocate()
    {
      polyVertices = new float[4 * PGL.DEFAULT_TESS_VERTICES];
      polyColors = new int[PGL.DEFAULT_TESS_VERTICES];
      polyNormals = new float[3 * PGL.DEFAULT_TESS_VERTICES];
      polyTexCoords = new float[2 * PGL.DEFAULT_TESS_VERTICES];
      polyAmbient = new int[PGL.DEFAULT_TESS_VERTICES];
      polySpecular = new int[PGL.DEFAULT_TESS_VERTICES];
      polyEmissive = new int[PGL.DEFAULT_TESS_VERTICES];
      polyShininess = new float[PGL.DEFAULT_TESS_VERTICES];
      polyIndices = new short[PGL.DEFAULT_TESS_VERTICES];
      
      lineVertices = new float[4 * PGL.DEFAULT_TESS_VERTICES];
      lineColors = new int[PGL.DEFAULT_TESS_VERTICES];
      lineDirections = new float[4 * PGL.DEFAULT_TESS_VERTICES];
      lineIndices = new short[PGL.DEFAULT_TESS_VERTICES];
      
      pointVertices = new float[4 * PGL.DEFAULT_TESS_VERTICES];
      pointColors = new int[PGL.DEFAULT_TESS_VERTICES];
      pointOffsets = new float[2 * PGL.DEFAULT_TESS_VERTICES];
      pointIndices = new short[PGL.DEFAULT_TESS_VERTICES];
      
      polyVerticesBuffer = PGL.allocateFloatBuffer(polyVertices);
      polyColorsBuffer = PGL.allocateIntBuffer(polyColors);
      polyNormalsBuffer = PGL.allocateFloatBuffer(polyNormals);
      polyTexCoordsBuffer = PGL.allocateFloatBuffer(polyTexCoords);
      polyAmbientBuffer = PGL.allocateIntBuffer(polyAmbient);
      polySpecularBuffer = PGL.allocateIntBuffer(polySpecular);
      polyEmissiveBuffer = PGL.allocateIntBuffer(polyEmissive);
      polyShininessBuffer = PGL.allocateFloatBuffer(polyShininess);
      polyIndicesBuffer = PGL.allocateShortBuffer(polyIndices);
      
      lineVerticesBuffer = PGL.allocateFloatBuffer(lineVertices);
      lineColorsBuffer = PGL.allocateIntBuffer(lineColors);
      lineDirectionsBuffer = PGL.allocateFloatBuffer(lineDirections);
      lineIndicesBuffer = PGL.allocateShortBuffer(lineIndices);
      
      pointVerticesBuffer = PGL.allocateFloatBuffer(pointVertices);
      pointColorsBuffer = PGL.allocateIntBuffer(pointColors);
      pointOffsetsBuffer = PGL.allocateFloatBuffer(pointOffsets);
      pointIndicesBuffer = PGL.allocateShortBuffer(pointIndices);
      
      clear();
    }
    
    void initAttrib(PGraphicsOpenGL.VertexAttribute attrib) {
      if ((type == PGL.FLOAT) && (!fpolyAttribs.containsKey(name))) {
        float[] temp = new float[tessSize * PGL.DEFAULT_TESS_VERTICES];
        fpolyAttribs.put(name, temp);
        polyAttribBuffers.put(name, PGL.allocateFloatBuffer(temp));
      } else if ((type == PGL.INT) && (!ipolyAttribs.containsKey(name))) {
        int[] temp = new int[tessSize * PGL.DEFAULT_TESS_VERTICES];
        ipolyAttribs.put(name, temp);
        polyAttribBuffers.put(name, PGL.allocateIntBuffer(temp));
      } else if ((type == PGL.BOOL) && (!bpolyAttribs.containsKey(name))) {
        byte[] temp = new byte[tessSize * PGL.DEFAULT_TESS_VERTICES];
        bpolyAttribs.put(name, temp);
        polyAttribBuffers.put(name, PGL.allocateByteBuffer(temp));
      }
    }
    
    void clear() {
      firstPolyVertex = (this.lastPolyVertex = this.polyVertexCount = 0);
      firstPolyIndex = (this.lastPolyIndex = this.polyIndexCount = 0);
      
      firstLineVertex = (this.lastLineVertex = this.lineVertexCount = 0);
      firstLineIndex = (this.lastLineIndex = this.lineIndexCount = 0);
      
      firstPointVertex = (this.lastPointVertex = this.pointVertexCount = 0);
      firstPointIndex = (this.lastPointIndex = this.pointIndexCount = 0);
      
      polyIndexCache.clear();
      lineIndexCache.clear();
      pointIndexCache.clear();
    }
    
    void polyVertexCheck() {
      if (polyVertexCount == polyVertices.length / 4) {
        int newSize = polyVertexCount << 1;
        
        expandPolyVertices(newSize);
        expandPolyColors(newSize);
        expandPolyNormals(newSize);
        expandPolyTexCoords(newSize);
        expandPolyAmbient(newSize);
        expandPolySpecular(newSize);
        expandPolyEmissive(newSize);
        expandPolyShininess(newSize);
        expandAttributes(newSize);
      }
      
      firstPolyVertex = polyVertexCount;
      polyVertexCount += 1;
      lastPolyVertex = (polyVertexCount - 1);
    }
    
    void polyVertexCheck(int count) {
      int oldSize = polyVertices.length / 4;
      if (polyVertexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, polyVertexCount + count);
        
        expandPolyVertices(newSize);
        expandPolyColors(newSize);
        expandPolyNormals(newSize);
        expandPolyTexCoords(newSize);
        expandPolyAmbient(newSize);
        expandPolySpecular(newSize);
        expandPolyEmissive(newSize);
        expandPolyShininess(newSize);
        expandAttributes(newSize);
      }
      
      firstPolyVertex = polyVertexCount;
      polyVertexCount += count;
      lastPolyVertex = (polyVertexCount - 1);
    }
    
    void polyIndexCheck(int count) {
      int oldSize = polyIndices.length;
      if (polyIndexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, polyIndexCount + count);
        
        expandPolyIndices(newSize);
      }
      
      firstPolyIndex = polyIndexCount;
      polyIndexCount += count;
      lastPolyIndex = (polyIndexCount - 1);
    }
    
    void polyIndexCheck() {
      if (polyIndexCount == polyIndices.length) {
        int newSize = polyIndexCount << 1;
        
        expandPolyIndices(newSize);
      }
      
      firstPolyIndex = polyIndexCount;
      polyIndexCount += 1;
      lastPolyIndex = (polyIndexCount - 1);
    }
    
    void lineVertexCheck(int count) {
      int oldSize = lineVertices.length / 4;
      if (lineVertexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, lineVertexCount + count);
        
        expandLineVertices(newSize);
        expandLineColors(newSize);
        expandLineDirections(newSize);
      }
      
      firstLineVertex = lineVertexCount;
      lineVertexCount += count;
      lastLineVertex = (lineVertexCount - 1);
    }
    
    void lineIndexCheck(int count) {
      int oldSize = lineIndices.length;
      if (lineIndexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, lineIndexCount + count);
        
        expandLineIndices(newSize);
      }
      
      firstLineIndex = lineIndexCount;
      lineIndexCount += count;
      lastLineIndex = (lineIndexCount - 1);
    }
    
    void pointVertexCheck(int count) {
      int oldSize = pointVertices.length / 4;
      if (pointVertexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, pointVertexCount + count);
        
        expandPointVertices(newSize);
        expandPointColors(newSize);
        expandPointOffsets(newSize);
      }
      
      firstPointVertex = pointVertexCount;
      pointVertexCount += count;
      lastPointVertex = (pointVertexCount - 1);
    }
    
    void pointIndexCheck(int count) {
      int oldSize = pointIndices.length;
      if (pointIndexCount + count > oldSize) {
        int newSize = PGraphicsOpenGL.expandArraySize(oldSize, pointIndexCount + count);
        
        expandPointIndices(newSize);
      }
      
      firstPointIndex = pointIndexCount;
      pointIndexCount += count;
      lastPointIndex = (pointIndexCount - 1);
    }
    



    boolean isFull()
    {
      return (PGL.FLUSH_VERTEX_COUNT <= polyVertexCount) || 
        (PGL.FLUSH_VERTEX_COUNT <= lineVertexCount) || (
        PGL.FLUSH_VERTEX_COUNT <= pointVertexCount);
    }
    
    void getPolyVertexMin(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.min(x, polyVertices[(index++)]);
        y = PApplet.min(y, polyVertices[(index++)]);
        z = PApplet.min(z, polyVertices[index]);
      }
    }
    
    void getLineVertexMin(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.min(x, lineVertices[(index++)]);
        y = PApplet.min(y, lineVertices[(index++)]);
        z = PApplet.min(z, lineVertices[index]);
      }
    }
    
    void getPointVertexMin(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.min(x, pointVertices[(index++)]);
        y = PApplet.min(y, pointVertices[(index++)]);
        z = PApplet.min(z, pointVertices[index]);
      }
    }
    
    void getPolyVertexMax(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.max(x, polyVertices[(index++)]);
        y = PApplet.max(y, polyVertices[(index++)]);
        z = PApplet.max(z, polyVertices[index]);
      }
    }
    
    void getLineVertexMax(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.max(x, lineVertices[(index++)]);
        y = PApplet.max(y, lineVertices[(index++)]);
        z = PApplet.max(z, lineVertices[index]);
      }
    }
    
    void getPointVertexMax(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x = PApplet.max(x, pointVertices[(index++)]);
        y = PApplet.max(y, pointVertices[(index++)]);
        z = PApplet.max(z, pointVertices[index]);
      }
    }
    
    int getPolyVertexSum(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x += polyVertices[(index++)];
        y += polyVertices[(index++)];
        z += polyVertices[index];
      }
      return last - first + 1;
    }
    
    int getLineVertexSum(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x += lineVertices[(index++)];
        y += lineVertices[(index++)];
        z += lineVertices[index];
      }
      return last - first + 1;
    }
    
    int getPointVertexSum(PVector v, int first, int last) {
      for (int i = first; i <= last; i++) {
        int index = 4 * i;
        x += pointVertices[(index++)];
        y += pointVertices[(index++)];
        z += pointVertices[index];
      }
      return last - first + 1;
    }
    



    protected void updatePolyVerticesBuffer()
    {
      updatePolyVerticesBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyVerticesBuffer(int offset, int size) {
      PGL.updateFloatBuffer(polyVerticesBuffer, polyVertices, 
        4 * offset, 4 * size);
    }
    
    protected void updatePolyColorsBuffer() {
      updatePolyColorsBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyColorsBuffer(int offset, int size) {
      PGL.updateIntBuffer(polyColorsBuffer, polyColors, offset, size);
    }
    
    protected void updatePolyNormalsBuffer() {
      updatePolyNormalsBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyNormalsBuffer(int offset, int size) {
      PGL.updateFloatBuffer(polyNormalsBuffer, polyNormals, 
        3 * offset, 3 * size);
    }
    
    protected void updatePolyTexCoordsBuffer() {
      updatePolyTexCoordsBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyTexCoordsBuffer(int offset, int size) {
      PGL.updateFloatBuffer(polyTexCoordsBuffer, polyTexCoords, 
        2 * offset, 2 * size);
    }
    
    protected void updatePolyAmbientBuffer() {
      updatePolyAmbientBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyAmbientBuffer(int offset, int size) {
      PGL.updateIntBuffer(polyAmbientBuffer, polyAmbient, offset, size);
    }
    
    protected void updatePolySpecularBuffer() {
      updatePolySpecularBuffer(0, polyVertexCount);
    }
    
    protected void updatePolySpecularBuffer(int offset, int size) {
      PGL.updateIntBuffer(polySpecularBuffer, polySpecular, offset, size);
    }
    
    protected void updatePolyEmissiveBuffer() {
      updatePolyEmissiveBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyEmissiveBuffer(int offset, int size) {
      PGL.updateIntBuffer(polyEmissiveBuffer, polyEmissive, offset, size);
    }
    
    protected void updatePolyShininessBuffer() {
      updatePolyShininessBuffer(0, polyVertexCount);
    }
    
    protected void updatePolyShininessBuffer(int offset, int size) {
      PGL.updateFloatBuffer(polyShininessBuffer, polyShininess, offset, size);
    }
    
    protected void updateAttribBuffer(String name) {
      updateAttribBuffer(name, 0, polyVertexCount);
    }
    
    protected void updateAttribBuffer(String name, int offset, int size) {
      PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
      if (type == PGL.FLOAT) {
        FloatBuffer buffer = (FloatBuffer)polyAttribBuffers.get(name);
        float[] array = (float[])fpolyAttribs.get(name);
        PGL.updateFloatBuffer(buffer, array, 
          tessSize * offset, tessSize * size);
      } else if (type == PGL.INT) {
        IntBuffer buffer = (IntBuffer)polyAttribBuffers.get(name);
        int[] array = (int[])ipolyAttribs.get(name);
        PGL.updateIntBuffer(buffer, array, 
          tessSize * offset, tessSize * size);
      } else if (type == PGL.BOOL) {
        ByteBuffer buffer = (ByteBuffer)polyAttribBuffers.get(name);
        byte[] array = (byte[])bpolyAttribs.get(name);
        PGL.updateByteBuffer(buffer, array, 
          tessSize * offset, tessSize * size);
      }
    }
    
    protected void updatePolyIndicesBuffer() {
      updatePolyIndicesBuffer(0, polyIndexCount);
    }
    
    protected void updatePolyIndicesBuffer(int offset, int size) {
      PGL.updateShortBuffer(polyIndicesBuffer, polyIndices, offset, size);
    }
    
    protected void updateLineVerticesBuffer() {
      updateLineVerticesBuffer(0, lineVertexCount);
    }
    
    protected void updateLineVerticesBuffer(int offset, int size) {
      PGL.updateFloatBuffer(lineVerticesBuffer, lineVertices, 
        4 * offset, 4 * size);
    }
    
    protected void updateLineColorsBuffer() {
      updateLineColorsBuffer(0, lineVertexCount);
    }
    
    protected void updateLineColorsBuffer(int offset, int size) {
      PGL.updateIntBuffer(lineColorsBuffer, lineColors, offset, size);
    }
    
    protected void updateLineDirectionsBuffer() {
      updateLineDirectionsBuffer(0, lineVertexCount);
    }
    
    protected void updateLineDirectionsBuffer(int offset, int size) {
      PGL.updateFloatBuffer(lineDirectionsBuffer, lineDirections, 
        4 * offset, 4 * size);
    }
    
    protected void updateLineIndicesBuffer() {
      updateLineIndicesBuffer(0, lineIndexCount);
    }
    
    protected void updateLineIndicesBuffer(int offset, int size) {
      PGL.updateShortBuffer(lineIndicesBuffer, lineIndices, offset, size);
    }
    
    protected void updatePointVerticesBuffer() {
      updatePointVerticesBuffer(0, pointVertexCount);
    }
    
    protected void updatePointVerticesBuffer(int offset, int size) {
      PGL.updateFloatBuffer(pointVerticesBuffer, pointVertices, 
        4 * offset, 4 * size);
    }
    
    protected void updatePointColorsBuffer() {
      updatePointColorsBuffer(0, pointVertexCount);
    }
    
    protected void updatePointColorsBuffer(int offset, int size) {
      PGL.updateIntBuffer(pointColorsBuffer, pointColors, offset, size);
    }
    
    protected void updatePointOffsetsBuffer() {
      updatePointOffsetsBuffer(0, pointVertexCount);
    }
    
    protected void updatePointOffsetsBuffer(int offset, int size) {
      PGL.updateFloatBuffer(pointOffsetsBuffer, pointOffsets, 
        2 * offset, 2 * size);
    }
    
    protected void updatePointIndicesBuffer() {
      updatePointIndicesBuffer(0, pointIndexCount);
    }
    
    protected void updatePointIndicesBuffer(int offset, int size) {
      PGL.updateShortBuffer(pointIndicesBuffer, pointIndices, offset, size);
    }
    



    void expandPolyVertices(int n)
    {
      float[] temp = new float[4 * n];
      PApplet.arrayCopy(polyVertices, 0, temp, 0, 4 * polyVertexCount);
      polyVertices = temp;
      polyVerticesBuffer = PGL.allocateFloatBuffer(polyVertices);
    }
    
    void expandPolyColors(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(polyColors, 0, temp, 0, polyVertexCount);
      polyColors = temp;
      polyColorsBuffer = PGL.allocateIntBuffer(polyColors);
    }
    
    void expandPolyNormals(int n) {
      float[] temp = new float[3 * n];
      PApplet.arrayCopy(polyNormals, 0, temp, 0, 3 * polyVertexCount);
      polyNormals = temp;
      polyNormalsBuffer = PGL.allocateFloatBuffer(polyNormals);
    }
    
    void expandPolyTexCoords(int n) {
      float[] temp = new float[2 * n];
      PApplet.arrayCopy(polyTexCoords, 0, temp, 0, 2 * polyVertexCount);
      polyTexCoords = temp;
      polyTexCoordsBuffer = PGL.allocateFloatBuffer(polyTexCoords);
    }
    
    void expandPolyAmbient(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(polyAmbient, 0, temp, 0, polyVertexCount);
      polyAmbient = temp;
      polyAmbientBuffer = PGL.allocateIntBuffer(polyAmbient);
    }
    
    void expandPolySpecular(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(polySpecular, 0, temp, 0, polyVertexCount);
      polySpecular = temp;
      polySpecularBuffer = PGL.allocateIntBuffer(polySpecular);
    }
    
    void expandPolyEmissive(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(polyEmissive, 0, temp, 0, polyVertexCount);
      polyEmissive = temp;
      polyEmissiveBuffer = PGL.allocateIntBuffer(polyEmissive);
    }
    
    void expandPolyShininess(int n) {
      float[] temp = new float[n];
      PApplet.arrayCopy(polyShininess, 0, temp, 0, polyVertexCount);
      polyShininess = temp;
      polyShininessBuffer = PGL.allocateFloatBuffer(polyShininess);
    }
    
    void expandAttributes(int n) {
      for (String name : polyAttribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
        if (type == PGL.FLOAT) {
          expandFloatAttribute(attrib, n);
        } else if (type == PGL.INT) {
          expandIntAttribute(attrib, n);
        } else if (type == PGL.BOOL) {
          expandBoolAttribute(attrib, n);
        }
      }
    }
    
    void expandFloatAttribute(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      float[] array = (float[])fpolyAttribs.get(name);
      float[] temp = new float[tessSize * n];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      fpolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateFloatBuffer(temp));
    }
    
    void expandIntAttribute(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      int[] array = (int[])ipolyAttribs.get(name);
      int[] temp = new int[tessSize * n];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      ipolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateIntBuffer(temp));
    }
    
    void expandBoolAttribute(PGraphicsOpenGL.VertexAttribute attrib, int n) {
      byte[] array = (byte[])bpolyAttribs.get(name);
      byte[] temp = new byte[tessSize * n];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      bpolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateByteBuffer(temp));
    }
    
    void expandPolyIndices(int n) {
      short[] temp = new short[n];
      PApplet.arrayCopy(polyIndices, 0, temp, 0, polyIndexCount);
      polyIndices = temp;
      polyIndicesBuffer = PGL.allocateShortBuffer(polyIndices);
    }
    
    void expandLineVertices(int n) {
      float[] temp = new float[4 * n];
      PApplet.arrayCopy(lineVertices, 0, temp, 0, 4 * lineVertexCount);
      lineVertices = temp;
      lineVerticesBuffer = PGL.allocateFloatBuffer(lineVertices);
    }
    
    void expandLineColors(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(lineColors, 0, temp, 0, lineVertexCount);
      lineColors = temp;
      lineColorsBuffer = PGL.allocateIntBuffer(lineColors);
    }
    
    void expandLineDirections(int n) {
      float[] temp = new float[4 * n];
      PApplet.arrayCopy(lineDirections, 0, temp, 0, 4 * lineVertexCount);
      lineDirections = temp;
      lineDirectionsBuffer = PGL.allocateFloatBuffer(lineDirections);
    }
    
    void expandLineIndices(int n) {
      short[] temp = new short[n];
      PApplet.arrayCopy(lineIndices, 0, temp, 0, lineIndexCount);
      lineIndices = temp;
      lineIndicesBuffer = PGL.allocateShortBuffer(lineIndices);
    }
    
    void expandPointVertices(int n) {
      float[] temp = new float[4 * n];
      PApplet.arrayCopy(pointVertices, 0, temp, 0, 4 * pointVertexCount);
      pointVertices = temp;
      pointVerticesBuffer = PGL.allocateFloatBuffer(pointVertices);
    }
    
    void expandPointColors(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(pointColors, 0, temp, 0, pointVertexCount);
      pointColors = temp;
      pointColorsBuffer = PGL.allocateIntBuffer(pointColors);
    }
    
    void expandPointOffsets(int n) {
      float[] temp = new float[2 * n];
      PApplet.arrayCopy(pointOffsets, 0, temp, 0, 2 * pointVertexCount);
      pointOffsets = temp;
      pointOffsetsBuffer = PGL.allocateFloatBuffer(pointOffsets);
    }
    
    void expandPointIndices(int n) {
      short[] temp = new short[n];
      PApplet.arrayCopy(pointIndices, 0, temp, 0, pointIndexCount);
      pointIndices = temp;
      pointIndicesBuffer = PGL.allocateShortBuffer(pointIndices);
    }
    



    void trim()
    {
      if ((polyVertexCount > 0) && (polyVertexCount < polyVertices.length / 4)) {
        trimPolyVertices();
        trimPolyColors();
        trimPolyNormals();
        trimPolyTexCoords();
        trimPolyAmbient();
        trimPolySpecular();
        trimPolyEmissive();
        trimPolyShininess();
        trimPolyAttributes();
      }
      
      if ((polyIndexCount > 0) && (polyIndexCount < polyIndices.length)) {
        trimPolyIndices();
      }
      
      if ((lineVertexCount > 0) && (lineVertexCount < lineVertices.length / 4)) {
        trimLineVertices();
        trimLineColors();
        trimLineDirections();
      }
      
      if ((lineIndexCount > 0) && (lineIndexCount < lineIndices.length)) {
        trimLineIndices();
      }
      
      if ((pointVertexCount > 0) && (pointVertexCount < pointVertices.length / 4)) {
        trimPointVertices();
        trimPointColors();
        trimPointOffsets();
      }
      
      if ((pointIndexCount > 0) && (pointIndexCount < pointIndices.length)) {
        trimPointIndices();
      }
    }
    
    void trimPolyVertices() {
      float[] temp = new float[4 * polyVertexCount];
      PApplet.arrayCopy(polyVertices, 0, temp, 0, 4 * polyVertexCount);
      polyVertices = temp;
      polyVerticesBuffer = PGL.allocateFloatBuffer(polyVertices);
    }
    
    void trimPolyColors() {
      int[] temp = new int[polyVertexCount];
      PApplet.arrayCopy(polyColors, 0, temp, 0, polyVertexCount);
      polyColors = temp;
      polyColorsBuffer = PGL.allocateIntBuffer(polyColors);
    }
    
    void trimPolyNormals() {
      float[] temp = new float[3 * polyVertexCount];
      PApplet.arrayCopy(polyNormals, 0, temp, 0, 3 * polyVertexCount);
      polyNormals = temp;
      polyNormalsBuffer = PGL.allocateFloatBuffer(polyNormals);
    }
    
    void trimPolyTexCoords() {
      float[] temp = new float[2 * polyVertexCount];
      PApplet.arrayCopy(polyTexCoords, 0, temp, 0, 2 * polyVertexCount);
      polyTexCoords = temp;
      polyTexCoordsBuffer = PGL.allocateFloatBuffer(polyTexCoords);
    }
    
    void trimPolyAmbient() {
      int[] temp = new int[polyVertexCount];
      PApplet.arrayCopy(polyAmbient, 0, temp, 0, polyVertexCount);
      polyAmbient = temp;
      polyAmbientBuffer = PGL.allocateIntBuffer(polyAmbient);
    }
    
    void trimPolySpecular() {
      int[] temp = new int[polyVertexCount];
      PApplet.arrayCopy(polySpecular, 0, temp, 0, polyVertexCount);
      polySpecular = temp;
      polySpecularBuffer = PGL.allocateIntBuffer(polySpecular);
    }
    
    void trimPolyEmissive() {
      int[] temp = new int[polyVertexCount];
      PApplet.arrayCopy(polyEmissive, 0, temp, 0, polyVertexCount);
      polyEmissive = temp;
      polyEmissiveBuffer = PGL.allocateIntBuffer(polyEmissive);
    }
    
    void trimPolyShininess() {
      float[] temp = new float[polyVertexCount];
      PApplet.arrayCopy(polyShininess, 0, temp, 0, polyVertexCount);
      polyShininess = temp;
      polyShininessBuffer = PGL.allocateFloatBuffer(polyShininess);
    }
    
    void trimPolyAttributes() {
      for (String name : polyAttribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
        if (type == PGL.FLOAT) {
          trimFloatAttribute(attrib);
        } else if (type == PGL.INT) {
          trimIntAttribute(attrib);
        } else if (type == PGL.BOOL) {
          trimBoolAttribute(attrib);
        }
      }
    }
    
    void trimFloatAttribute(PGraphicsOpenGL.VertexAttribute attrib) {
      float[] array = (float[])fpolyAttribs.get(name);
      float[] temp = new float[tessSize * polyVertexCount];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      fpolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateFloatBuffer(temp));
    }
    
    void trimIntAttribute(PGraphicsOpenGL.VertexAttribute attrib) {
      int[] array = (int[])ipolyAttribs.get(name);
      int[] temp = new int[tessSize * polyVertexCount];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      ipolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateIntBuffer(temp));
    }
    
    void trimBoolAttribute(PGraphicsOpenGL.VertexAttribute attrib) {
      byte[] array = (byte[])bpolyAttribs.get(name);
      byte[] temp = new byte[tessSize * polyVertexCount];
      PApplet.arrayCopy(array, 0, temp, 0, tessSize * polyVertexCount);
      bpolyAttribs.put(name, temp);
      polyAttribBuffers.put(name, PGL.allocateByteBuffer(temp));
    }
    
    void trimPolyIndices() {
      short[] temp = new short[polyIndexCount];
      PApplet.arrayCopy(polyIndices, 0, temp, 0, polyIndexCount);
      polyIndices = temp;
      polyIndicesBuffer = PGL.allocateShortBuffer(polyIndices);
    }
    
    void trimLineVertices() {
      float[] temp = new float[4 * lineVertexCount];
      PApplet.arrayCopy(lineVertices, 0, temp, 0, 4 * lineVertexCount);
      lineVertices = temp;
      lineVerticesBuffer = PGL.allocateFloatBuffer(lineVertices);
    }
    
    void trimLineColors() {
      int[] temp = new int[lineVertexCount];
      PApplet.arrayCopy(lineColors, 0, temp, 0, lineVertexCount);
      lineColors = temp;
      lineColorsBuffer = PGL.allocateIntBuffer(lineColors);
    }
    
    void trimLineDirections() {
      float[] temp = new float[4 * lineVertexCount];
      PApplet.arrayCopy(lineDirections, 0, temp, 0, 4 * lineVertexCount);
      lineDirections = temp;
      lineDirectionsBuffer = PGL.allocateFloatBuffer(lineDirections);
    }
    
    void trimLineIndices() {
      short[] temp = new short[lineIndexCount];
      PApplet.arrayCopy(lineIndices, 0, temp, 0, lineIndexCount);
      lineIndices = temp;
      lineIndicesBuffer = PGL.allocateShortBuffer(lineIndices);
    }
    
    void trimPointVertices() {
      float[] temp = new float[4 * pointVertexCount];
      PApplet.arrayCopy(pointVertices, 0, temp, 0, 4 * pointVertexCount);
      pointVertices = temp;
      pointVerticesBuffer = PGL.allocateFloatBuffer(pointVertices);
    }
    
    void trimPointColors() {
      int[] temp = new int[pointVertexCount];
      PApplet.arrayCopy(pointColors, 0, temp, 0, pointVertexCount);
      pointColors = temp;
      pointColorsBuffer = PGL.allocateIntBuffer(pointColors);
    }
    
    void trimPointOffsets() {
      float[] temp = new float[2 * pointVertexCount];
      PApplet.arrayCopy(pointOffsets, 0, temp, 0, 2 * pointVertexCount);
      pointOffsets = temp;
      pointOffsetsBuffer = PGL.allocateFloatBuffer(pointOffsets);
    }
    
    void trimPointIndices() {
      short[] temp = new short[pointIndexCount];
      PApplet.arrayCopy(pointIndices, 0, temp, 0, pointIndexCount);
      pointIndices = temp;
      pointIndicesBuffer = PGL.allocateShortBuffer(pointIndices);
    }
    



    void incPolyIndices(int first, int last, int inc)
    {
      for (int i = first; i <= last; i++) {
        int tmp12_10 = i; short[] tmp12_7 = polyIndices;tmp12_7[tmp12_10] = ((short)(tmp12_7[tmp12_10] + inc));
      }
    }
    
    void incLineIndices(int first, int last, int inc) {
      for (int i = first; i <= last; i++) {
        int tmp12_10 = i; short[] tmp12_7 = lineIndices;tmp12_7[tmp12_10] = ((short)(tmp12_7[tmp12_10] + inc));
      }
    }
    
    void incPointIndices(int first, int last, int inc) {
      for (int i = first; i <= last; i++) {
        int tmp12_10 = i; short[] tmp12_7 = pointIndices;tmp12_7[tmp12_10] = ((short)(tmp12_7[tmp12_10] + inc));
      }
    }
    






    void calcPolyNormal(int i0, int i1, int i2)
    {
      int index = 4 * i0;
      float x0 = polyVertices[(index++)];
      float y0 = polyVertices[(index++)];
      float z0 = polyVertices[index];
      
      index = 4 * i1;
      float x1 = polyVertices[(index++)];
      float y1 = polyVertices[(index++)];
      float z1 = polyVertices[index];
      
      index = 4 * i2;
      float x2 = polyVertices[(index++)];
      float y2 = polyVertices[(index++)];
      float z2 = polyVertices[index];
      
      float v12x = x2 - x1;
      float v12y = y2 - y1;
      float v12z = z2 - z1;
      
      float v10x = x0 - x1;
      float v10y = y0 - y1;
      float v10z = z0 - z1;
      
      float nx = v12y * v10z - v10y * v12z;
      float ny = v12z * v10x - v10z * v12x;
      float nz = v12x * v10y - v10x * v12y;
      float d = PApplet.sqrt(nx * nx + ny * ny + nz * nz);
      nx /= d;
      ny /= d;
      nz /= d;
      
      index = 3 * i0;
      polyNormals[(index++)] = nx;
      polyNormals[(index++)] = ny;
      polyNormals[index] = nz;
      
      index = 3 * i1;
      polyNormals[(index++)] = nx;
      polyNormals[(index++)] = ny;
      polyNormals[index] = nz;
      
      index = 3 * i2;
      polyNormals[(index++)] = nx;
      polyNormals[(index++)] = ny;
      polyNormals[index] = nz;
    }
    







    void setPointVertex(int tessIdx, PGraphicsOpenGL.InGeometry in, int inIdx)
    {
      int index = 3 * inIdx;
      float x = vertices[(index++)];
      float y = vertices[(index++)];
      float z = vertices[index];
      
      if ((renderMode == 0) && (pg.flushMode == 1)) {
        PMatrix3D mm = pg.modelview;
        
        index = 4 * tessIdx;
        pointVertices[(index++)] = (x * m00 + y * m01 + z * m02 + m03);
        pointVertices[(index++)] = (x * m10 + y * m11 + z * m12 + m13);
        pointVertices[(index++)] = (x * m20 + y * m21 + z * m22 + m23);
        pointVertices[index] = (x * m30 + y * m31 + z * m32 + m33);
      } else {
        index = 4 * tessIdx;
        pointVertices[(index++)] = x;
        pointVertices[(index++)] = y;
        pointVertices[(index++)] = z;
        pointVertices[index] = 1.0F;
      }
      
      pointColors[tessIdx] = strokeColors[inIdx];
    }
    





    void setLineVertex(int tessIdx, float[] vertices, int inIdx0, int rgba)
    {
      int index = 3 * inIdx0;
      float x0 = vertices[(index++)];
      float y0 = vertices[(index++)];
      float z0 = vertices[index];
      
      if ((renderMode == 0) && (pg.flushMode == 1)) {
        PMatrix3D mm = pg.modelview;
        
        index = 4 * tessIdx;
        lineVertices[(index++)] = (x0 * m00 + y0 * m01 + z0 * m02 + m03);
        lineVertices[(index++)] = (x0 * m10 + y0 * m11 + z0 * m12 + m13);
        lineVertices[(index++)] = (x0 * m20 + y0 * m21 + z0 * m22 + m23);
        lineVertices[index] = (x0 * m30 + y0 * m31 + z0 * m32 + m33);
      } else {
        index = 4 * tessIdx;
        lineVertices[(index++)] = x0;
        lineVertices[(index++)] = y0;
        lineVertices[(index++)] = z0;
        lineVertices[index] = 1.0F;
      }
      
      lineColors[tessIdx] = rgba;
      index = 4 * tessIdx;
      lineDirections[(index++)] = 0.0F;
      lineDirections[(index++)] = 0.0F;
      lineDirections[(index++)] = 0.0F;
      lineDirections[index] = 0.0F;
    }
    




    void setLineVertex(int tessIdx, float[] vertices, int inIdx0, int inIdx1, int rgba, float weight)
    {
      int index = 3 * inIdx0;
      float x0 = vertices[(index++)];
      float y0 = vertices[(index++)];
      float z0 = vertices[index];
      
      index = 3 * inIdx1;
      float x1 = vertices[(index++)];
      float y1 = vertices[(index++)];
      float z1 = vertices[index];
      
      float dx = x1 - x0;
      float dy = y1 - y0;
      float dz = z1 - z0;
      
      if ((renderMode == 0) && (pg.flushMode == 1)) {
        PMatrix3D mm = pg.modelview;
        
        index = 4 * tessIdx;
        lineVertices[(index++)] = (x0 * m00 + y0 * m01 + z0 * m02 + m03);
        lineVertices[(index++)] = (x0 * m10 + y0 * m11 + z0 * m12 + m13);
        lineVertices[(index++)] = (x0 * m20 + y0 * m21 + z0 * m22 + m23);
        lineVertices[index] = (x0 * m30 + y0 * m31 + z0 * m32 + m33);
        
        index = 4 * tessIdx;
        lineDirections[(index++)] = (dx * m00 + dy * m01 + dz * m02);
        lineDirections[(index++)] = (dx * m10 + dy * m11 + dz * m12);
        lineDirections[index] = (dx * m20 + dy * m21 + dz * m22);
      } else {
        index = 4 * tessIdx;
        lineVertices[(index++)] = x0;
        lineVertices[(index++)] = y0;
        lineVertices[(index++)] = z0;
        lineVertices[index] = 1.0F;
        
        index = 4 * tessIdx;
        lineDirections[(index++)] = dx;
        lineDirections[(index++)] = dy;
        lineDirections[index] = dz;
      }
      
      lineColors[tessIdx] = rgba;
      lineDirections[(4 * tessIdx + 3)] = weight;
    }
    



    void addPolyVertex(double[] d, boolean clampXY)
    {
      int fcolor = 
        (int)d[3] << 24 | (int)d[4] << 16 | (int)d[5] << 8 | (int)d[6];
      int acolor = 
        (int)d[12] << 24 | (int)d[13] << 16 | (int)d[14] << 8 | (int)d[15];
      int scolor = 
        (int)d[16] << 24 | (int)d[17] << 16 | (int)d[18] << 8 | (int)d[19];
      int ecolor = 
        (int)d[20] << 24 | (int)d[21] << 16 | (int)d[22] << 8 | (int)d[23];
      
      addPolyVertex((float)d[0], (float)d[1], (float)d[2], 
        fcolor, 
        (float)d[7], (float)d[8], (float)d[9], 
        (float)d[10], (float)d[11], 
        acolor, scolor, ecolor, 
        (float)d[24], 
        clampXY);
      
      if (25 < d.length)
      {
        PMatrix3D mm = pg.modelview;
        PMatrix3D nm = pg.modelviewInv;
        int tessIdx = polyVertexCount - 1;
        
        int pos = 25;
        for (int i = 0; i < polyAttribs.size(); i++) {
          PGraphicsOpenGL.VertexAttribute attrib = polyAttribs.get(i);
          String name = name;
          int index = tessSize * tessIdx;
          if (attrib.isColor())
          {
            int color = 
              (int)d[(pos + 0)] << 24 | (int)d[(pos + 1)] << 16 | (int)d[(pos + 2)] << 8 | (int)d[(pos + 3)];
            int[] tessValues = (int[])ipolyAttribs.get(name);
            tessValues[index] = color;
            pos += 4;
          } else if (attrib.isPosition()) {
            float[] farray = (float[])fpolyAttribs.get(name);
            float x = (float)d[(pos++)];
            float y = (float)d[(pos++)];
            float z = (float)d[(pos++)];
            if ((renderMode == 0) && (pg.flushMode == 1)) {
              if (clampXY)
              {
                farray[(index++)] = 
                  PApplet.ceil(x * m00 + y * m01 + z * m02 + m03);
                farray[(index++)] = 
                  PApplet.ceil(x * m10 + y * m11 + z * m12 + m13);
              } else {
                farray[(index++)] = (x * m00 + y * m01 + z * m02 + m03);
                farray[(index++)] = (x * m10 + y * m11 + z * m12 + m13);
              }
              farray[(index++)] = (x * m20 + y * m21 + z * m22 + m23);
              farray[index] = (x * m30 + y * m31 + z * m32 + m33);
            } else {
              farray[(index++)] = x;
              farray[(index++)] = y;
              farray[(index++)] = z;
              farray[index] = 1.0F;
            }
          } else if (attrib.isNormal()) {
            float[] farray = (float[])fpolyAttribs.get(name);
            float x = (float)d[(pos + 0)];
            float y = (float)d[(pos + 1)];
            float z = (float)d[(pos + 2)];
            if ((renderMode == 0) && (pg.flushMode == 1)) {
              farray[(index++)] = (x * m00 + y * m10 + z * m20);
              farray[(index++)] = (x * m01 + y * m11 + z * m21);
              farray[index] = (x * m02 + y * m12 + z * m22);
            } else {
              farray[(index++)] = x;
              farray[(index++)] = y;
              farray[index] = z;
            }
            pos += 3;
          } else {
            if (attrib.isFloat()) {
              float[] farray = (float[])fpolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                farray[(index++)] = ((float)d[(pos++)]);
              }
            } else if (attrib.isInt()) {
              int[] iarray = (int[])ipolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                iarray[(index++)] = ((int)d[(pos++)]);
              }
            } else if (attrib.isBool()) {
              byte[] barray = (byte[])bpolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                barray[(index++)] = ((byte)(int)d[(pos++)]);
              }
            }
            pos += size;
          }
        }
      }
    }
    




    void addPolyVertex(float x, float y, float z, int rgba, float nx, float ny, float nz, float u, float v, int am, int sp, int em, float shine, boolean clampXY)
    {
      polyVertexCheck();
      int tessIdx = polyVertexCount - 1;
      setPolyVertex(tessIdx, x, y, z, 
        rgba, 
        nx, ny, nz, 
        u, v, 
        am, sp, em, shine, clampXY);
    }
    
    void setPolyVertex(int tessIdx, float x, float y, float z, int rgba, boolean clampXY)
    {
      setPolyVertex(tessIdx, x, y, z, 
        rgba, 
        0.0F, 0.0F, 1.0F, 
        0.0F, 0.0F, 
        0, 0, 0, 0.0F, clampXY);
    }
    






    void setPolyVertex(int tessIdx, float x, float y, float z, int rgba, float nx, float ny, float nz, float u, float v, int am, int sp, int em, float shine, boolean clampXY)
    {
      if ((renderMode == 0) && (pg.flushMode == 1)) {
        PMatrix3D mm = pg.modelview;
        PMatrix3D nm = pg.modelviewInv;
        
        int index = 4 * tessIdx;
        if (clampXY)
        {
          polyVertices[(index++)] = 
            PApplet.ceil(x * m00 + y * m01 + z * m02 + m03);
          polyVertices[(index++)] = 
            PApplet.ceil(x * m10 + y * m11 + z * m12 + m13);
        } else {
          polyVertices[(index++)] = (x * m00 + y * m01 + z * m02 + m03);
          polyVertices[(index++)] = (x * m10 + y * m11 + z * m12 + m13);
        }
        polyVertices[(index++)] = (x * m20 + y * m21 + z * m22 + m23);
        polyVertices[index] = (x * m30 + y * m31 + z * m32 + m33);
        
        index = 3 * tessIdx;
        polyNormals[(index++)] = (nx * m00 + ny * m10 + nz * m20);
        polyNormals[(index++)] = (nx * m01 + ny * m11 + nz * m21);
        polyNormals[index] = (nx * m02 + ny * m12 + nz * m22);
      } else {
        index = 4 * tessIdx;
        polyVertices[(index++)] = x;
        polyVertices[(index++)] = y;
        polyVertices[(index++)] = z;
        polyVertices[index] = 1.0F;
        
        index = 3 * tessIdx;
        polyNormals[(index++)] = nx;
        polyNormals[(index++)] = ny;
        polyNormals[index] = nz;
      }
      
      polyColors[tessIdx] = rgba;
      
      int index = 2 * tessIdx;
      polyTexCoords[(index++)] = u;
      polyTexCoords[index] = v;
      
      polyAmbient[tessIdx] = am;
      polySpecular[tessIdx] = sp;
      polyEmissive[tessIdx] = em;
      polyShininess[tessIdx] = shine;
    }
    
    void addPolyVertices(PGraphicsOpenGL.InGeometry in, boolean clampXY) {
      addPolyVertices(in, 0, vertexCount - 1, clampXY);
    }
    
    void addPolyVertex(PGraphicsOpenGL.InGeometry in, int i, boolean clampXY) {
      addPolyVertices(in, i, i, clampXY);
    }
    
    void addPolyVertices(PGraphicsOpenGL.InGeometry in, int i0, int i1, boolean clampXY) {
      int index = 0;
      int nvert = i1 - i0 + 1;
      
      polyVertexCheck(nvert);
      
      if ((renderMode == 0) && (pg.flushMode == 1)) {
        modelviewCoords(in, i0, index, nvert, clampXY);
      }
      else if (nvert <= PGL.MIN_ARRAYCOPY_SIZE) {
        copyFewCoords(in, i0, index, nvert);
      } else {
        copyManyCoords(in, i0, index, nvert);
      }
      

      if (nvert <= PGL.MIN_ARRAYCOPY_SIZE) {
        copyFewAttribs(in, i0, index, nvert);
      } else {
        copyManyAttribs(in, i0, index, nvert);
      }
    }
    
    private void modelviewCoords(PGraphicsOpenGL.InGeometry in, int i0, int index, int nvert, boolean clampXY)
    {
      PMatrix3D mm = pg.modelview;
      PMatrix3D nm = pg.modelviewInv;
      
      for (int i = 0; i < nvert; i++) {
        int inIdx = i0 + i;
        int tessIdx = firstPolyVertex + i;
        
        index = 3 * inIdx;
        float x = vertices[(index++)];
        float y = vertices[(index++)];
        float z = vertices[index];
        
        index = 3 * inIdx;
        float nx = normals[(index++)];
        float ny = normals[(index++)];
        float nz = normals[index];
        
        index = 4 * tessIdx;
        if (clampXY)
        {
          polyVertices[(index++)] = 
            PApplet.ceil(x * m00 + y * m01 + z * m02 + m03);
          polyVertices[(index++)] = 
            PApplet.ceil(x * m10 + y * m11 + z * m12 + m13);
        } else {
          polyVertices[(index++)] = (x * m00 + y * m01 + z * m02 + m03);
          polyVertices[(index++)] = (x * m10 + y * m11 + z * m12 + m13);
        }
        polyVertices[(index++)] = (x * m20 + y * m21 + z * m22 + m23);
        polyVertices[index] = (x * m30 + y * m31 + z * m32 + m33);
        
        index = 3 * tessIdx;
        polyNormals[(index++)] = (nx * m00 + ny * m10 + nz * m20);
        polyNormals[(index++)] = (nx * m01 + ny * m11 + nz * m21);
        polyNormals[index] = (nx * m02 + ny * m12 + nz * m22);
        
        for (String name : polyAttribs.keySet()) {
          PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
          if ((!attrib.isColor()) && (!attrib.isOther()))
          {
            float[] inValues = (float[])fattribs.get(name);
            index = 3 * inIdx;
            x = inValues[(index++)];
            y = inValues[(index++)];
            z = inValues[index];
            
            float[] tessValues = (float[])fpolyAttribs.get(name);
            if (attrib.isPosition()) {
              index = 4 * tessIdx;
              if (clampXY)
              {
                tessValues[(index++)] = 
                  PApplet.ceil(x * m00 + y * m01 + z * m02 + m03);
                tessValues[(index++)] = 
                  PApplet.ceil(x * m10 + y * m11 + z * m12 + m13);
              } else {
                tessValues[(index++)] = (x * m00 + y * m01 + z * m02 + m03);
                tessValues[(index++)] = (x * m10 + y * m11 + z * m12 + m13);
              }
              tessValues[(index++)] = (x * m20 + y * m21 + z * m22 + m23);
              tessValues[index] = (x * m30 + y * m31 + z * m32 + m33);
            } else {
              index = 3 * tessIdx;
              tessValues[(index++)] = (x * m00 + y * m10 + z * m20);
              tessValues[(index++)] = (x * m01 + y * m11 + z * m21);
              tessValues[index] = (x * m02 + y * m12 + z * m22);
            }
          }
        }
      }
    }
    

    private void copyFewCoords(PGraphicsOpenGL.InGeometry in, int i0, int index, int nvert)
    {
      for (int i = 0; i < nvert; i++) {
        int inIdx = i0 + i;
        int tessIdx = firstPolyVertex + i;
        
        index = 3 * inIdx;
        float x = vertices[(index++)];
        float y = vertices[(index++)];
        float z = vertices[index];
        
        index = 3 * inIdx;
        float nx = normals[(index++)];
        float ny = normals[(index++)];
        float nz = normals[index];
        
        index = 4 * tessIdx;
        polyVertices[(index++)] = x;
        polyVertices[(index++)] = y;
        polyVertices[(index++)] = z;
        polyVertices[index] = 1.0F;
        
        index = 3 * tessIdx;
        polyNormals[(index++)] = nx;
        polyNormals[(index++)] = ny;
        polyNormals[index] = nz;
        
        for (String name : polyAttribs.keySet()) {
          PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
          if ((!attrib.isColor()) && (!attrib.isOther()))
          {
            float[] inValues = (float[])fattribs.get(name);
            index = 3 * inIdx;
            x = inValues[(index++)];
            y = inValues[(index++)];
            z = inValues[index];
            
            float[] tessValues = (float[])fpolyAttribs.get(name);
            if (attrib.isPosition()) {
              index = 4 * tessIdx;
              tessValues[(index++)] = x;
              tessValues[(index++)] = y;
              tessValues[(index++)] = z;
              tessValues[index] = 1.0F;
            } else {
              index = 3 * tessIdx;
              tessValues[(index++)] = x;
              tessValues[(index++)] = y;
              tessValues[index] = z;
            }
          }
        }
      }
    }
    
    private void copyManyCoords(PGraphicsOpenGL.InGeometry in, int i0, int index, int nvert) { int inIdx;
      for (int i = 0; i < nvert; i++)
      {

        inIdx = i0 + i;
        int tessIdx = firstPolyVertex + i;
        PApplet.arrayCopy(vertices, 3 * inIdx, 
          polyVertices, 4 * tessIdx, 3);
        polyVertices[(4 * tessIdx + 3)] = 1.0F;
        
        for (String name : polyAttribs.keySet()) {
          PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
          if (attrib.isPosition()) {
            float[] inValues = (float[])fattribs.get(name);
            float[] tessValues = (float[])fpolyAttribs.get(name);
            PApplet.arrayCopy(inValues, 3 * inIdx, 
              tessValues, 4 * tessIdx, 3);
            tessValues[(4 * tessIdx + 3)] = 1.0F;
          }
        } }
      PApplet.arrayCopy(normals, 3 * i0, 
        polyNormals, 3 * firstPolyVertex, 3 * nvert);
      for (String name : polyAttribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
        if (attrib.isNormal()) {
          float[] inValues = (float[])fattribs.get(name);
          float[] tessValues = (float[])fpolyAttribs.get(name);
          PApplet.arrayCopy(inValues, 3 * i0, 
            tessValues, 3 * firstPolyVertex, 3 * nvert);
        }
      }
    }
    
    private void copyFewAttribs(PGraphicsOpenGL.InGeometry in, int i0, int index, int nvert) {
      for (int i = 0; i < nvert; i++) {
        int inIdx = i0 + i;
        int tessIdx = firstPolyVertex + i;
        
        index = 2 * inIdx;
        float u = texcoords[(index++)];
        float v = texcoords[index];
        
        polyColors[tessIdx] = colors[inIdx];
        
        index = 2 * tessIdx;
        polyTexCoords[(index++)] = u;
        polyTexCoords[index] = v;
        
        polyAmbient[tessIdx] = ambient[inIdx];
        polySpecular[tessIdx] = specular[inIdx];
        polyEmissive[tessIdx] = emissive[inIdx];
        polyShininess[tessIdx] = shininess[inIdx];
        
        for (String name : polyAttribs.keySet()) {
          PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
          if ((!attrib.isPosition()) && (!attrib.isNormal())) {
            int index0 = size * inIdx;
            int index1 = size * tessIdx;
            if (attrib.isFloat()) {
              float[] inValues = (float[])fattribs.get(name);
              float[] tessValues = (float[])fpolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                tessValues[(index1++)] = inValues[(index0++)];
              }
            } else if (attrib.isInt()) {
              int[] inValues = (int[])iattribs.get(name);
              int[] tessValues = (int[])ipolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                tessValues[(index1++)] = inValues[(index0++)];
              }
            } else if (attrib.isBool()) {
              byte[] inValues = (byte[])battribs.get(name);
              byte[] tessValues = (byte[])bpolyAttribs.get(name);
              for (int n = 0; n < size; n++) {
                tessValues[(index1++)] = inValues[(index0++)];
              }
            }
          }
        }
      }
    }
    
    private void copyManyAttribs(PGraphicsOpenGL.InGeometry in, int i0, int index, int nvert) {
      PApplet.arrayCopy(colors, i0, 
        polyColors, firstPolyVertex, nvert);
      PApplet.arrayCopy(texcoords, 2 * i0, 
        polyTexCoords, 2 * firstPolyVertex, 2 * nvert);
      PApplet.arrayCopy(ambient, i0, 
        polyAmbient, firstPolyVertex, nvert);
      PApplet.arrayCopy(specular, i0, 
        polySpecular, firstPolyVertex, nvert);
      PApplet.arrayCopy(emissive, i0, 
        polyEmissive, firstPolyVertex, nvert);
      PApplet.arrayCopy(shininess, i0, 
        polyShininess, firstPolyVertex, nvert);
      
      for (String name : polyAttribs.keySet()) {
        PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
        if ((!attrib.isPosition()) && (!attrib.isNormal())) {
          Object inValues = null;
          Object tessValues = null;
          if (attrib.isFloat()) {
            inValues = fattribs.get(name);
            tessValues = fpolyAttribs.get(name);
          } else if (attrib.isInt()) {
            inValues = iattribs.get(name);
            tessValues = ipolyAttribs.get(name);
          } else if (attrib.isBool()) {
            inValues = battribs.get(name);
            tessValues = bpolyAttribs.get(name);
          }
          PApplet.arrayCopy(inValues, size * i0, 
            tessValues, tessSize * firstPolyVertex, 
            size * nvert);
        }
      }
    }
    


    void applyMatrixOnPolyGeometry(PMatrix tr, int first, int last)
    {
      if ((tr instanceof PMatrix2D)) {
        applyMatrixOnPolyGeometry((PMatrix2D)tr, first, last);
      } else if ((tr instanceof PMatrix3D)) {
        applyMatrixOnPolyGeometry((PMatrix3D)tr, first, last);
      }
    }
    
    void applyMatrixOnLineGeometry(PMatrix tr, int first, int last) {
      if ((tr instanceof PMatrix2D)) {
        applyMatrixOnLineGeometry((PMatrix2D)tr, first, last);
      } else if ((tr instanceof PMatrix3D)) {
        applyMatrixOnLineGeometry((PMatrix3D)tr, first, last);
      }
    }
    
    void applyMatrixOnPointGeometry(PMatrix tr, int first, int last) {
      if ((tr instanceof PMatrix2D)) {
        applyMatrixOnPointGeometry((PMatrix2D)tr, first, last);
      } else if ((tr instanceof PMatrix3D)) {
        applyMatrixOnPointGeometry((PMatrix3D)tr, first, last);
      }
    }
    
    void applyMatrixOnPolyGeometry(PMatrix2D tr, int first, int last) {
      if (first < last)
      {

        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = polyVertices[(index++)];
          float y = polyVertices[index];
          
          index = 3 * i;
          float nx = polyNormals[(index++)];
          float ny = polyNormals[index];
          
          index = 4 * i;
          polyVertices[(index++)] = (x * m00 + y * m01 + m02);
          polyVertices[index] = (x * m10 + y * m11 + m12);
          
          index = 3 * i;
          polyNormals[(index++)] = (nx * m00 + ny * m01);
          polyNormals[index] = (nx * m10 + ny * m11);
          
          for (String name : polyAttribs.keySet()) {
            PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
            if ((!attrib.isColor()) && (!attrib.isOther())) {
              float[] values = (float[])fpolyAttribs.get(name);
              if (attrib.isPosition()) {
                index = 4 * i;
                x = values[(index++)];
                y = values[index];
                index = 4 * i;
                values[(index++)] = (x * m00 + y * m01 + m02);
                values[index] = (x * m10 + y * m11 + m12);
              } else {
                index = 3 * i;
                nx = values[(index++)];
                ny = values[index];
                index = 3 * i;
                values[(index++)] = (nx * m00 + ny * m01);
                values[index] = (nx * m10 + ny * m11);
              }
            }
          }
        } }
    }
    
    void applyMatrixOnLineGeometry(PMatrix2D tr, int first, int last) {
      if (first < last)
      {

        float scaleFactor = PGraphicsOpenGL.matrixScale(tr);
        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = lineVertices[(index++)];
          float y = lineVertices[index];
          
          index = 4 * i;
          float dx = lineDirections[(index++)];
          float dy = lineDirections[index];
          
          index = 4 * i;
          lineVertices[(index++)] = (x * m00 + y * m01 + m02);
          lineVertices[index] = (x * m10 + y * m11 + m12);
          
          index = 4 * i;
          lineDirections[(index++)] = (dx * m00 + dy * m01);
          lineDirections[index] = (dx * m10 + dy * m11);
          lineDirections[(index + 2)] *= scaleFactor;
        }
      }
    }
    
    void applyMatrixOnPointGeometry(PMatrix2D tr, int first, int last) {
      if (first < last)
      {

        float matrixScale = PGraphicsOpenGL.matrixScale(tr);
        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = pointVertices[(index++)];
          float y = pointVertices[index];
          
          index = 4 * i;
          pointVertices[(index++)] = (x * m00 + y * m01 + m02);
          pointVertices[index] = (x * m10 + y * m11 + m12);
          
          index = 2 * i;
          pointOffsets[(index++)] *= matrixScale;
          pointOffsets[index] *= matrixScale;
        }
      }
    }
    
    void applyMatrixOnPolyGeometry(PMatrix3D tr, int first, int last) {
      if (first < last)
      {

        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = polyVertices[(index++)];
          float y = polyVertices[(index++)];
          float z = polyVertices[(index++)];
          float w = polyVertices[index];
          
          index = 3 * i;
          float nx = polyNormals[(index++)];
          float ny = polyNormals[(index++)];
          float nz = polyNormals[index];
          
          index = 4 * i;
          polyVertices[(index++)] = (x * m00 + y * m01 + z * m02 + w * m03);
          polyVertices[(index++)] = (x * m10 + y * m11 + z * m12 + w * m13);
          polyVertices[(index++)] = (x * m20 + y * m21 + z * m22 + w * m23);
          polyVertices[index] = (x * m30 + y * m31 + z * m32 + w * m33);
          
          index = 3 * i;
          polyNormals[(index++)] = (nx * m00 + ny * m01 + nz * m02);
          polyNormals[(index++)] = (nx * m10 + ny * m11 + nz * m12);
          polyNormals[index] = (nx * m20 + ny * m21 + nz * m22);
          
          for (String name : polyAttribs.keySet()) {
            PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
            if ((!attrib.isColor()) && (!attrib.isOther())) {
              float[] values = (float[])fpolyAttribs.get(name);
              if (attrib.isPosition()) {
                index = 4 * i;
                x = values[(index++)];
                y = values[(index++)];
                z = values[(index++)];
                w = values[index];
                index = 4 * i;
                values[(index++)] = (x * m00 + y * m01 + z * m02 + w * m03);
                values[(index++)] = (x * m10 + y * m11 + z * m12 + w * m13);
                values[(index++)] = (x * m20 + y * m21 + z * m22 + w * m23);
                values[index] = (x * m30 + y * m31 + z * m32 + w * m33);
              } else {
                index = 3 * i;
                nx = values[(index++)];
                ny = values[(index++)];
                nz = values[index];
                index = 3 * i;
                values[(index++)] = (nx * m00 + ny * m01 + nz * m02);
                values[(index++)] = (nx * m10 + ny * m11 + nz * m12);
                values[index] = (nx * m20 + ny * m21 + nz * m22);
              }
            }
          }
        } }
    }
    
    void applyMatrixOnLineGeometry(PMatrix3D tr, int first, int last) {
      if (first < last)
      {

        float scaleFactor = PGraphicsOpenGL.matrixScale(tr);
        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = lineVertices[(index++)];
          float y = lineVertices[(index++)];
          float z = lineVertices[(index++)];
          float w = lineVertices[index];
          
          index = 4 * i;
          float dx = lineDirections[(index++)];
          float dy = lineDirections[(index++)];
          float dz = lineDirections[index];
          
          index = 4 * i;
          lineVertices[(index++)] = (x * m00 + y * m01 + z * m02 + w * m03);
          lineVertices[(index++)] = (x * m10 + y * m11 + z * m12 + w * m13);
          lineVertices[(index++)] = (x * m20 + y * m21 + z * m22 + w * m23);
          lineVertices[index] = (x * m30 + y * m31 + z * m32 + w * m33);
          
          index = 4 * i;
          lineDirections[(index++)] = (dx * m00 + dy * m01 + dz * m02);
          lineDirections[(index++)] = (dx * m10 + dy * m11 + dz * m12);
          lineDirections[(index++)] = (dx * m20 + dy * m21 + dz * m22);
          lineDirections[index] *= scaleFactor;
        }
      }
    }
    
    void applyMatrixOnPointGeometry(PMatrix3D tr, int first, int last) {
      if (first < last)
      {

        float matrixScale = PGraphicsOpenGL.matrixScale(tr);
        for (int i = first; i <= last; i++) {
          int index = 4 * i;
          float x = pointVertices[(index++)];
          float y = pointVertices[(index++)];
          float z = pointVertices[(index++)];
          float w = pointVertices[index];
          
          index = 4 * i;
          pointVertices[(index++)] = (x * m00 + y * m01 + z * m02 + w * m03);
          pointVertices[(index++)] = (x * m10 + y * m11 + z * m12 + w * m13);
          pointVertices[(index++)] = (x * m20 + y * m21 + z * m22 + w * m23);
          pointVertices[index] = (x * m30 + y * m31 + z * m32 + w * m33);
          
          index = 2 * i;
          pointOffsets[(index++)] *= matrixScale;
          pointOffsets[index] *= matrixScale;
        }
      }
    }
  }
  

  protected static class Tessellator
  {
    PGraphicsOpenGL.InGeometry in;
    
    PGraphicsOpenGL.TessGeometry tess;
    
    PGraphicsOpenGL.TexCache texCache;
    
    PImage prevTexImage;
    
    PImage newTexImage;
    
    int firstTexIndex;
    
    int firstTexCache;
    
    PGL.Tessellator gluTess;
    
    TessellatorCallback callback;
    
    boolean fill;
    boolean stroke;
    int strokeColor;
    float strokeWeight;
    int strokeJoin;
    int strokeCap;
    boolean accurate2DStrokes;
    PMatrix transform;
    float transformScale;
    boolean is2D;
    boolean is3D;
    protected PGraphicsOpenGL pg;
    int[] rawIndices;
    int rawSize;
    int[] dupIndices;
    int dupCount;
    int firstPolyIndexCache;
    int lastPolyIndexCache;
    int firstLineIndexCache;
    int lastLineIndexCache;
    int firstPointIndexCache;
    int lastPointIndexCache;
    float[] strokeVertices;
    int[] strokeColors;
    float[] strokeWeights;
    int pathVertexCount;
    float[] pathVertices;
    int[] pathColors;
    float[] pathWeights;
    int beginPath;
    
    public Tessellator()
    {
      rawIndices = new int['Ȁ'];
      accurate2DStrokes = true;
      transform = null;
      is2D = false;
      is3D = true;
    }
    
    void initGluTess() {
      if (gluTess == null) {
        callback = new TessellatorCallback(tess.polyAttribs);
        gluTess = pg.pgl.createTessellator(callback);
      }
    }
    
    void setInGeometry(PGraphicsOpenGL.InGeometry in) {
      this.in = in;
      
      firstPolyIndexCache = -1;
      lastPolyIndexCache = -1;
      firstLineIndexCache = -1;
      lastLineIndexCache = -1;
      firstPointIndexCache = -1;
      lastPointIndexCache = -1;
    }
    
    void setTessGeometry(PGraphicsOpenGL.TessGeometry tess) {
      this.tess = tess;
    }
    
    void setFill(boolean fill) {
      this.fill = fill;
    }
    
    void setTexCache(PGraphicsOpenGL.TexCache texCache, PImage newTexImage) {
      this.texCache = texCache;
      this.newTexImage = newTexImage;
    }
    
    void setStroke(boolean stroke) {
      this.stroke = stroke;
    }
    
    void setStrokeColor(int color) {
      strokeColor = PGL.javaToNativeARGB(color);
    }
    
    void setStrokeWeight(float weight) {
      strokeWeight = weight;
    }
    
    void setStrokeCap(int strokeCap) {
      this.strokeCap = strokeCap;
    }
    
    void setStrokeJoin(int strokeJoin) {
      this.strokeJoin = strokeJoin;
    }
    
    void setAccurate2DStrokes(boolean accurate) {
      accurate2DStrokes = accurate;
    }
    
    protected void setRenderer(PGraphicsOpenGL pg) {
      this.pg = pg;
    }
    
    void set3D(boolean value) {
      if (value) {
        is2D = false;
        is3D = true;
      } else {
        is2D = true;
        is3D = false;
      }
    }
    
    void setTransform(PMatrix transform) {
      this.transform = transform;
      transformScale = -1.0F;
    }
    
    void resetCurveVertexCount() {
      pg.curveVertexCount = 0;
    }
    



    void tessellatePoints()
    {
      if (strokeCap == 2) {
        tessellateRoundPoints();
      } else {
        tessellateSquarePoints();
      }
    }
    
    void tessellateRoundPoints() {
      int nInVert = in.vertexCount;
      if ((stroke) && (1 <= nInVert))
      {


        int nPtVert = 
          PApplet.min(200, PApplet.max(20, 
          (int)(6.2831855F * strokeWeight / 
          10.0F))) + 1;
        if (PGL.MAX_VERTEX_INDEX1 <= nPtVert) {
          throw new RuntimeException("Error in point tessellation.");
        }
        updateTex();
        int nvertTot = nPtVert * nInVert;
        int nindTot = 3 * (nPtVert - 1) * nInVert;
        if (is3D) {
          tessellateRoundPoints3D(nvertTot, nindTot, nPtVert);
        } else if (is2D) {
          beginNoTex();
          tessellateRoundPoints2D(nvertTot, nindTot, nPtVert);
          endNoTex();
        }
      }
    }
    
    void tessellateRoundPoints3D(int nvertTot, int nindTot, int nPtVert) {
      int perim = nPtVert - 1;
      tess.pointVertexCheck(nvertTot);
      tess.pointIndexCheck(nindTot);
      int vertIdx = tess.firstPointVertex;
      int attribIdx = tess.firstPointVertex;
      int indIdx = tess.firstPointIndex;
      PGraphicsOpenGL.IndexCache cache = tess.pointIndexCache;
      int index = in.renderMode == 1 ? cache.addNew() : cache.getLast();
      firstPointIndexCache = index;
      for (int i = 0; i < in.vertexCount; i++)
      {

        int count = vertexCount[index];
        if (PGL.MAX_VERTEX_INDEX1 <= count + nPtVert)
        {
          index = cache.addNew();
          count = 0;
        }
        

        for (int k = 0; k < nPtVert; k++) {
          tess.setPointVertex(vertIdx, in, i);
          vertIdx++;
        }
        




        tess.pointOffsets[(2 * attribIdx + 0)] = 0.0F;
        tess.pointOffsets[(2 * attribIdx + 1)] = 0.0F;
        attribIdx++;
        float val = 0.0F;
        float inc = 720.0F / perim;
        for (int k = 0; k < perim; k++) {
          tess.pointOffsets[(2 * attribIdx + 0)] = 
            (0.5F * PGraphicsOpenGL.cosLUT[((int)val)] * transformScale() * strokeWeight);
          tess.pointOffsets[(2 * attribIdx + 1)] = 
            (0.5F * PGraphicsOpenGL.sinLUT[((int)val)] * transformScale() * strokeWeight);
          val = (val + inc) % 720.0F;
          attribIdx++;
        }
        


        for (int k = 1; k < nPtVert - 1; k++) {
          tess.pointIndices[(indIdx++)] = ((short)(count + 0));
          tess.pointIndices[(indIdx++)] = ((short)(count + k));
          tess.pointIndices[(indIdx++)] = ((short)(count + k + 1));
        }
        
        tess.pointIndices[(indIdx++)] = ((short)(count + 0));
        tess.pointIndices[(indIdx++)] = ((short)(count + 1));
        tess.pointIndices[(indIdx++)] = ((short)(count + nPtVert - 1));
        
        cache.incCounts(index, 3 * (nPtVert - 1), nPtVert);
      }
      lastPointIndexCache = index;
    }
    
    void tessellateRoundPoints2D(int nvertTot, int nindTot, int nPtVert) {
      int perim = nPtVert - 1;
      tess.polyVertexCheck(nvertTot);
      tess.polyIndexCheck(nindTot);
      int vertIdx = tess.firstPolyVertex;
      int indIdx = tess.firstPolyIndex;
      PGraphicsOpenGL.IndexCache cache = tess.polyIndexCache;
      int index = in.renderMode == 1 ? cache.addNew() : cache.getLast();
      firstPointIndexCache = index;
      if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
      for (int i = 0; i < in.vertexCount; i++) {
        int count = vertexCount[index];
        if (PGL.MAX_VERTEX_INDEX1 <= count + nPtVert)
        {
          index = cache.addNew();
          count = 0;
        }
        
        float x0 = in.vertices[(3 * i + 0)];
        float y0 = in.vertices[(3 * i + 1)];
        int rgba = in.strokeColors[i];
        
        float val = 0.0F;
        float inc = 720.0F / perim;
        tess.setPolyVertex(vertIdx, x0, y0, 0.0F, rgba, false);
        vertIdx++;
        for (int k = 0; k < perim; k++) {
          tess.setPolyVertex(vertIdx, 
            x0 + 0.5F * PGraphicsOpenGL.cosLUT[((int)val)] * strokeWeight, 
            y0 + 0.5F * PGraphicsOpenGL.sinLUT[((int)val)] * strokeWeight, 
            0.0F, rgba, false);
          vertIdx++;
          val = (val + inc) % 720.0F;
        }
        


        for (int k = 1; k < nPtVert - 1; k++) {
          tess.polyIndices[(indIdx++)] = ((short)(count + 0));
          tess.polyIndices[(indIdx++)] = ((short)(count + k));
          tess.polyIndices[(indIdx++)] = ((short)(count + k + 1));
        }
        
        tess.polyIndices[(indIdx++)] = ((short)(count + 0));
        tess.polyIndices[(indIdx++)] = ((short)(count + 1));
        tess.polyIndices[(indIdx++)] = ((short)(count + nPtVert - 1));
        
        cache.incCounts(index, 3 * (nPtVert - 1), nPtVert);
      }
      lastPointIndexCache = (this.lastPolyIndexCache = index);
    }
    
    void tessellateSquarePoints() {
      int nInVert = in.vertexCount;
      if ((stroke) && (1 <= nInVert)) {
        updateTex();
        int quadCount = nInVert;
        


        int nvertTot = 5 * quadCount;
        

        int nindTot = 12 * quadCount;
        if (is3D) {
          tessellateSquarePoints3D(nvertTot, nindTot);
        } else if (is2D) {
          beginNoTex();
          tessellateSquarePoints2D(nvertTot, nindTot);
          endNoTex();
        }
      }
    }
    
    void tessellateSquarePoints3D(int nvertTot, int nindTot) {
      tess.pointVertexCheck(nvertTot);
      tess.pointIndexCheck(nindTot);
      int vertIdx = tess.firstPointVertex;
      int attribIdx = tess.firstPointVertex;
      int indIdx = tess.firstPointIndex;
      PGraphicsOpenGL.IndexCache cache = tess.pointIndexCache;
      int index = in.renderMode == 1 ? cache.addNew() : cache.getLast();
      firstPointIndexCache = index;
      for (int i = 0; i < in.vertexCount; i++) {
        int nvert = 5;
        int count = vertexCount[index];
        if (PGL.MAX_VERTEX_INDEX1 <= count + nvert)
        {
          index = cache.addNew();
          count = 0;
        }
        
        for (int k = 0; k < nvert; k++) {
          tess.setPointVertex(vertIdx, in, i);
          vertIdx++;
        }
        




        tess.pointOffsets[(2 * attribIdx + 0)] = 0.0F;
        tess.pointOffsets[(2 * attribIdx + 1)] = 0.0F;
        attribIdx++;
        for (int k = 0; k < 4; k++) {
          tess.pointOffsets[(2 * attribIdx + 0)] = 
            (0.5F * PGraphicsOpenGL.QUAD_POINT_SIGNS[k][0] * transformScale() * strokeWeight);
          tess.pointOffsets[(2 * attribIdx + 1)] = 
            (0.5F * PGraphicsOpenGL.QUAD_POINT_SIGNS[k][1] * transformScale() * strokeWeight);
          attribIdx++;
        }
        


        for (int k = 1; k < nvert - 1; k++) {
          tess.pointIndices[(indIdx++)] = ((short)(count + 0));
          tess.pointIndices[(indIdx++)] = ((short)(count + k));
          tess.pointIndices[(indIdx++)] = ((short)(count + k + 1));
        }
        
        tess.pointIndices[(indIdx++)] = ((short)(count + 0));
        tess.pointIndices[(indIdx++)] = ((short)(count + 1));
        tess.pointIndices[(indIdx++)] = ((short)(count + nvert - 1));
        
        cache.incCounts(index, 12, 5);
      }
      lastPointIndexCache = index;
    }
    
    void tessellateSquarePoints2D(int nvertTot, int nindTot) {
      tess.polyVertexCheck(nvertTot);
      tess.polyIndexCheck(nindTot);
      boolean clamp = clampSquarePoints2D();
      int vertIdx = tess.firstPolyVertex;
      int indIdx = tess.firstPolyIndex;
      PGraphicsOpenGL.IndexCache cache = tess.polyIndexCache;
      int index = in.renderMode == 1 ? cache.addNew() : cache.getLast();
      firstPointIndexCache = index;
      if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
      for (int i = 0; i < in.vertexCount; i++) {
        int nvert = 5;
        int count = vertexCount[index];
        if (PGL.MAX_VERTEX_INDEX1 <= count + nvert)
        {
          index = cache.addNew();
          count = 0;
        }
        
        float x0 = in.vertices[(3 * i + 0)];
        float y0 = in.vertices[(3 * i + 1)];
        int rgba = in.strokeColors[i];
        
        tess.setPolyVertex(vertIdx, x0, y0, 0.0F, rgba, clamp);
        vertIdx++;
        for (int k = 0; k < nvert - 1; k++) {
          tess.setPolyVertex(vertIdx, 
            x0 + 0.5F * PGraphicsOpenGL.QUAD_POINT_SIGNS[k][0] * strokeWeight, 
            y0 + 0.5F * PGraphicsOpenGL.QUAD_POINT_SIGNS[k][1] * strokeWeight, 
            0.0F, rgba, clamp);
          vertIdx++;
        }
        
        for (int k = 1; k < nvert - 1; k++) {
          tess.polyIndices[(indIdx++)] = ((short)(count + 0));
          tess.polyIndices[(indIdx++)] = ((short)(count + k));
          tess.polyIndices[(indIdx++)] = ((short)(count + k + 1));
        }
        
        tess.polyIndices[(indIdx++)] = ((short)(count + 0));
        tess.polyIndices[(indIdx++)] = ((short)(count + 1));
        tess.polyIndices[(indIdx++)] = ((short)(count + nvert - 1));
        
        cache.incCounts(index, 12, 5);
      }
      lastPointIndexCache = (this.lastPolyIndexCache = index);
    }
    
    boolean clamp2D() {
      return (is2D) && (tess.renderMode == 0) && 
        (PGraphicsOpenGL.zero(pg.modelview.m01)) && (PGraphicsOpenGL.zero(pg.modelview.m10));
    }
    
    boolean clampSquarePoints2D() {
      return clamp2D();
    }
    



    void tessellateLines()
    {
      int nInVert = in.vertexCount;
      if ((stroke) && (2 <= nInVert)) {
        strokeVertices = in.vertices;
        strokeColors = in.strokeColors;
        strokeWeights = in.strokeWeights;
        updateTex();
        int lineCount = nInVert / 2;
        if (is3D) {
          tessellateLines3D(lineCount);
        } else if (is2D) {
          beginNoTex();
          tessellateLines2D(lineCount);
          endNoTex();
        }
      }
    }
    
    void tessellateLines3D(int lineCount)
    {
      int nvert = lineCount * 4;
      

      int nind = lineCount * 2 * 3;
      
      int vcount0 = tess.lineVertexCount;
      int icount0 = tess.lineIndexCount;
      tess.lineVertexCheck(nvert);
      tess.lineIndexCheck(nind);
      int index = in.renderMode == 1 ? tess.lineIndexCache.addNew() : 
        tess.lineIndexCache.getLast();
      firstLineIndexCache = index;
      int[] tmp = new int[2];
      tess.lineIndexCache.setCounter(tmp);
      for (int ln = 0; ln < lineCount; ln++) {
        int i0 = 2 * ln + 0;
        int i1 = 2 * ln + 1;
        index = addLineSegment3D(i0, i1, i0 - 2, i1 - 1, index, null, false);
      }
      
      tess.lineIndexCache.setCounter(null);
      tess.lineIndexCount = (icount0 + tmp[0]);
      tess.lineVertexCount = (vcount0 + tmp[1]);
      lastLineIndexCache = index;
    }
    
    void tessellateLines2D(int lineCount) {
      int nvert = lineCount * 4;
      int nind = lineCount * 2 * 3;
      
      if (noCapsJoins(nvert)) {
        tess.polyVertexCheck(nvert);
        tess.polyIndexCheck(nind);
        int index = in.renderMode == 1 ? tess.polyIndexCache.addNew() : 
          tess.polyIndexCache.getLast();
        firstLineIndexCache = index;
        if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
        boolean clamp = clampLines2D(lineCount);
        for (int ln = 0; ln < lineCount; ln++) {
          int i0 = 2 * ln + 0;
          int i1 = 2 * ln + 1;
          index = addLineSegment2D(i0, i1, index, false, clamp);
        }
        lastLineIndexCache = (this.lastPolyIndexCache = index);
      } else {
        LinePath path = new LinePath(1);
        for (int ln = 0; ln < lineCount; ln++) {
          int i0 = 2 * ln + 0;
          int i1 = 2 * ln + 1;
          path.moveTo(in.vertices[(3 * i0 + 0)], in.vertices[(3 * i0 + 1)], 
            in.strokeColors[i0]);
          path.lineTo(in.vertices[(3 * i1 + 0)], in.vertices[(3 * i1 + 1)], 
            in.strokeColors[i1]);
        }
        tessellateLinePath(path);
      }
    }
    
    boolean clampLines2D(int lineCount) {
      boolean res = clamp2D();
      if (res)
        for (int ln = 0; ln < lineCount; ln++) {
          int i0 = 2 * ln + 0;
          int i1 = 2 * ln + 1;
          res = segmentIsAxisAligned(i0, i1);
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateLineStrip() {
      int nInVert = in.vertexCount;
      if ((stroke) && (2 <= nInVert)) {
        strokeVertices = in.vertices;
        strokeColors = in.strokeColors;
        strokeWeights = in.strokeWeights;
        updateTex();
        int lineCount = nInVert - 1;
        if (is3D) {
          tessellateLineStrip3D(lineCount);
        } else if (is2D) {
          beginNoTex();
          tessellateLineStrip2D(lineCount);
          endNoTex();
        }
      }
    }
    
    void tessellateLineStrip3D(int lineCount) {
      int nBevelTr = noCapsJoins() ? 0 : lineCount - 1;
      int nvert = lineCount * 4 + nBevelTr * 3;
      int nind = lineCount * 2 * 3 + nBevelTr * 2 * 3;
      
      int vcount0 = tess.lineVertexCount;
      int icount0 = tess.lineIndexCount;
      tess.lineVertexCheck(nvert);
      tess.lineIndexCheck(nind);
      int index = in.renderMode == 1 ? tess.lineIndexCache.addNew() : 
        tess.lineIndexCache.getLast();
      firstLineIndexCache = index;
      int i0 = 0;
      short[] lastInd = { -1, -1 };
      int[] tmp = new int[2];
      tess.lineIndexCache.setCounter(tmp);
      for (int ln = 0; ln < lineCount; ln++) {
        int i1 = ln + 1;
        if (nBevelTr > 0) {
          index = addLineSegment3D(i0, i1, i1 - 2, i1 - 1, index, lastInd, false);
        } else {
          index = addLineSegment3D(i0, i1, i1 - 2, i1 - 1, index, null, false);
        }
        i0 = i1;
      }
      
      tess.lineIndexCache.setCounter(null);
      tess.lineIndexCount = (icount0 + tmp[0]);
      tess.lineVertexCount = (vcount0 + tmp[1]);
      lastLineIndexCache = index;
    }
    
    void tessellateLineStrip2D(int lineCount) {
      int nvert = lineCount * 4;
      int nind = lineCount * 2 * 3;
      
      if (noCapsJoins(nvert)) {
        tess.polyVertexCheck(nvert);
        tess.polyIndexCheck(nind);
        int index = in.renderMode == 1 ? tess.polyIndexCache.addNew() : 
          tess.polyIndexCache.getLast();
        firstLineIndexCache = index;
        if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
        int i0 = 0;
        boolean clamp = clampLineStrip2D(lineCount);
        for (int ln = 0; ln < lineCount; ln++) {
          int i1 = ln + 1;
          index = addLineSegment2D(i0, i1, index, false, clamp);
          i0 = i1;
        }
        lastLineIndexCache = (this.lastPolyIndexCache = index);
      } else {
        LinePath path = new LinePath(1);
        path.moveTo(in.vertices[0], in.vertices[1], in.strokeColors[0]);
        for (int ln = 0; ln < lineCount; ln++) {
          int i1 = ln + 1;
          path.lineTo(in.vertices[(3 * i1 + 0)], in.vertices[(3 * i1 + 1)], 
            in.strokeColors[i1]);
        }
        tessellateLinePath(path);
      }
    }
    
    boolean clampLineStrip2D(int lineCount) {
      boolean res = clamp2D();
      if (res)
        for (int ln = 0; ln < lineCount; ln++) {
          res = segmentIsAxisAligned(0, ln + 1);
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateLineLoop() {
      int nInVert = in.vertexCount;
      if ((stroke) && (2 <= nInVert)) {
        strokeVertices = in.vertices;
        strokeColors = in.strokeColors;
        strokeWeights = in.strokeWeights;
        updateTex();
        int lineCount = nInVert;
        if (is3D) {
          tessellateLineLoop3D(lineCount);
        } else if (is2D) {
          beginNoTex();
          tessellateLineLoop2D(lineCount);
          endNoTex();
        }
      }
    }
    
    void tessellateLineLoop3D(int lineCount) {
      int nBevelTr = noCapsJoins() ? 0 : lineCount;
      int nvert = lineCount * 4 + nBevelTr * 3;
      int nind = lineCount * 2 * 3 + nBevelTr * 2 * 3;
      
      int vcount0 = tess.lineVertexCount;
      int icount0 = tess.lineIndexCount;
      tess.lineVertexCheck(nvert);
      tess.lineIndexCheck(nind);
      int index = in.renderMode == 1 ? tess.lineIndexCache.addNew() : 
        tess.lineIndexCache.getLast();
      firstLineIndexCache = index;
      int i0 = 0;
      int i1 = -1;
      short[] lastInd = { -1, -1 };
      int[] tmp = new int[2];
      tess.lineIndexCache.setCounter(tmp);
      for (int ln = 0; ln < lineCount - 1; ln++) {
        i1 = ln + 1;
        if (nBevelTr > 0) {
          index = addLineSegment3D(i0, i1, i1 - 2, i1 - 1, index, lastInd, false);
        } else {
          index = addLineSegment3D(i0, i1, i1 - 2, i1 - 1, index, null, false);
        }
        i0 = i1;
      }
      index = addLineSegment3D(in.vertexCount - 1, 0, i1 - 2, i1 - 1, index, lastInd, false);
      if (nBevelTr > 0) {
        index = addBevel3D(0, 1, in.vertexCount - 1, 0, index, lastInd, false);
      }
      
      tess.lineIndexCache.setCounter(null);
      tess.lineIndexCount = (icount0 + tmp[0]);
      tess.lineVertexCount = (vcount0 + tmp[1]);
      lastLineIndexCache = index;
    }
    
    void tessellateLineLoop2D(int lineCount) {
      int nvert = lineCount * 4;
      int nind = lineCount * 2 * 3;
      
      if (noCapsJoins(nvert)) {
        tess.polyVertexCheck(nvert);
        tess.polyIndexCheck(nind);
        int index = in.renderMode == 1 ? tess.polyIndexCache.addNew() : 
          tess.polyIndexCache.getLast();
        firstLineIndexCache = index;
        if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
        int i0 = 0;
        boolean clamp = clampLineLoop2D(lineCount);
        for (int ln = 0; ln < lineCount - 1; ln++) {
          int i1 = ln + 1;
          index = addLineSegment2D(i0, i1, index, false, clamp);
          i0 = i1;
        }
        index = addLineSegment2D(0, in.vertexCount - 1, index, false, clamp);
        lastLineIndexCache = (this.lastPolyIndexCache = index);
      } else {
        LinePath path = new LinePath(1);
        path.moveTo(in.vertices[0], in.vertices[1], in.strokeColors[0]);
        for (int ln = 0; ln < lineCount - 1; ln++) {
          int i1 = ln + 1;
          path.lineTo(in.vertices[(3 * i1 + 0)], in.vertices[(3 * i1 + 1)], 
            in.strokeColors[i1]);
        }
        path.closePath();
        tessellateLinePath(path);
      }
    }
    
    boolean clampLineLoop2D(int lineCount) {
      boolean res = clamp2D();
      if (res)
        for (int ln = 0; ln < lineCount; ln++) {
          res = segmentIsAxisAligned(0, ln + 1);
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateEdges() {
      if (stroke) {
        if (in.edgeCount == 0) return;
        strokeVertices = in.vertices;
        strokeColors = in.strokeColors;
        strokeWeights = in.strokeWeights;
        if (is3D) {
          tessellateEdges3D();
        } else if (is2D) {
          beginNoTex();
          tessellateEdges2D();
          endNoTex();
        }
      }
    }
    
    void tessellateEdges3D() {
      boolean bevel = !noCapsJoins();
      int nInVert = in.getNumEdgeVertices(bevel);
      int nInInd = in.getNumEdgeIndices(bevel);
      
      int vcount0 = tess.lineVertexCount;
      int icount0 = tess.lineIndexCount;
      tess.lineVertexCheck(nInVert);
      tess.lineIndexCheck(nInInd);
      int index = in.renderMode == 1 ? tess.lineIndexCache.addNew() : 
        tess.lineIndexCache.getLast();
      firstLineIndexCache = index;
      int fi0 = 0;
      int fi1 = 0;
      short[] lastInd = { -1, -1 };
      int pi0 = -1;
      int pi1 = -1;
      
      int[] tmp = new int[2];
      tess.lineIndexCache.setCounter(tmp);
      for (int i = 0; i <= in.edgeCount - 1; i++) {
        int[] edge = in.edges[i];
        int i0 = edge[0];
        int i1 = edge[1];
        if (bevel) {
          if (edge[2] == -1) {
            index = addBevel3D(fi0, fi1, pi0, pi1, index, lastInd, false);
          } else {
            index = addLineSegment3D(i0, i1, pi0, pi1, index, lastInd, false);
          }
        } else if (edge[2] != -1) {
          index = addLineSegment3D(i0, i1, pi0, pi1, index, null, false);
        }
        if (edge[2] == 1) {
          fi0 = i0;
          fi1 = i1;
        }
        
        if ((edge[2] == 2) || (edge[2] == 3) || (edge[2] == -1))
        {
          byte tmp308_307 = -1;lastInd[1] = tmp308_307;lastInd[0] = tmp308_307;
          pi1 = pi0 = -1;
        } else {
          pi0 = i0;
          pi1 = i1;
        }
      }
      
      tess.lineIndexCache.setCounter(null);
      tess.lineIndexCount = (icount0 + tmp[0]);
      tess.lineVertexCount = (vcount0 + tmp[1]);
      
      lastLineIndexCache = index;
    }
    
    void tessellateEdges2D() {
      int nInVert = in.getNumEdgeVertices(false);
      if (noCapsJoins(nInVert)) {
        int nInInd = in.getNumEdgeIndices(false);
        
        tess.polyVertexCheck(nInVert);
        tess.polyIndexCheck(nInInd);
        int index = in.renderMode == 1 ? tess.polyIndexCache.addNew() : 
          tess.polyIndexCache.getLast();
        firstLineIndexCache = index;
        if (firstPolyIndexCache == -1) firstPolyIndexCache = index;
        boolean clamp = clampEdges2D();
        for (int i = 0; i <= in.edgeCount - 1; i++) {
          int[] edge = in.edges[i];
          if (edge[2] != -1) {
            int i0 = edge[0];
            int i1 = edge[1];
            index = addLineSegment2D(i0, i1, index, false, clamp);
          } }
        lastLineIndexCache = (this.lastPolyIndexCache = index);
      } else {
        LinePath path = new LinePath(1);
        for (int i = 0; i <= in.edgeCount - 1; i++) {
          int[] edge = in.edges[i];
          int i0 = edge[0];
          int i1 = edge[1];
          switch (edge[2]) {
          case 0: 
            path.lineTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            break;
          case 1: 
            path.moveTo(strokeVertices[(3 * i0 + 0)], strokeVertices[(3 * i0 + 1)], 
              strokeColors[i0]);
            path.lineTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            break;
          case 2: 
            path.lineTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            path.moveTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            break;
          case 3: 
            path.moveTo(strokeVertices[(3 * i0 + 0)], strokeVertices[(3 * i0 + 1)], 
              strokeColors[i0]);
            path.lineTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            path.moveTo(strokeVertices[(3 * i1 + 0)], strokeVertices[(3 * i1 + 1)], 
              strokeColors[i1]);
            break;
          case -1: 
            path.closePath();
          }
          
        }
        tessellateLinePath(path);
      }
    }
    
    boolean clampEdges2D() {
      boolean res = clamp2D();
      if (res)
        for (int i = 0; i <= in.edgeCount - 1; i++) {
          int[] edge = in.edges[i];
          if (edge[2] != -1) {
            int i0 = edge[0];
            int i1 = edge[1];
            res = segmentIsAxisAligned(strokeVertices, i0, i1);
            if (!res) break;
          }
        }
      return res;
    }
    


    int addLineSegment3D(int i0, int i1, int pi0, int pi1, int index, short[] lastInd, boolean constStroke)
    {
      PGraphicsOpenGL.IndexCache cache = tess.lineIndexCache;
      int count = vertexCount[index];
      boolean addBevel = (lastInd != null) && (-1 < lastInd[0]) && (-1 < lastInd[1]);
      boolean newCache = false;
      if (PGL.MAX_VERTEX_INDEX1 <= count + 4 + (addBevel ? 1 : 0))
      {
        index = cache.addNew();
        count = 0;
        newCache = true;
      }
      int iidx = indexOffset[index] + indexCount[index];
      int vidx = vertexOffset[index] + vertexCount[index];
      


      int color0 = color = constStroke ? strokeColor : strokeColors[i0];
      float weight = constStroke ? strokeWeight : strokeWeights[i0];
      weight *= transformScale();
      
      tess.setLineVertex(vidx++, strokeVertices, i0, i1, color, weight / 2.0F);
      tess.lineIndices[(iidx++)] = ((short)(count + 0));
      
      tess.setLineVertex(vidx++, strokeVertices, i0, i1, color, -weight / 2.0F);
      tess.lineIndices[(iidx++)] = ((short)(count + 1));
      
      int color = constStroke ? strokeColor : strokeColors[i1];
      weight = constStroke ? strokeWeight : strokeWeights[i1];
      weight *= transformScale();
      
      tess.setLineVertex(vidx++, strokeVertices, i1, i0, color, -weight / 2.0F);
      tess.lineIndices[(iidx++)] = ((short)(count + 2));
      

      tess.lineIndices[(iidx++)] = ((short)(count + 2));
      tess.lineIndices[(iidx++)] = ((short)(count + 1));
      
      tess.setLineVertex(vidx++, strokeVertices, i1, i0, color, weight / 2.0F);
      tess.lineIndices[(iidx++)] = ((short)(count + 3));
      
      cache.incCounts(index, 6, 4);
      
      if (lastInd != null) {
        if ((-1 < lastInd[0]) && (-1 < lastInd[1]))
        {
          if (newCache) {
            if ((-1 < pi0) && (-1 < pi1))
            {

              color = constStroke ? strokeColor : strokeColors[pi0];
              weight = constStroke ? strokeWeight : strokeWeights[pi0];
              weight *= transformScale();
              
              tess.setLineVertex(vidx++, strokeVertices, pi1, color);
              tess.setLineVertex(vidx++, strokeVertices, pi1, pi0, color, -weight / 2.0F);
              tess.setLineVertex(vidx, strokeVertices, pi1, pi0, color, weight / 2.0F);
              
              tess.lineIndices[(iidx++)] = ((short)(count + 4));
              tess.lineIndices[(iidx++)] = ((short)(count + 5));
              tess.lineIndices[(iidx++)] = ((short)(count + 0));
              
              tess.lineIndices[(iidx++)] = ((short)(count + 4));
              tess.lineIndices[(iidx++)] = ((short)(count + 6));
              tess.lineIndices[iidx] = ((short)(count + 1));
              
              cache.incCounts(index, 6, 3);
            }
          } else {
            tess.setLineVertex(vidx, strokeVertices, i0, color0);
            
            tess.lineIndices[(iidx++)] = ((short)(count + 4));
            tess.lineIndices[(iidx++)] = lastInd[0];
            tess.lineIndices[(iidx++)] = ((short)(count + 0));
            
            tess.lineIndices[(iidx++)] = ((short)(count + 4));
            tess.lineIndices[(iidx++)] = lastInd[1];
            tess.lineIndices[iidx] = ((short)(count + 1));
            
            cache.incCounts(index, 6, 1);
          }
        }
        


        lastInd[0] = ((short)(count + 2));
        lastInd[1] = ((short)(count + 3));
      }
      return index;
    }
    
    int addBevel3D(int fi0, int fi1, int pi0, int pi1, int index, short[] lastInd, boolean constStroke)
    {
      PGraphicsOpenGL.IndexCache cache = tess.lineIndexCache;
      int count = vertexCount[index];
      boolean newCache = false;
      if (PGL.MAX_VERTEX_INDEX1 <= count + 3)
      {
        index = cache.addNew();
        count = 0;
        newCache = true;
      }
      
      int iidx = indexOffset[index] + indexCount[index];
      int vidx = vertexOffset[index] + vertexCount[index];
      int color = constStroke ? strokeColor : strokeColors[fi0];
      float weight = constStroke ? strokeWeight : strokeWeights[fi0];
      weight *= transformScale();
      
      tess.setLineVertex(vidx++, strokeVertices, fi0, color);
      tess.setLineVertex(vidx++, strokeVertices, fi0, fi1, color, weight / 2.0F);
      tess.setLineVertex(vidx++, strokeVertices, fi0, fi1, color, -weight / 2.0F);
      
      int extra = 0;
      if ((newCache) && (-1 < pi0) && (-1 < pi1))
      {

        color = constStroke ? strokeColor : strokeColors[pi1];
        weight = constStroke ? strokeWeight : strokeWeights[pi1];
        weight *= transformScale();
        
        tess.setLineVertex(vidx++, strokeVertices, pi1, pi0, color, -weight / 2.0F);
        tess.setLineVertex(vidx, strokeVertices, pi1, pi0, color, weight / 2.0F);
        
        lastInd[0] = ((short)(count + 3));
        lastInd[1] = ((short)(count + 4));
        extra = 2;
      }
      
      tess.lineIndices[(iidx++)] = ((short)(count + 0));
      tess.lineIndices[(iidx++)] = lastInd[0];
      tess.lineIndices[(iidx++)] = ((short)(count + 1));
      
      tess.lineIndices[(iidx++)] = ((short)(count + 0));
      tess.lineIndices[(iidx++)] = ((short)(count + 2));
      tess.lineIndices[iidx] = lastInd[1];
      
      cache.incCounts(index, 6, 3 + extra);
      
      return index;
    }
    



    int addLineSegment2D(int i0, int i1, int index, boolean constStroke, boolean clamp)
    {
      PGraphicsOpenGL.IndexCache cache = tess.polyIndexCache;
      int count = vertexCount[index];
      if (PGL.MAX_VERTEX_INDEX1 <= count + 4)
      {
        index = cache.addNew();
        count = 0;
      }
      int iidx = indexOffset[index] + indexCount[index];
      int vidx = vertexOffset[index] + vertexCount[index];
      
      int color = constStroke ? strokeColor : strokeColors[i0];
      float weight = constStroke ? strokeWeight : strokeWeights[i0];
      if (subPixelStroke(weight)) { clamp = false;
      }
      float x0 = strokeVertices[(3 * i0 + 0)];
      float y0 = strokeVertices[(3 * i0 + 1)];
      
      float x1 = strokeVertices[(3 * i1 + 0)];
      float y1 = strokeVertices[(3 * i1 + 1)];
      

      float dirx = x1 - x0;
      float diry = y1 - y0;
      float llen = PApplet.sqrt(dirx * dirx + diry * diry);
      float normx = 0.0F;float normy = 0.0F;
      float dirdx = 0.0F;float dirdy = 0.0F;
      if (PGraphicsOpenGL.nonZero(llen)) {
        normx = -diry / llen;
        normy = dirx / llen;
        





        dirdx = dirx / llen * PApplet.min(0.75F, weight / 2.0F);
        dirdy = diry / llen * PApplet.min(0.75F, weight / 2.0F);
      }
      
      float normdx = normx * weight / 2.0F;
      float normdy = normy * weight / 2.0F;
      
      tess.setPolyVertex(vidx++, x0 + normdx - dirdx, y0 + normdy - dirdy, 
        0.0F, color, clamp);
      tess.polyIndices[(iidx++)] = ((short)(count + 0));
      
      tess.setPolyVertex(vidx++, x0 - normdx - dirdx, y0 - normdy - dirdy, 
        0.0F, color, clamp);
      tess.polyIndices[(iidx++)] = ((short)(count + 1));
      
      if (clamp)
      {
        float xac = tess.polyVertices[(4 * (vidx - 2) + 0)];
        float yac = tess.polyVertices[(4 * (vidx - 2) + 1)];
        float xbc = tess.polyVertices[(4 * (vidx - 1) + 0)];
        float ybc = tess.polyVertices[(4 * (vidx - 1) + 1)];
        if ((PGraphicsOpenGL.same(xac, xbc)) && (PGraphicsOpenGL.same(yac, ybc))) {
          unclampLine2D(vidx - 2, x0 + normdx - dirdx, y0 + normdy - dirdy);
          unclampLine2D(vidx - 1, x0 - normdx - dirdx, y0 - normdy - dirdy);
        }
      }
      
      if (!constStroke) {
        color = strokeColors[i1];
        weight = strokeWeights[i1];
        normdx = normx * weight / 2.0F;
        normdy = normy * weight / 2.0F;
        if (subPixelStroke(weight)) { clamp = false;
        }
      }
      tess.setPolyVertex(vidx++, x1 - normdx + dirdx, y1 - normdy + dirdy, 
        0.0F, color, clamp);
      tess.polyIndices[(iidx++)] = ((short)(count + 2));
      

      tess.polyIndices[(iidx++)] = ((short)(count + 2));
      tess.polyIndices[(iidx++)] = ((short)(count + 0));
      
      tess.setPolyVertex(vidx++, x1 + normdx + dirdx, y1 + normdy + dirdy, 
        0.0F, color, clamp);
      tess.polyIndices[(iidx++)] = ((short)(count + 3));
      
      if (clamp)
      {
        float xac = tess.polyVertices[(4 * (vidx - 2) + 0)];
        float yac = tess.polyVertices[(4 * (vidx - 2) + 1)];
        float xbc = tess.polyVertices[(4 * (vidx - 1) + 0)];
        float ybc = tess.polyVertices[(4 * (vidx - 1) + 1)];
        if ((PGraphicsOpenGL.same(xac, xbc)) && (PGraphicsOpenGL.same(yac, ybc))) {
          unclampLine2D(vidx - 2, x1 - normdx + dirdx, y1 - normdy + dirdy);
          unclampLine2D(vidx - 1, x1 + normdx + dirdx, y1 + normdy + dirdy);
        }
      }
      
      cache.incCounts(index, 6, 4);
      return index;
    }
    
    void unclampLine2D(int tessIdx, float x, float y) {
      PMatrix3D mm = pg.modelview;
      int index = 4 * tessIdx;
      tess.polyVertices[(index++)] = (x * m00 + y * m01 + m03);
      tess.polyVertices[(index++)] = (x * m10 + y * m11 + m13);
    }
    
    boolean noCapsJoins(int nInVert) {
      if (!accurate2DStrokes)
        return true;
      if (PGL.MAX_CAPS_JOINS_LENGTH <= nInVert)
      {

        return true;
      }
      return noCapsJoins();
    }
    
    boolean subPixelStroke(float weight)
    {
      float sw = transformScale() * weight;
      return PApplet.abs(sw - (int)sw) > 0.0F;
    }
    

    boolean noCapsJoins()
    {
      return (tess.renderMode == 0) && (
        transformScale() * strokeWeight < PGL.MIN_CAPS_JOINS_WEIGHT);
    }
    
    float transformScale() {
      if (-1.0F < transformScale) return transformScale;
      return this.transformScale = PGraphicsOpenGL.matrixScale(transform);
    }
    
    boolean segmentIsAxisAligned(int i0, int i1) {
      return (PGraphicsOpenGL.zero(in.vertices[(3 * i0 + 0)] - in.vertices[(3 * i1 + 0)])) || 
        (PGraphicsOpenGL.zero(in.vertices[(3 * i0 + 1)] - in.vertices[(3 * i1 + 1)]));
    }
    
    boolean segmentIsAxisAligned(float[] vertices, int i0, int i1) {
      return (PGraphicsOpenGL.zero(vertices[(3 * i0 + 0)] - vertices[(3 * i1 + 0)])) || 
        (PGraphicsOpenGL.zero(vertices[(3 * i0 + 1)] - vertices[(3 * i1 + 1)]));
    }
    



    void tessellateTriangles()
    {
      beginTex();
      int nTri = in.vertexCount / 3;
      if ((fill) && (1 <= nTri)) {
        int nInInd = 3 * nTri;
        setRawSize(nInInd);
        int idx = 0;
        boolean clamp = clampTriangles();
        for (int i = 0; i < 3 * nTri; i++) {
          rawIndices[(idx++)] = i;
        }
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampTriangles() {
      boolean res = clamp2D();
      if (res) {
        int nTri = in.vertexCount / 3;
        for (int i = 0; i < nTri; i++) {
          int i0 = 3 * i + 0;
          int i1 = 3 * i + 1;
          int i2 = 3 * i + 2;
          int count = 0;
          if (segmentIsAxisAligned(i0, i1)) count++;
          if (segmentIsAxisAligned(i0, i2)) count++;
          if (segmentIsAxisAligned(i1, i2)) count++;
          res = 1 < count;
          if (!res) break;
        }
      }
      return res;
    }
    
    void tessellateTriangles(int[] indices) {
      beginTex();
      int nInVert = in.vertexCount;
      if ((fill) && (3 <= nInVert)) {
        int nInInd = indices.length;
        setRawSize(nInInd);
        PApplet.arrayCopy(indices, rawIndices, nInInd);
        boolean clamp = clampTriangles(indices);
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampTriangles(int[] indices) {
      boolean res = clamp2D();
      if (res) {
        int nTri = indices.length;
        for (int i = 0; i < nTri; i++) {
          int i0 = indices[(3 * i + 0)];
          int i1 = indices[(3 * i + 1)];
          int i2 = indices[(3 * i + 2)];
          int count = 0;
          if (segmentIsAxisAligned(i0, i1)) count++;
          if (segmentIsAxisAligned(i0, i2)) count++;
          if (segmentIsAxisAligned(i1, i2)) count++;
          res = 1 < count;
          if (!res) break;
        }
      }
      return res;
    }
    
    void tessellateTriangleFan() {
      beginTex();
      int nInVert = in.vertexCount;
      if ((fill) && (3 <= nInVert)) {
        int nInInd = 3 * (nInVert - 2);
        setRawSize(nInInd);
        int idx = 0;
        boolean clamp = clampTriangleFan();
        for (int i = 1; i < in.vertexCount - 1; i++) {
          rawIndices[(idx++)] = 0;
          rawIndices[(idx++)] = i;
          rawIndices[(idx++)] = (i + 1);
        }
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampTriangleFan() {
      boolean res = clamp2D();
      if (res)
        for (int i = 1; i < in.vertexCount - 1; i++) {
          int i0 = 0;
          int i1 = i;
          int i2 = i + 1;
          int count = 0;
          if (segmentIsAxisAligned(i0, i1)) count++;
          if (segmentIsAxisAligned(i0, i2)) count++;
          if (segmentIsAxisAligned(i1, i2)) count++;
          res = 1 < count;
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateTriangleStrip() {
      beginTex();
      int nInVert = in.vertexCount;
      if ((fill) && (3 <= nInVert)) {
        int nInInd = 3 * (nInVert - 2);
        setRawSize(nInInd);
        int idx = 0;
        boolean clamp = clampTriangleStrip();
        for (int i = 1; i < in.vertexCount - 1; i++) {
          rawIndices[(idx++)] = i;
          if (i % 2 == 0) {
            rawIndices[(idx++)] = (i - 1);
            rawIndices[(idx++)] = (i + 1);
          } else {
            rawIndices[(idx++)] = (i + 1);
            rawIndices[(idx++)] = (i - 1);
          }
        }
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampTriangleStrip() {
      boolean res = clamp2D();
      if (res)
        for (int i = 1; i < in.vertexCount - 1; i++) {
          int i0 = i;
          int i2;
          int i1; int i2; if (i % 2 == 0) {
            int i1 = i - 1;
            i2 = i + 1;
          } else {
            i1 = i + 1;
            i2 = i - 1;
          }
          int count = 0;
          if (segmentIsAxisAligned(i0, i1)) count++;
          if (segmentIsAxisAligned(i0, i2)) count++;
          if (segmentIsAxisAligned(i1, i2)) count++;
          res = 1 < count;
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateQuads() {
      beginTex();
      int quadCount = in.vertexCount / 4;
      if ((fill) && (1 <= quadCount)) {
        int nInInd = 6 * quadCount;
        setRawSize(nInInd);
        int idx = 0;
        boolean clamp = clampQuads(quadCount);
        for (int qd = 0; qd < quadCount; qd++) {
          int i0 = 4 * qd + 0;
          int i1 = 4 * qd + 1;
          int i2 = 4 * qd + 2;
          int i3 = 4 * qd + 3;
          
          rawIndices[(idx++)] = i0;
          rawIndices[(idx++)] = i1;
          rawIndices[(idx++)] = i2;
          
          rawIndices[(idx++)] = i2;
          rawIndices[(idx++)] = i3;
          rawIndices[(idx++)] = i0;
        }
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampQuads(int quadCount) {
      boolean res = clamp2D();
      if (res)
        for (int qd = 0; qd < quadCount; qd++) {
          int i0 = 4 * qd + 0;
          int i1 = 4 * qd + 1;
          int i2 = 4 * qd + 2;
          int i3 = 4 * qd + 3;
          res = (segmentIsAxisAligned(i0, i1)) && 
            (segmentIsAxisAligned(i1, i2)) && 
            (segmentIsAxisAligned(i2, i3));
          if (!res)
            break;
        }
      return res;
    }
    
    void tessellateQuadStrip() {
      beginTex();
      int quadCount = in.vertexCount / 2 - 1;
      if ((fill) && (1 <= quadCount)) {
        int nInInd = 6 * quadCount;
        setRawSize(nInInd);
        int idx = 0;
        boolean clamp = clampQuadStrip(quadCount);
        for (int qd = 1; qd < quadCount + 1; qd++) {
          int i0 = 2 * (qd - 1);
          int i1 = 2 * (qd - 1) + 1;
          int i2 = 2 * qd + 1;
          int i3 = 2 * qd;
          
          rawIndices[(idx++)] = i0;
          rawIndices[(idx++)] = i1;
          rawIndices[(idx++)] = i3;
          
          rawIndices[(idx++)] = i1;
          rawIndices[(idx++)] = i2;
          rawIndices[(idx++)] = i3;
        }
        splitRawIndices(clamp);
      }
      endTex();
      tessellateEdges();
    }
    
    boolean clampQuadStrip(int quadCount) {
      boolean res = clamp2D();
      if (res)
        for (int qd = 1; qd < quadCount + 1; qd++) {
          int i0 = 2 * (qd - 1);
          int i1 = 2 * (qd - 1) + 1;
          int i2 = 2 * qd + 1;
          int i3 = 2 * qd;
          res = (segmentIsAxisAligned(i0, i1)) && 
            (segmentIsAxisAligned(i1, i2)) && 
            (segmentIsAxisAligned(i2, i3));
          if (!res)
            break;
        }
      return res;
    }
    















    void splitRawIndices(boolean clamp)
    {
      tess.polyIndexCheck(rawSize);
      int offset = tess.firstPolyIndex;
      

      int inInd0 = 0;int inInd1 = 0;
      int inMaxVert0 = 0;int inMaxVert1 = 0;
      
      int inMaxVertRef = inMaxVert0;
      int inMaxVertRel = -1;
      
      dupCount = 0;
      
      PGraphicsOpenGL.IndexCache cache = tess.polyIndexCache;
      


      int index = in.renderMode == 1 ? cache.addNew() : cache.getLast();
      firstPolyIndexCache = index;
      
      int trCount = rawSize / 3;
      for (int tr = 0; tr < trCount; tr++) {
        if (index == -1) { index = cache.addNew();
        }
        int i0 = rawIndices[(3 * tr + 0)];
        int i1 = rawIndices[(3 * tr + 1)];
        int i2 = rawIndices[(3 * tr + 2)];
        

        int ii0 = i0 - inMaxVertRef;
        int ii1 = i1 - inMaxVertRef;
        int ii2 = i2 - inMaxVertRef;
        

        int count = vertexCount[index];
        int ri0;
        int ri0; if (ii0 < 0) {
          addDupIndex(ii0);
          ri0 = ii0;
        } else { ri0 = count + ii0; }
        int ri1; int ri1; if (ii1 < 0) {
          addDupIndex(ii1);
          ri1 = ii1;
        } else { ri1 = count + ii1; }
        int ri2; int ri2; if (ii2 < 0) {
          addDupIndex(ii2);
          ri2 = ii2;
        } else { ri2 = count + ii2;
        }
        tess.polyIndices[(offset + 3 * tr + 0)] = ((short)ri0);
        tess.polyIndices[(offset + 3 * tr + 1)] = ((short)ri1);
        tess.polyIndices[(offset + 3 * tr + 2)] = ((short)ri2);
        
        inInd1 = 3 * tr + 2;
        inMaxVert1 = PApplet.max(inMaxVert1, PApplet.max(i0, i1, i2));
        inMaxVert0 = PApplet.min(inMaxVert0, PApplet.min(i0, i1, i2));
        
        inMaxVertRel = PApplet.max(inMaxVertRel, PApplet.max(ri0, ri1, ri2));
        
        if (((PGL.MAX_VERTEX_INDEX1 - 3 <= inMaxVertRel + dupCount) && 
          (inMaxVertRel + dupCount < PGL.MAX_VERTEX_INDEX1)) || 
          (tr == trCount - 1))
        {



          int nondupCount = 0;
          if (dupCount > 0)
          {

            for (int i = inInd0; i <= inInd1; i++) {
              int ri = tess.polyIndices[(offset + i)];
              if (ri < 0) {
                tess.polyIndices[(offset + i)] = 
                  ((short)(inMaxVertRel + 1 + dupIndexPos(ri)));
              }
            }
            
            if (inMaxVertRef <= inMaxVert1)
            {
              tess.addPolyVertices(in, inMaxVertRef, inMaxVert1, clamp);
              nondupCount = inMaxVert1 - inMaxVertRef + 1;
            }
            

            for (int i = 0; i < dupCount; i++) {
              tess.addPolyVertex(in, dupIndices[i] + inMaxVertRef, clamp);
            }
          }
          else {
            tess.addPolyVertices(in, inMaxVert0, inMaxVert1, clamp);
            nondupCount = inMaxVert1 - inMaxVert0 + 1;
          }
          

          cache.incCounts(index, inInd1 - inInd0 + 1, nondupCount + dupCount);
          lastPolyIndexCache = index;
          

          index = -1;
          inMaxVertRel = -1;
          inMaxVertRef = inMaxVert1 + 1;
          inMaxVert0 = inMaxVertRef;
          inInd0 = inInd1 + 1;
          if (dupIndices != null) Arrays.fill(dupIndices, 0, dupCount, 0);
          dupCount = 0;
        }
      }
    }
    
    void addDupIndex(int idx) {
      if (dupIndices == null) {
        dupIndices = new int[16];
      }
      if (dupIndices.length == dupCount) {
        int n = dupCount << 1;
        
        int[] temp = new int[n];
        PApplet.arrayCopy(dupIndices, 0, temp, 0, dupCount);
        dupIndices = temp;
      }
      
      if (idx < dupIndices[0])
      {
        for (int i = dupCount; i > 0; i--) dupIndices[i] = dupIndices[(i - 1)];
        dupIndices[0] = idx;
        dupCount += 1;
      } else if (dupIndices[(dupCount - 1)] < idx)
      {
        dupIndices[dupCount] = idx;
        dupCount += 1;
      } else {
        for (int i = 0; i < dupCount - 1; i++) {
          if (dupIndices[i] == idx) break;
          if ((dupIndices[i] < idx) && (idx < dupIndices[(i + 1)]))
          {
            for (int j = dupCount; j > i + 1; j--) {
              dupIndices[j] = dupIndices[(j - 1)];
            }
            dupIndices[(i + 1)] = idx;
            dupCount += 1;
            break;
          }
        }
      }
    }
    
    int dupIndexPos(int idx) {
      for (int i = 0; i < dupCount; i++) {
        if (dupIndices[i] == idx) return i;
      }
      return 0;
    }
    
    void setRawSize(int size) {
      int size0 = rawIndices.length;
      if (size0 < size) {
        int size1 = PGraphicsOpenGL.expandArraySize(size0, size);
        expandRawIndices(size1);
      }
      rawSize = size;
    }
    
    void expandRawIndices(int n) {
      int[] temp = new int[n];
      PApplet.arrayCopy(rawIndices, 0, temp, 0, rawSize);
      rawIndices = temp;
    }
    
    void beginTex() {
      setFirstTexIndex(tess.polyIndexCount, tess.polyIndexCache.size - 1);
    }
    
    void endTex() {
      setLastTexIndex(tess.lastPolyIndex, tess.polyIndexCache.size - 1);
    }
    
    void beginNoTex() {
      newTexImage = null;
      setFirstTexIndex(tess.polyIndexCount, tess.polyIndexCache.size - 1);
    }
    
    void endNoTex() {
      setLastTexIndex(tess.lastPolyIndex, tess.polyIndexCache.size - 1);
    }
    
    void updateTex() {
      beginTex();
      endTex();
    }
    
    void setFirstTexIndex(int firstIndex, int firstCache) {
      if (texCache != null) {
        firstTexIndex = firstIndex;
        firstTexCache = PApplet.max(0, firstCache);
      }
    }
    
    void setLastTexIndex(int lastIndex, int lastCache) {
      if (texCache != null) {
        if ((prevTexImage != newTexImage) || (texCache.size == 0)) {
          texCache.addTexture(newTexImage, firstTexIndex, firstTexCache, 
            lastIndex, lastCache);
        } else {
          texCache.setLastIndex(lastIndex, lastCache);
        }
        prevTexImage = newTexImage;
      }
    }
    



    void tessellatePolygon(boolean solid, boolean closed, boolean calcNormals)
    {
      beginTex();
      
      int nInVert = in.vertexCount;
      
      if (3 <= nInVert) {
        firstPolyIndexCache = -1;
        
        initGluTess();
        boolean clamp = clampPolygon();
        callback.init(in.renderMode == 1, false, calcNormals, clamp);
        
        if (fill) {
          gluTess.beginPolygon();
          if (solid)
          {
            gluTess.setWindingRule(PGL.TESS_WINDING_NONZERO);
          }
          else {
            gluTess.setWindingRule(PGL.TESS_WINDING_ODD);
          }
          gluTess.beginContour();
        }
        
        if (stroke) {
          beginPolygonStroke();
          beginStrokePath();
        }
        
        int i = 0;
        int c = 0;
        while (i < in.vertexCount) {
          int code = 0;
          boolean brk = false;
          if ((in.codes != null) && (c < in.codeCount)) {
            code = in.codes[(c++)];
            if ((code == 4) && (c < in.codeCount)) {
              brk = true;
              code = in.codes[(c++)];
            }
          }
          
          if (brk) {
            if (stroke) {
              endStrokePath(closed);
              beginStrokePath();
            }
            if (fill) {
              gluTess.endContour();
              gluTess.beginContour();
            }
          }
          
          if (code == 1) {
            addBezierVertex(i);
            i += 3;
          } else if (code == 2) {
            addQuadraticVertex(i);
            i += 2;
          } else if (code == 3) {
            addCurveVertex(i);
            i++;
          } else {
            addVertex(i);
            i++;
          }
        }
        if (stroke) {
          endStrokePath(closed);
          endPolygonStroke();
        }
        if (fill) {
          gluTess.endContour();
          gluTess.endPolygon();
        }
      }
      endTex();
      
      if (stroke) tessellateStrokePath();
    }
    
    void addBezierVertex(int i) {
      pg.curveVertexCount = 0;
      pg.bezierInitCheck();
      pg.bezierVertexCheck(20, i);
      
      PMatrix3D draw = pg.bezierDrawMatrix;
      
      int i1 = i - 1;
      float x1 = in.vertices[(3 * i1 + 0)];
      float y1 = in.vertices[(3 * i1 + 1)];
      float z1 = in.vertices[(3 * i1 + 2)];
      
      int strokeColor = 0;
      float strokeWeight = 0.0F;
      if (stroke) {
        strokeColor = in.strokeColors[i];
        strokeWeight = in.strokeWeights[i];
      }
      
      double[] vertexT = fill ? collectVertexAttributes(i) : null;
      
      float x2 = in.vertices[(3 * i + 0)];
      float y2 = in.vertices[(3 * i + 1)];
      float z2 = in.vertices[(3 * i + 2)];
      float x3 = in.vertices[(3 * (i + 1) + 0)];
      float y3 = in.vertices[(3 * (i + 1) + 1)];
      float z3 = in.vertices[(3 * (i + 1) + 2)];
      float x4 = in.vertices[(3 * (i + 2) + 0)];
      float y4 = in.vertices[(3 * (i + 2) + 1)];
      float z4 = in.vertices[(3 * (i + 2) + 2)];
      
      float xplot1 = m10 * x1 + m11 * x2 + m12 * x3 + m13 * x4;
      float xplot2 = m20 * x1 + m21 * x2 + m22 * x3 + m23 * x4;
      float xplot3 = m30 * x1 + m31 * x2 + m32 * x3 + m33 * x4;
      
      float yplot1 = m10 * y1 + m11 * y2 + m12 * y3 + m13 * y4;
      float yplot2 = m20 * y1 + m21 * y2 + m22 * y3 + m23 * y4;
      float yplot3 = m30 * y1 + m31 * y2 + m32 * y3 + m33 * y4;
      
      float zplot1 = m10 * z1 + m11 * z2 + m12 * z3 + m13 * z4;
      float zplot2 = m20 * z1 + m21 * z2 + m22 * z3 + m23 * z4;
      float zplot3 = m30 * z1 + m31 * z2 + m32 * z3 + m33 * z4;
      
      for (int j = 0; j < pg.bezierDetail; j++) {
        x1 += xplot1;xplot1 += xplot2;xplot2 += xplot3;
        y1 += yplot1;yplot1 += yplot2;yplot2 += yplot3;
        z1 += zplot1;zplot1 += zplot2;zplot2 += zplot3;
        if (fill) {
          double[] vertex = Arrays.copyOf(vertexT, vertexT.length);
          vertex[0] = x1;
          vertex[1] = y1;
          vertex[2] = z1;
          gluTess.addVertex(vertex);
        }
        if (stroke) addStrokeVertex(x1, y1, z1, strokeColor, strokeWeight);
      }
    }
    
    void addQuadraticVertex(int i) {
      pg.curveVertexCount = 0;
      pg.bezierInitCheck();
      pg.bezierVertexCheck(20, i);
      
      PMatrix3D draw = pg.bezierDrawMatrix;
      
      int i1 = i - 1;
      float x1 = in.vertices[(3 * i1 + 0)];
      float y1 = in.vertices[(3 * i1 + 1)];
      float z1 = in.vertices[(3 * i1 + 2)];
      
      int strokeColor = 0;
      float strokeWeight = 0.0F;
      if (stroke) {
        strokeColor = in.strokeColors[i];
        strokeWeight = in.strokeWeights[i];
      }
      
      double[] vertexT = fill ? collectVertexAttributes(i) : null;
      
      float cx = in.vertices[(3 * i + 0)];
      float cy = in.vertices[(3 * i + 1)];
      float cz = in.vertices[(3 * i + 2)];
      float x = in.vertices[(3 * (i + 1) + 0)];
      float y = in.vertices[(3 * (i + 1) + 1)];
      float z = in.vertices[(3 * (i + 1) + 2)];
      
      float x2 = x1 + (cx - x1) * 2.0F / 3.0F;
      float y2 = y1 + (cy - y1) * 2.0F / 3.0F;
      float z2 = z1 + (cz - z1) * 2.0F / 3.0F;
      float x3 = x + (cx - x) * 2.0F / 3.0F;
      float y3 = y + (cy - y) * 2.0F / 3.0F;
      float z3 = z + (cz - z) * 2.0F / 3.0F;
      float x4 = x;
      float y4 = y;
      float z4 = z;
      
      float xplot1 = m10 * x1 + m11 * x2 + m12 * x3 + m13 * x4;
      float xplot2 = m20 * x1 + m21 * x2 + m22 * x3 + m23 * x4;
      float xplot3 = m30 * x1 + m31 * x2 + m32 * x3 + m33 * x4;
      
      float yplot1 = m10 * y1 + m11 * y2 + m12 * y3 + m13 * y4;
      float yplot2 = m20 * y1 + m21 * y2 + m22 * y3 + m23 * y4;
      float yplot3 = m30 * y1 + m31 * y2 + m32 * y3 + m33 * y4;
      
      float zplot1 = m10 * z1 + m11 * z2 + m12 * z3 + m13 * z4;
      float zplot2 = m20 * z1 + m21 * z2 + m22 * z3 + m23 * z4;
      float zplot3 = m30 * z1 + m31 * z2 + m32 * z3 + m33 * z4;
      
      for (int j = 0; j < pg.bezierDetail; j++) {
        x1 += xplot1;xplot1 += xplot2;xplot2 += xplot3;
        y1 += yplot1;yplot1 += yplot2;yplot2 += yplot3;
        z1 += zplot1;zplot1 += zplot2;zplot2 += zplot3;
        if (fill) {
          double[] vertex = Arrays.copyOf(vertexT, vertexT.length);
          vertex[0] = x1;
          vertex[1] = y1;
          vertex[2] = z1;
          gluTess.addVertex(vertex);
        }
        if (stroke) addStrokeVertex(x1, y1, z1, strokeColor, strokeWeight);
      }
    }
    
    void addCurveVertex(int i) {
      pg.curveVertexCheck(20);
      
      float[] vertex = pg.curveVertices[pg.curveVertexCount];
      vertex[0] = in.vertices[(3 * i + 0)];
      vertex[1] = in.vertices[(3 * i + 1)];
      vertex[2] = in.vertices[(3 * i + 2)];
      pg.curveVertexCount += 1;
      

      if (pg.curveVertexCount == 3) {
        float[] v = pg.curveVertices[(pg.curveVertexCount - 2)];
        addCurveInitialVertex(i, v[0], v[1], v[2]);
      }
      if (pg.curveVertexCount > 3) {
        float[] v1 = pg.curveVertices[(pg.curveVertexCount - 4)];
        float[] v2 = pg.curveVertices[(pg.curveVertexCount - 3)];
        float[] v3 = pg.curveVertices[(pg.curveVertexCount - 2)];
        float[] v4 = pg.curveVertices[(pg.curveVertexCount - 1)];
        addCurveVertexSegment(i, v1[0], v1[1], v1[2], 
          v2[0], v2[1], v2[2], 
          v3[0], v3[1], v3[2], 
          v4[0], v4[1], v4[2]);
      }
    }
    
    void addCurveInitialVertex(int i, float x, float y, float z) {
      if (fill) {
        double[] vertex0 = collectVertexAttributes(i);
        vertex0[0] = x;
        vertex0[1] = y;
        vertex0[2] = z;
        gluTess.addVertex(vertex0);
      }
      if (stroke) {
        addStrokeVertex(x, y, z, in.strokeColors[i], strokeWeight);
      }
    }
    


    void addCurveVertexSegment(int i, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4)
    {
      int strokeColor = 0;
      float strokeWeight = 0.0F;
      if (stroke) {
        strokeColor = in.strokeColors[i];
        strokeWeight = in.strokeWeights[i];
      }
      
      double[] vertexT = fill ? collectVertexAttributes(i) : null;
      
      float x = x2;
      float y = y2;
      float z = z2;
      
      PMatrix3D draw = pg.curveDrawMatrix;
      
      float xplot1 = m10 * x1 + m11 * x2 + m12 * x3 + m13 * x4;
      float xplot2 = m20 * x1 + m21 * x2 + m22 * x3 + m23 * x4;
      float xplot3 = m30 * x1 + m31 * x2 + m32 * x3 + m33 * x4;
      
      float yplot1 = m10 * y1 + m11 * y2 + m12 * y3 + m13 * y4;
      float yplot2 = m20 * y1 + m21 * y2 + m22 * y3 + m23 * y4;
      float yplot3 = m30 * y1 + m31 * y2 + m32 * y3 + m33 * y4;
      
      float zplot1 = m10 * z1 + m11 * z2 + m12 * z3 + m13 * z4;
      float zplot2 = m20 * z1 + m21 * z2 + m22 * z3 + m23 * z4;
      float zplot3 = m30 * z1 + m31 * z2 + m32 * z3 + m33 * z4;
      
      for (int j = 0; j < pg.curveDetail; j++) {
        x += xplot1;xplot1 += xplot2;xplot2 += xplot3;
        y += yplot1;yplot1 += yplot2;yplot2 += yplot3;
        z += zplot1;zplot1 += zplot2;zplot2 += zplot3;
        if (fill) {
          double[] vertex1 = Arrays.copyOf(vertexT, vertexT.length);
          vertex1[0] = x;
          vertex1[1] = y;
          vertex1[2] = z;
          gluTess.addVertex(vertex1);
        }
        if (stroke) addStrokeVertex(x, y, z, strokeColor, strokeWeight);
      }
    }
    
    void addVertex(int i) {
      pg.curveVertexCount = 0;
      
      float x = in.vertices[(3 * i + 0)];
      float y = in.vertices[(3 * i + 1)];
      float z = in.vertices[(3 * i + 2)];
      
      if (fill) {
        double[] vertex = collectVertexAttributes(i);
        vertex[0] = x;
        vertex[1] = y;
        vertex[2] = z;
        gluTess.addVertex(vertex);
      }
      if (stroke) {
        addStrokeVertex(x, y, z, in.strokeColors[i], in.strokeWeights[i]);
      }
    }
    


    double[] collectVertexAttributes(int i)
    {
      double[] avect = in.getAttribVector(i);
      
      double[] r = new double[25 + avect.length];
      
      int j = 3;
      
      int fcol = in.colors[i];
      r[(j++)] = (fcol >> 24 & 0xFF);
      r[(j++)] = (fcol >> 16 & 0xFF);
      r[(j++)] = (fcol >> 8 & 0xFF);
      r[(j++)] = (fcol >> 0 & 0xFF);
      
      r[(j++)] = in.normals[(3 * i + 0)];
      r[(j++)] = in.normals[(3 * i + 1)];
      r[(j++)] = in.normals[(3 * i + 2)];
      
      r[(j++)] = in.texcoords[(2 * i + 0)];
      r[(j++)] = in.texcoords[(2 * i + 1)];
      
      int acol = in.ambient[i];
      r[(j++)] = (acol >> 24 & 0xFF);
      r[(j++)] = (acol >> 16 & 0xFF);
      r[(j++)] = (acol >> 8 & 0xFF);
      r[(j++)] = (acol >> 0 & 0xFF);
      
      int scol = in.specular[i];
      r[(j++)] = (scol >> 24 & 0xFF);
      r[(j++)] = (scol >> 16 & 0xFF);
      r[(j++)] = (scol >> 8 & 0xFF);
      r[(j++)] = (scol >> 0 & 0xFF);
      
      int ecol = in.emissive[i];
      r[(j++)] = (ecol >> 24 & 0xFF);
      r[(j++)] = (ecol >> 16 & 0xFF);
      r[(j++)] = (ecol >> 8 & 0xFF);
      r[(j++)] = (ecol >> 0 & 0xFF);
      
      r[(j++)] = in.shininess[i];
      
      System.arraycopy(avect, 0, r, j, avect.length);
      
      return r;
    }
    
    void beginPolygonStroke() {
      pathVertexCount = 0;
      if (pathVertices == null) {
        pathVertices = new float[3 * PGL.DEFAULT_IN_VERTICES];
        pathColors = new int[PGL.DEFAULT_IN_VERTICES];
        pathWeights = new float[PGL.DEFAULT_IN_VERTICES];
      }
    }
    

    void endPolygonStroke() {}
    
    void beginStrokePath()
    {
      beginPath = pathVertexCount;
    }
    
    void endStrokePath(boolean closed) {
      int idx = pathVertexCount;
      if (beginPath + 1 < idx) {
        boolean begin = beginPath == idx - 2;
        boolean end = (begin) || (!closed);
        in.addEdge(idx - 2, idx - 1, begin, end);
        if (!end) {
          in.addEdge(idx - 1, beginPath, false, false);
          in.closeEdge(idx - 1, beginPath);
        }
      }
    }
    
    void addStrokeVertex(float x, float y, float z, int c, float w) {
      int idx = pathVertexCount;
      if (beginPath + 1 < idx) {
        in.addEdge(idx - 2, idx - 1, beginPath == idx - 2, false);
      }
      
      if (pathVertexCount == pathVertices.length / 3) {
        int newSize = pathVertexCount << 1;
        
        float[] vtemp = new float[3 * newSize];
        PApplet.arrayCopy(pathVertices, 0, vtemp, 0, 3 * pathVertexCount);
        pathVertices = vtemp;
        
        int[] ctemp = new int[newSize];
        PApplet.arrayCopy(pathColors, 0, ctemp, 0, pathVertexCount);
        pathColors = ctemp;
        
        float[] wtemp = new float[newSize];
        PApplet.arrayCopy(pathWeights, 0, wtemp, 0, pathVertexCount);
        pathWeights = wtemp;
      }
      
      pathVertices[(3 * idx + 0)] = x;
      pathVertices[(3 * idx + 1)] = y;
      pathVertices[(3 * idx + 2)] = z;
      pathColors[idx] = c;
      pathWeights[idx] = w;
      
      pathVertexCount += 1;
    }
    
    void tessellateStrokePath() {
      if (in.edgeCount == 0) return;
      strokeVertices = pathVertices;
      strokeColors = pathColors;
      strokeWeights = pathWeights;
      if (is3D) {
        tessellateEdges3D();
      } else if (is2D) {
        beginNoTex();
        tessellateEdges2D();
        endNoTex();
      }
    }
    
    boolean clampPolygon() {
      return false;
    }
    


    public void tessellateLinePath(LinePath path)
    {
      initGluTess();
      boolean clamp = clampLinePath();
      callback.init(in.renderMode == 1, true, false, clamp);
      
      int cap = 
        strokeCap == 4 ? 2 : strokeCap == 2 ? 1 : 
        0;
      int join = 
        strokeJoin == 32 ? 2 : strokeJoin == 2 ? 1 : 
        0;
      

      LinePath strokedPath = LinePath.createStrokedPath(path, strokeWeight, 
        cap, join);
      
      gluTess.beginPolygon();
      

      float[] coords = new float[6];
      
      LinePath.PathIterator iter = strokedPath.getPathIterator();
      int rule = iter.getWindingRule();
      switch (rule) {
      case 0: 
        gluTess.setWindingRule(PGL.TESS_WINDING_ODD);
        break;
      case 1: 
        gluTess.setWindingRule(PGL.TESS_WINDING_NONZERO);
      }
      
      
      while (!iter.isDone()) {
        switch (iter.currentSegment(coords))
        {
        case 0: 
          gluTess.beginContour();
        



        case 1: 
          double[] vertex = { coords[0], coords[1], 0.0D, 
            coords[2], coords[3], coords[4], coords[5], 
            0.0D, 0.0D, 1.0D, 
            0.0D, 0.0D, 
            0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D };
          
          gluTess.addVertex(vertex);
          
          break;
        case 2: 
          gluTess.endContour();
        }
        
        iter.next();
      }
      gluTess.endPolygon();
    }
    
    boolean clampLinePath() {
      return (clamp2D()) && 
        (strokeCap == 4) && (strokeJoin == 32) && 
        (!subPixelStroke(strokeWeight));
    }
    


    protected class TessellatorCallback
      implements PGL.TessellatorCallback
    {
      PGraphicsOpenGL.AttributeMap attribs;
      
      boolean calcNormals;
      
      boolean strokeTess;
      
      boolean clampXY;
      
      PGraphicsOpenGL.IndexCache cache;
      
      int cacheIndex;
      
      int vertFirst;
      
      int vertCount;
      
      int vertOffset;
      
      int primitive;
      

      public TessellatorCallback(PGraphicsOpenGL.AttributeMap attribs)
      {
        this.attribs = attribs;
      }
      
      public void init(boolean addCache, boolean strokeTess, boolean calcNorm, boolean clampXY)
      {
        this.strokeTess = strokeTess;
        calcNormals = calcNorm;
        this.clampXY = clampXY;
        
        cache = tess.polyIndexCache;
        if (addCache) {
          cache.addNew();
        }
      }
      
      public void begin(int type) {
        cacheIndex = cache.getLast();
        if (firstPolyIndexCache == -1) {
          firstPolyIndexCache = cacheIndex;
        }
        if ((strokeTess) && (firstLineIndexCache == -1)) {
          firstLineIndexCache = cacheIndex;
        }
        
        vertFirst = cache.vertexCount[cacheIndex];
        vertOffset = cache.vertexOffset[cacheIndex];
        vertCount = 0;
        
        if (type == PGL.TRIANGLE_FAN) { primitive = 11;
        } else if (type == PGL.TRIANGLE_STRIP) { primitive = 10;
        } else if (type == PGL.TRIANGLES) primitive = 9;
      }
      
      public void end() {
        if (PGL.MAX_VERTEX_INDEX1 <= vertFirst + vertCount)
        {





          cacheIndex = cache.addNew();
          vertFirst = cache.vertexCount[cacheIndex];
          vertOffset = cache.vertexOffset[cacheIndex];
        }
        
        int indCount = 0;
        switch (primitive) {
        case 11: 
          indCount = 3 * (vertCount - 2);
          for (int i = 1; i < vertCount - 1; i++) {
            addIndex(0);
            addIndex(i);
            addIndex(i + 1);
            if (calcNormals) calcTriNormal(0, i, i + 1);
          }
          break;
        case 10: 
          indCount = 3 * (vertCount - 2);
          for (int i = 1; i < vertCount - 1; i++) {
            if (i % 2 == 0) {
              addIndex(i + 1);
              addIndex(i);
              addIndex(i - 1);
              if (calcNormals) calcTriNormal(i + 1, i, i - 1);
            } else {
              addIndex(i - 1);
              addIndex(i);
              addIndex(i + 1);
              if (calcNormals) calcTriNormal(i - 1, i, i + 1);
            }
          }
          break;
        case 9: 
          indCount = vertCount;
          for (int i = 0; i < vertCount; i++) {
            addIndex(i);
          }
          if (calcNormals) {
            for (int tr = 0; tr < vertCount / 3; tr++) {
              int i0 = 3 * tr + 0;
              int i1 = 3 * tr + 1;
              int i2 = 3 * tr + 2;
              calcTriNormal(i0, i1, i2);
            }
          }
          break;
        }
        
        cache.incCounts(cacheIndex, indCount, vertCount);
        lastPolyIndexCache = cacheIndex;
        if (strokeTess) {
          lastLineIndexCache = cacheIndex;
        }
      }
      
      protected void addIndex(int tessIdx) {
        tess.polyIndexCheck();
        tess.polyIndices[(tess.polyIndexCount - 1)] = 
          ((short)(vertFirst + tessIdx));
      }
      
      protected void calcTriNormal(int tessIdx0, int tessIdx1, int tessIdx2) {
        tess.calcPolyNormal(vertFirst + vertOffset + tessIdx0, 
          vertFirst + vertOffset + tessIdx1, 
          vertFirst + vertOffset + tessIdx2);
      }
      
      public void vertex(Object data) {
        if ((data instanceof double[])) {
          double[] d = (double[])data;
          int l = d.length;
          if (l < 25) {
            throw new RuntimeException("TessCallback vertex() data is too small");
          }
          

          if (vertCount < PGL.MAX_VERTEX_INDEX1) {
            tess.addPolyVertex(d, clampXY);
            vertCount += 1;
          } else {
            throw new RuntimeException("The tessellator is generating too many vertices, reduce complexity of shape.");
          }
          
        }
        else
        {
          throw new RuntimeException("TessCallback vertex() data not understood");
        }
      }
      
      public void error(int errnum)
      {
        String estring = pg.pgl.tessError(errnum);
        PGraphics.showWarning("Tessellation Error: %1$s", new Object[] { estring });
      }
      













      public void combine(double[] coords, Object[] data, float[] weight, Object[] outData)
      {
        int n = ((double[])data[0]).length;
        double[] vertex = new double[n];
        vertex[0] = coords[0];
        vertex[1] = coords[1];
        vertex[2] = coords[2];
        



        for (int i = 3; i < n; i++) {
          vertex[i] = 0.0D;
          for (int j = 0; j < 4; j++) {
            double[] vertData = (double[])data[j];
            if (vertData != null) {
              vertex[i] += weight[j] * vertData[i];
            }
          }
        }
        



        normalize(vertex, 7);
        if (25 < n)
        {
          int pos = 25;
          for (int i = 0; i < attribs.size(); i++) {
            PGraphicsOpenGL.VertexAttribute attrib = attribs.get(i);
            if (attrib.isNormal()) {
              normalize(vertex, pos);
              pos += 3;
            } else {
              pos += size;
            }
          }
        }
        
        outData[0] = vertex;
      }
      
      private void normalize(double[] v, int i) {
        double sum = v[i] * v[i] + 
          v[(i + 1)] * v[(i + 1)] + 
          v[(i + 2)] * v[(i + 2)];
        double len = Math.sqrt(sum);
        if (0.0D < len) {
          v[i] /= len;
          v[(i + 1)] /= len;
          v[(i + 2)] /= len;
        }
      }
    }
  }
  

  protected static class DepthSorter
  {
    static final int X = 0;
    
    static final int Y = 1;
    
    static final int Z = 2;
    static final int W = 3;
    static final int X0 = 0;
    static final int Y0 = 1;
    static final int Z0 = 2;
    static final int X1 = 3;
    static final int Y1 = 4;
    static final int Z1 = 5;
    static final int X2 = 6;
    static final int Y2 = 7;
    static final int Z2 = 8;
    int[] triangleIndices = new int[0];
    int[] texMap = new int[0];
    int[] voffsetMap = new int[0];
    
    float[] minXBuffer = new float[0];
    float[] minYBuffer = new float[0];
    float[] minZBuffer = new float[0];
    float[] maxXBuffer = new float[0];
    float[] maxYBuffer = new float[0];
    float[] maxZBuffer = new float[0];
    
    float[] screenVertices = new float[0];
    
    float[] triA = new float[9];
    float[] triB = new float[9];
    
    BitSet marked = new BitSet();
    BitSet swapped = new BitSet();
    PGraphicsOpenGL pg;
    
    DepthSorter(PGraphicsOpenGL pg)
    {
      this.pg = pg;
    }
    
    void checkIndexBuffers(int newTriangleCount) {
      if (triangleIndices.length < newTriangleCount) {
        int newSize = (newTriangleCount / 4 + 1) * 5;
        triangleIndices = new int[newSize];
        texMap = new int[newSize];
        voffsetMap = new int[newSize];
        minXBuffer = new float[newSize];
        minYBuffer = new float[newSize];
        minZBuffer = new float[newSize];
        maxXBuffer = new float[newSize];
        maxYBuffer = new float[newSize];
        maxZBuffer = new float[newSize];
      }
    }
    
    void checkVertexBuffer(int newVertexCount) {
      int coordCount = 3 * newVertexCount;
      if (screenVertices.length < coordCount) {
        int newSize = (coordCount / 4 + 1) * 5;
        screenVertices = new float[newSize];
      }
    }
    


    void sort(PGraphicsOpenGL.TessGeometry tessGeo)
    {
      int triangleCount = polyIndexCount / 3;
      checkIndexBuffers(triangleCount);
      int[] triangleIndices = this.triangleIndices;
      int[] texMap = this.texMap;
      int[] voffsetMap = this.voffsetMap;
      

      for (int i = 0; i < triangleCount; i++) {
        triangleIndices[i] = i;
      }
      


      PGraphicsOpenGL.TexCache texCache = pg.texCache;
      PGraphicsOpenGL.IndexCache indexCache = polyIndexCache;
      for (int i = 0; i < size; i++) {
        int first = firstCache[i];
        int last = lastCache[i];
        for (int n = first; n <= last; n++) {
          int ioffset = n == first ? 
            firstIndex[i] : 
            indexOffset[n];
          int icount = n == last ? 
            lastIndex[i] - ioffset + 1 : 
            indexOffset[n] + indexCount[n] - ioffset;
          
          for (int tr = ioffset / 3; tr < (ioffset + icount) / 3; tr++) {
            texMap[tr] = i;
            voffsetMap[tr] = n;
          }
        }
      }
      


      int polyVertexCount = polyVertexCount;
      checkVertexBuffer(polyVertexCount);
      float[] screenVertices = this.screenVertices;
      
      float[] polyVertices = polyVertices;
      
      PMatrix3D projection = pg.projection;
      
      for (int i = 0; i < polyVertexCount; i++) {
        float x = polyVertices[(4 * i + 0)];
        float y = polyVertices[(4 * i + 1)];
        float z = polyVertices[(4 * i + 2)];
        float w = polyVertices[(4 * i + 3)];
        
        float ox = m00 * x + m01 * y + 
          m02 * z + m03 * w;
        float oy = m10 * x + m11 * y + 
          m12 * z + m13 * w;
        float oz = m20 * x + m21 * y + 
          m22 * z + m23 * w;
        float ow = m30 * x + m31 * y + 
          m32 * z + m33 * w;
        if (PGraphicsOpenGL.nonZero(ow)) {
          ox /= ow;
          oy /= ow;
          oz /= ow;
        }
        screenVertices[(3 * i + 0)] = ox;
        screenVertices[(3 * i + 1)] = oy;
        screenVertices[(3 * i + 2)] = (-oz);
      }
      
      float[] screenVertices = this.screenVertices;
      
      int[] vertexOffset = polyIndexCache.vertexOffset;
      short[] polyIndices = polyIndices;
      
      float[] triA = this.triA;
      float[] triB = this.triB;
      
      for (int i = 0; i < triangleCount; i++) {
        fetchTriCoords(triA, i, vertexOffset, voffsetMap, screenVertices, polyIndices);
        minXBuffer[i] = PApplet.min(triA[0], triA[3], triA[6]);
        maxXBuffer[i] = PApplet.max(triA[0], triA[3], triA[6]);
        minYBuffer[i] = PApplet.min(triA[1], triA[4], triA[7]);
        maxYBuffer[i] = PApplet.max(triA[1], triA[4], triA[7]);
        minZBuffer[i] = PApplet.min(triA[2], triA[5], triA[8]);
        maxZBuffer[i] = PApplet.max(triA[2], triA[5], triA[8]);
      }
      
      sortByMinZ(0, triangleCount - 1, triangleIndices, minZBuffer);
      
      int activeTid = 0;
      
      BitSet marked = this.marked;
      BitSet swapped = this.swapped;
      
      marked.clear();
      
      while (activeTid < triangleCount) {
        int testTid = activeTid + 1;
        boolean draw = false;
        
        swapped.clear();
        
        int ati = triangleIndices[activeTid];
        float minXA = minXBuffer[ati];
        float maxXA = maxXBuffer[ati];
        float minYA = minYBuffer[ati];
        float maxYA = maxYBuffer[ati];
        float maxZA = maxZBuffer[ati];
        
        fetchTriCoords(triA, ati, vertexOffset, voffsetMap, screenVertices, polyIndices);
        
        while ((!draw) && (testTid < triangleCount)) {
          int tti = triangleIndices[testTid];
          

          if ((maxZA <= minZBuffer[tti]) && (!marked.get(tti))) {
            draw = true;

          }
          else if ((maxXA <= minXBuffer[tti]) || (maxYA <= minYBuffer[tti]) || 
            (minXA >= maxXBuffer[tti]) || (minYA >= maxYBuffer[tti])) {
            testTid++;
          }
          else
          {
            fetchTriCoords(triB, tti, vertexOffset, voffsetMap, 
              screenVertices, polyIndices);
            if (side(triB, triA, -1.0F) > 0) {
              testTid++;

            }
            else if (side(triA, triB, 1.0F) > 0) {
              testTid++;


            }
            else if (!swapped.get(tti)) {
              swapped.set(ati);
              marked.set(tti);
              rotateRight(triangleIndices, activeTid, testTid);
              
              ati = tti;
              System.arraycopy(triB, 0, triA, 0, 9);
              minXA = minXBuffer[ati];
              maxXA = maxXBuffer[ati];
              minYA = minYBuffer[ati];
              maxYA = maxYBuffer[ati];
              maxZA = maxZBuffer[ati];
              
              testTid = activeTid + 1;
            }
            else
            {
              testTid++;
            }
          }
        }
        
        activeTid++;
      }
      

      for (int id = 0; id < triangleCount; id++) {
        int mappedId = triangleIndices[id];
        if (id != mappedId)
        {

          short i0 = polyIndices[(3 * id + 0)];
          short i1 = polyIndices[(3 * id + 1)];
          short i2 = polyIndices[(3 * id + 2)];
          int texId = texMap[id];
          int voffsetId = voffsetMap[id];
          

          int currId = id;
          int nextId = mappedId;
          do {
            triangleIndices[currId] = currId;
            polyIndices[(3 * currId + 0)] = polyIndices[(3 * nextId + 0)];
            polyIndices[(3 * currId + 1)] = polyIndices[(3 * nextId + 1)];
            polyIndices[(3 * currId + 2)] = polyIndices[(3 * nextId + 2)];
            texMap[currId] = texMap[nextId];
            voffsetMap[currId] = voffsetMap[nextId];
            
            currId = nextId;
            nextId = triangleIndices[nextId];
          } while (nextId != id);
          

          triangleIndices[currId] = currId;
          polyIndices[(3 * currId + 0)] = i0;
          polyIndices[(3 * currId + 1)] = i1;
          polyIndices[(3 * currId + 2)] = i2;
          texMap[currId] = texId;
          voffsetMap[currId] = voffsetId;
        }
      }
    }
    


    static void fetchTriCoords(float[] tri, int ti, int[] vertexOffset, int[] voffsetMap, float[] screenVertices, short[] polyIndices)
    {
      int voffset = vertexOffset[voffsetMap[ti]];
      int i0 = 3 * (voffset + polyIndices[(3 * ti + 0)]);
      int i1 = 3 * (voffset + polyIndices[(3 * ti + 1)]);
      int i2 = 3 * (voffset + polyIndices[(3 * ti + 2)]);
      tri[0] = screenVertices[(i0 + 0)];
      tri[1] = screenVertices[(i0 + 1)];
      tri[2] = screenVertices[(i0 + 2)];
      tri[3] = screenVertices[(i1 + 0)];
      tri[4] = screenVertices[(i1 + 1)];
      tri[5] = screenVertices[(i1 + 2)];
      tri[6] = screenVertices[(i2 + 0)];
      tri[7] = screenVertices[(i2 + 1)];
      tri[8] = screenVertices[(i2 + 2)];
    }
    


    static void sortByMinZ(int leftTid, int rightTid, int[] triangleIndices, float[] minZBuffer)
    {
      swap(triangleIndices, leftTid, (leftTid + rightTid) / 2);
      
      int k = leftTid;
      float leftMinZ = minZBuffer[triangleIndices[leftTid]];
      

      for (int tid = leftTid + 1; tid <= rightTid; tid++) {
        float minZ = minZBuffer[triangleIndices[tid]];
        if (minZ < leftMinZ) {
          swap(triangleIndices, ++k, tid);
        }
      }
      

      swap(triangleIndices, leftTid, k);
      
      if (leftTid < k - 1) sortByMinZ(leftTid, k - 1, triangleIndices, 
          minZBuffer);
      if (k + 1 < rightTid) { sortByMinZ(k + 1, rightTid, triangleIndices, 
          minZBuffer);
      }
    }
    



    static int side(float[] tri1, float[] tri2, float tz)
    {
      float ABx = tri1[3] - tri1[0];float ACx = tri1[6] - tri1[0];
      float ABy = tri1[4] - tri1[1];float ACy = tri1[7] - tri1[1];
      float ABz = tri1[5] - tri1[2];float ACz = tri1[8] - tri1[2];
      
      float Dx = ABy * ACz - ABz * ACy;float Dy = ABz * ACx - ABx * ACz;float Dz = ABx * ACy - ABy * ACx;
      

      float rMag = 1.0F / (float)Math.sqrt(Dx * Dx + Dy * Dy + Dz * Dz);
      Dx *= rMag;Dy *= rMag;Dz *= rMag;
      
      float Dw = -dot(Dx, Dy, Dz, tri1[0], tri1[1], tri1[2]);
      

      float distTest = dot(Dx, Dy, Dz, 
        tri1[0], tri1[1], tri1[2] + 100.0F * tz) + Dw;
      
      float distA = dot(Dx, Dy, Dz, tri2[0], tri2[1], tri2[2]) + Dw;
      float distB = dot(Dx, Dy, Dz, tri2[3], tri2[4], tri2[5]) + Dw;
      float distC = dot(Dx, Dy, Dz, tri2[6], tri2[7], tri2[8]) + Dw;
      


      float absA = PApplet.abs(distA);
      float absB = PApplet.abs(distB);
      float absC = PApplet.abs(distC);
      float eps = PApplet.max(absA, absB, absC) * 0.1F;
      
      float sideA = (absA < eps ? 0.0F : distA) * distTest;
      float sideB = (absB < eps ? 0.0F : distB) * distTest;
      float sideC = (absC < eps ? 0.0F : distC) * distTest;
      
      boolean sameSide = (sideA >= 0.0F) && (sideB >= 0.0F) && (sideC >= 0.0F);
      boolean notSameSide = (sideA <= 0.0F) && (sideB <= 0.0F) && (sideC <= 0.0F);
      
      return notSameSide ? -1 : sameSide ? 1 : 0;
    }
    
    static float dot(float a1, float a2, float a3, float b1, float b2, float b3)
    {
      return a1 * b1 + a2 * b2 + a3 * b3;
    }
    


    static void swap(int[] array, int i1, int i2)
    {
      int temp = array[i1];
      array[i1] = array[i2];
      array[i2] = temp;
    }
    
    static void rotateRight(int[] array, int i1, int i2) {
      if (i1 == i2) return;
      int temp = array[i2];
      System.arraycopy(array, i1, array, i1 + 1, i2 - i1);
      array[i1] = temp;
    }
  }
}
