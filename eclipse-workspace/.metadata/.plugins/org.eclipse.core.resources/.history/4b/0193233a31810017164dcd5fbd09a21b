package jogamp.opengl.es1;

import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.GLArrayData;
import com.jogamp.opengl.GLException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import jogamp.opengl.GLContextImpl;

public class GLES1Impl implements com.jogamp.opengl.GLBase, com.jogamp.opengl.GL, com.jogamp.opengl.GL2ES1, com.jogamp.opengl.GLES1
{
  private static final int params_offset = 0;
  private final com.jogamp.opengl.GLProfile glProfile;
  private final GLContextImpl _context;
  private final jogamp.opengl.GLStateTracker glStateTracker;
  private final jogamp.opengl.GLBufferObjectTracker bufferObjectTracker;
  private final jogamp.opengl.GLBufferStateTracker bufferStateTracker;
  
  public void glAlphaFunc(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glAlphaFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glAlphaFunc" }));
    }
    dispatch_glAlphaFunc1(paramInt, paramFloat, l);
  }
  

  private native void dispatch_glAlphaFunc1(int paramInt, float paramFloat, long paramLong);
  

  public void glClearColor(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glClearColor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearColor" }));
    }
    dispatch_glClearColor1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glClearColor1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glClearDepthf(float paramFloat)
  {
    long l = _pat._addressof_glClearDepthf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearDepthf" }));
    }
    dispatch_glClearDepthf1(paramFloat, l);
  }
  


  private native void dispatch_glClearDepthf1(float paramFloat, long paramLong);
  

  public void glClipPlanef(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glClipPlanef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanef" }));
    }
    dispatch_glClipPlanef1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glClipPlanef1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glClipPlanef(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"equation_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glClipPlanef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanef" }));
    }
    dispatch_glClipPlanef1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glColor4f(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glColor4f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColor4f" }));
    }
    dispatch_glColor4f1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glColor4f1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glDepthRangef(float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glDepthRangef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangef" }));
    }
    dispatch_glDepthRangef1(paramFloat1, paramFloat2, l);
  }
  

  private native void dispatch_glDepthRangef1(float paramFloat1, float paramFloat2, long paramLong);
  

  public void glFogf(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glFogf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogf" }));
    }
    dispatch_glFogf1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glFogf1(int paramInt, float paramFloat, long paramLong);
  

  public void glFogfv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glFogfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogfv" }));
    }
    dispatch_glFogfv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glFogfv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glFogfv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glFogfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogfv" }));
    }
    dispatch_glFogfv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glFrustumf(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6)
  {
    long l = _pat._addressof_glFrustumf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFrustumf" }));
    }
    dispatch_glFrustumf1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, paramFloat6, l);
  }
  


  private native void dispatch_glFrustumf1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, long paramLong);
  

  public void glGetClipPlanef(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetClipPlanef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetClipPlanef" }));
    }
    dispatch_glGetClipPlanef1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetClipPlanef1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetClipPlanef(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"equation_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetClipPlanef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetClipPlanef" }));
    }
    dispatch_glGetClipPlanef1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glGetFloatv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetFloatv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloatv" }));
    }
    dispatch_glGetFloatv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetFloatv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetFloatv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetFloatv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloatv" }));
    }
    dispatch_glGetFloatv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glGetLightfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetLightfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetLightfv" }));
    }
    dispatch_glGetLightfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetLightfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetLightfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetLightfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetLightfv" }));
    }
    dispatch_glGetLightfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetMaterialfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetMaterialfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMaterialfv" }));
    }
    dispatch_glGetMaterialfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetMaterialfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetMaterialfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetMaterialfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMaterialfv" }));
    }
    dispatch_glGetMaterialfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetTexEnvfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetTexEnvfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnvfv" }));
    }
    dispatch_glGetTexEnvfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexEnvfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexEnvfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetTexEnvfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnvfv" }));
    }
    dispatch_glGetTexEnvfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterfv" }));
    }
    dispatch_glGetTexParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterfv" }));
    }
    dispatch_glGetTexParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glLightModelf(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glLightModelf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelf" }));
    }
    dispatch_glLightModelf1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glLightModelf1(int paramInt, float paramFloat, long paramLong);
  

  public void glLightModelfv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glLightModelfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelfv" }));
    }
    dispatch_glLightModelfv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glLightModelfv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glLightModelfv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glLightModelfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelfv" }));
    }
    dispatch_glLightModelfv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glLightf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glLightf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightf" }));
    }
    dispatch_glLightf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glLightf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glLightfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glLightfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightfv" }));
    }
    dispatch_glLightfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glLightfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glLightfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glLightfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightfv" }));
    }
    dispatch_glLightfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glLineWidth(float paramFloat)
  {
    long l = _pat._addressof_glLineWidth;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLineWidth" }));
    }
    dispatch_glLineWidth1(paramFloat, l);
  }
  


  private native void dispatch_glLineWidth1(float paramFloat, long paramLong);
  

  public void glLoadMatrixf(FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glLoadMatrixf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadMatrixf" }));
    }
    dispatch_glLoadMatrixf1(bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glLoadMatrixf1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glLoadMatrixf(float[] paramArrayOfFloat, int paramInt)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt))
      throw new GLException("array offset argument \"m_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glLoadMatrixf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadMatrixf" }));
    }
    dispatch_glLoadMatrixf1(paramArrayOfFloat, 4 * paramInt, false, l);
  }
  

  public void glMaterialf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glMaterialf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialf" }));
    }
    dispatch_glMaterialf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glMaterialf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glMaterialfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glMaterialfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialfv" }));
    }
    dispatch_glMaterialfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glMaterialfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glMaterialfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glMaterialfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialfv" }));
    }
    dispatch_glMaterialfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glMultMatrixf(FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glMultMatrixf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultMatrixf" }));
    }
    dispatch_glMultMatrixf1(bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glMultMatrixf1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glMultMatrixf(float[] paramArrayOfFloat, int paramInt)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt))
      throw new GLException("array offset argument \"m_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glMultMatrixf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultMatrixf" }));
    }
    dispatch_glMultMatrixf1(paramArrayOfFloat, 4 * paramInt, false, l);
  }
  

  public void glMultiTexCoord4f(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glMultiTexCoord4f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiTexCoord4f" }));
    }
    dispatch_glMultiTexCoord4f1(paramInt, paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glMultiTexCoord4f1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glNormal3f(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glNormal3f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNormal3f" }));
    }
    dispatch_glNormal3f1(paramFloat1, paramFloat2, paramFloat3, l);
  }
  

  private native void dispatch_glNormal3f1(float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glOrthof(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6)
  {
    long l = _pat._addressof_glOrthof;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glOrthof" }));
    }
    dispatch_glOrthof1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, paramFloat6, l);
  }
  

  private native void dispatch_glOrthof1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, long paramLong);
  

  public void glPointParameterf(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glPointParameterf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterf" }));
    }
    dispatch_glPointParameterf1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glPointParameterf1(int paramInt, float paramFloat, long paramLong);
  

  public void glPointParameterfv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glPointParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterfv" }));
    }
    dispatch_glPointParameterfv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glPointParameterfv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glPointParameterfv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glPointParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterfv" }));
    }
    dispatch_glPointParameterfv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glPointSize(float paramFloat)
  {
    long l = _pat._addressof_glPointSize;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointSize" }));
    }
    dispatch_glPointSize1(paramFloat, l);
  }
  

  private native void dispatch_glPointSize1(float paramFloat, long paramLong);
  

  public void glPolygonOffset(float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glPolygonOffset;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPolygonOffset" }));
    }
    dispatch_glPolygonOffset1(paramFloat1, paramFloat2, l);
  }
  

  private native void dispatch_glPolygonOffset1(float paramFloat1, float paramFloat2, long paramLong);
  

  public void glRotatef(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glRotatef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRotatef" }));
    }
    dispatch_glRotatef1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glRotatef1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glScalef(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glScalef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScalef" }));
    }
    dispatch_glScalef1(paramFloat1, paramFloat2, paramFloat3, l);
  }
  

  private native void dispatch_glScalef1(float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glTexEnvf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glTexEnvf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvf" }));
    }
    dispatch_glTexEnvf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glTexEnvf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glTexEnvfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glTexEnvfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvfv" }));
    }
    dispatch_glTexEnvfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glTexEnvfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexEnvfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glTexEnvfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvfv" }));
    }
    dispatch_glTexEnvfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glTexParameterf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glTexParameterf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterf" }));
    }
    dispatch_glTexParameterf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glTexParameterf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glTexParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterfv" }));
    }
    dispatch_glTexParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterfv" }));
    }
    dispatch_glTexParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glTranslatef(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glTranslatef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTranslatef" }));
    }
    dispatch_glTranslatef1(paramFloat1, paramFloat2, paramFloat3, l);
  }
  

  private native void dispatch_glTranslatef1(float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glActiveTexture(int paramInt)
  {
    long l = _pat._addressof_glActiveTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glActiveTexture" }));
    }
    dispatch_glActiveTexture1(paramInt, l);
  }
  

  private native void dispatch_glActiveTexture1(int paramInt, long paramLong);
  

  public void glAlphaFuncx(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glAlphaFuncx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glAlphaFuncx" }));
    }
    dispatch_glAlphaFuncx1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glAlphaFuncx1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindBuffer(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindBuffer" }));
    }
    dispatch_glBindBuffer1(paramInt1, paramInt2, l);
    bufferStateTracker.setBoundBufferObject(paramInt1, paramInt2);
  }
  

  private native void dispatch_glBindBuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindTexture(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindTexture" }));
    }
    dispatch_glBindTexture1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBindTexture1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendFunc(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFunc" }));
    }
    dispatch_glBlendFunc1(paramInt1, paramInt2, l);
  }
  






  private native void dispatch_glBlendFunc1(int paramInt1, int paramInt2, long paramLong);
  






  private void glBufferDataDelegate(int paramInt1, long paramLong, Buffer paramBuffer, int paramInt2)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glBufferData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBufferData" }));
    }
    dispatch_glBufferDataDelegate1(paramInt1, paramLong, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt2, l);
  }
  







  private native void dispatch_glBufferDataDelegate1(int paramInt1, long paramLong1, Object paramObject, int paramInt2, boolean paramBoolean, int paramInt3, long paramLong2);
  






  public void glBufferSubData(int paramInt, long paramLong1, long paramLong2, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glBufferSubData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBufferSubData" }));
    }
    dispatch_glBufferSubData1(paramInt, paramLong1, paramLong2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glBufferSubData1(int paramInt1, long paramLong1, long paramLong2, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong3);
  

  public void glClear(int paramInt)
  {
    long l = _pat._addressof_glClear;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClear" }));
    }
    dispatch_glClear1(paramInt, l);
  }
  

  private native void dispatch_glClear1(int paramInt, long paramLong);
  

  public void glClearColorx(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glClearColorx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearColorx" }));
    }
    dispatch_glClearColorx1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glClearColorx1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glClearDepthx(int paramInt)
  {
    long l = _pat._addressof_glClearDepthx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearDepthx" }));
    }
    dispatch_glClearDepthx1(paramInt, l);
  }
  

  private native void dispatch_glClearDepthx1(int paramInt, long paramLong);
  

  public void glClearStencil(int paramInt)
  {
    long l = _pat._addressof_glClearStencil;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearStencil" }));
    }
    dispatch_glClearStencil1(paramInt, l);
  }
  

  private native void dispatch_glClearStencil1(int paramInt, long paramLong);
  

  public void glClientActiveTexture(int paramInt)
  {
    long l = _pat._addressof_glClientActiveTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClientActiveTexture" }));
    }
    dispatch_glClientActiveTexture1(paramInt, l);
  }
  


  private native void dispatch_glClientActiveTexture1(int paramInt, long paramLong);
  

  public void glClipPlanex(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glClipPlanex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanex" }));
    }
    dispatch_glClipPlanex1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glClipPlanex1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glClipPlanex(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"equation_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glClipPlanex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanex" }));
    }
    dispatch_glClipPlanex1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glColor4ub(byte paramByte1, byte paramByte2, byte paramByte3, byte paramByte4)
  {
    long l = _pat._addressof_glColor4ub;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColor4ub" }));
    }
    dispatch_glColor4ub1(paramByte1, paramByte2, paramByte3, paramByte4, l);
  }
  

  private native void dispatch_glColor4ub1(byte paramByte1, byte paramByte2, byte paramByte3, byte paramByte4, long paramLong);
  

  public void glColor4x(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glColor4x;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColor4x" }));
    }
    dispatch_glColor4x1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glColor4x1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glColorMask(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4)
  {
    long l = _pat._addressof_glColorMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorMask" }));
    }
    dispatch_glColorMask1(paramBoolean1, paramBoolean2, paramBoolean3, paramBoolean4, l);
  }
  


  private native void dispatch_glColorMask1(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4, long paramLong);
  

  public void glColorPointer(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glColorPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorPointer" }));
    }
    dispatch_glColorPointer0(paramInt1, paramInt2, paramInt3, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glColorPointer0(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, long paramLong);
  

  public void glColorPointer(int paramInt1, int paramInt2, int paramInt3, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glColorPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorPointer" }));
    }
    dispatch_glColorPointer0(paramInt1, paramInt2, paramInt3, paramLong, l);
  }
  


  private native void dispatch_glColorPointer0(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2);
  

  public void glCompressedTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage2D" }));
    }
    dispatch_glCompressedTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Object paramObject, int paramInt8, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage2D" }));
    }
    dispatch_glCompressedTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramLong, l);
  }
  


  private native void dispatch_glCompressedTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong1, long paramLong2);
  

  public void glCompressedTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage2D" }));
    }
    dispatch_glCompressedTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage2D" }));
    }
    dispatch_glCompressedTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glCompressedTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glCopyTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    long l = _pat._addressof_glCopyTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTexImage2D" }));
    }
    dispatch_glCopyTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, l);
  }
  

  private native void dispatch_glCopyTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong);
  

  public void glCopyTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    long l = _pat._addressof_glCopyTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTexSubImage2D" }));
    }
    dispatch_glCopyTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, l);
  }
  

  private native void dispatch_glCopyTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong);
  

  public void glCullFace(int paramInt)
  {
    long l = _pat._addressof_glCullFace;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCullFace" }));
    }
    dispatch_glCullFace1(paramInt, l);
  }
  


  private native void dispatch_glCullFace1(int paramInt, long paramLong);
  

  public void glDeleteBuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    bufferObjectTracker.notifyBuffersDeleted(paramInt, paramIntBuffer);
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteBuffers" }));
    }
    dispatch_glDeleteBuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteBuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteBuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    bufferObjectTracker.notifyBuffersDeleted(paramInt1, paramArrayOfInt, paramInt2);
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteBuffers" }));
    }
    dispatch_glDeleteBuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glDeleteTextures(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTextures" }));
    }
    dispatch_glDeleteTextures1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteTextures1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteTextures(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTextures" }));
    }
    dispatch_glDeleteTextures1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glDepthFunc(int paramInt)
  {
    long l = _pat._addressof_glDepthFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthFunc" }));
    }
    dispatch_glDepthFunc1(paramInt, l);
  }
  

  private native void dispatch_glDepthFunc1(int paramInt, long paramLong);
  

  public void glDepthMask(boolean paramBoolean)
  {
    long l = _pat._addressof_glDepthMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthMask" }));
    }
    dispatch_glDepthMask1(paramBoolean, l);
  }
  

  private native void dispatch_glDepthMask1(boolean paramBoolean, long paramLong);
  

  public void glDepthRangex(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDepthRangex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangex" }));
    }
    dispatch_glDepthRangex1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDepthRangex1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisable(int paramInt)
  {
    long l = _pat._addressof_glDisable;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisable" }));
    }
    dispatch_glDisable1(paramInt, l);
  }
  

  private native void dispatch_glDisable1(int paramInt, long paramLong);
  

  public void glDisableClientState(int paramInt)
  {
    long l = _pat._addressof_glDisableClientState;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableClientState" }));
    }
    dispatch_glDisableClientState1(paramInt, l);
  }
  

  private native void dispatch_glDisableClientState1(int paramInt, long paramLong);
  

  public void glDrawArrays(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glDrawArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArrays" }));
    }
    dispatch_glDrawArrays1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glDrawArrays1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glDrawElements(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElements" }));
    }
    dispatch_glDrawElements1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glDrawElements1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glDrawElements(int paramInt1, int paramInt2, int paramInt3, long paramLong)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElements" }));
    }
    dispatch_glDrawElements1(paramInt1, paramInt2, paramInt3, paramLong, l);
  }
  

  private native void dispatch_glDrawElements1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2);
  

  public void glEnable(int paramInt)
  {
    long l = _pat._addressof_glEnable;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnable" }));
    }
    dispatch_glEnable1(paramInt, l);
  }
  

  private native void dispatch_glEnable1(int paramInt, long paramLong);
  

  public void glEnableClientState(int paramInt)
  {
    long l = _pat._addressof_glEnableClientState;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableClientState" }));
    }
    dispatch_glEnableClientState1(paramInt, l);
  }
  

  private native void dispatch_glEnableClientState1(int paramInt, long paramLong);
  

  public void glFinish()
  {
    long l = _pat._addressof_glFinish;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFinish" }));
    }
    dispatch_glFinish1(l);
  }
  

  private native void dispatch_glFinish1(long paramLong);
  

  public void glFlush()
  {
    long l = _pat._addressof_glFlush;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFlush" }));
    }
    dispatch_glFlush1(l);
  }
  

  private native void dispatch_glFlush1(long paramLong);
  

  public void glFogx(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glFogx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogx" }));
    }
    dispatch_glFogx1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glFogx1(int paramInt1, int paramInt2, long paramLong);
  

  public void glFogxv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glFogxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogxv" }));
    }
    dispatch_glFogxv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glFogxv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glFogxv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glFogxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFogxv" }));
    }
    dispatch_glFogxv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glFrontFace(int paramInt)
  {
    long l = _pat._addressof_glFrontFace;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFrontFace" }));
    }
    dispatch_glFrontFace1(paramInt, l);
  }
  

  private native void dispatch_glFrontFace1(int paramInt, long paramLong);
  

  public void glFrustumx(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFrustumx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFrustumx" }));
    }
    dispatch_glFrustumx1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glFrustumx1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glGetBooleanv(int paramInt, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetBooleanv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleanv" }));
    }
    dispatch_glGetBooleanv1(paramInt, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glGetBooleanv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetBooleanv(int paramInt1, byte[] paramArrayOfByte, int paramInt2)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetBooleanv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleanv" }));
    }
    dispatch_glGetBooleanv1(paramInt1, paramArrayOfByte, paramInt2, false, l);
  }
  


  public void glGetBufferParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetBufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteriv" }));
    }
    dispatch_glGetBufferParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetBufferParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetBufferParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetBufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteriv" }));
    }
    dispatch_glGetBufferParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetClipPlanex(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetClipPlanex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetClipPlanex" }));
    }
    dispatch_glGetClipPlanex1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetClipPlanex1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetClipPlanex(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"eqn_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetClipPlanex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetClipPlanex" }));
    }
    dispatch_glGetClipPlanex1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenBuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenBuffers" }));
    }
    dispatch_glGenBuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenBuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenBuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenBuffers" }));
    }
    dispatch_glGenBuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenTextures(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTextures" }));
    }
    dispatch_glGenTextures1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenTextures1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenTextures(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTextures" }));
    }
    dispatch_glGenTextures1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public int glGetError()
  {
    long l = _pat._addressof_glGetError;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetError" }));
    }
    return dispatch_glGetError1(l);
  }
  


  private native int dispatch_glGetError1(long paramLong);
  

  public void glGetFixedv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetFixedv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFixedv" }));
    }
    dispatch_glGetFixedv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetFixedv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetFixedv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetFixedv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFixedv" }));
    }
    dispatch_glGetFixedv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGetIntegerv(int paramInt, IntBuffer paramIntBuffer)
  {
    if (glStateTracker.getInt(paramInt, paramIntBuffer, 0)) return;
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetIntegerv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegerv" }));
    }
    dispatch_glGetIntegerv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetIntegerv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetIntegerv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if (glStateTracker.getInt(paramInt1, paramArrayOfInt, paramInt2)) return;
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetIntegerv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegerv" }));
    }
    dispatch_glGetIntegerv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGetLightxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetLightxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetLightxv" }));
    }
    dispatch_glGetLightxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetLightxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetLightxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetLightxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetLightxv" }));
    }
    dispatch_glGetLightxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetMaterialxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetMaterialxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMaterialxv" }));
    }
    dispatch_glGetMaterialxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetMaterialxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetMaterialxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetMaterialxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMaterialxv" }));
    }
    dispatch_glGetMaterialxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public String glGetString(int paramInt)
  {
    if ((_context.isExtensionCacheInitialized()) && 
      (7939 == paramInt)) {
      return _context.getGLExtensionsString();
    }
    


    long l = _pat._addressof_glGetString;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetString" }));
    }
    return dispatch_glGetString1(paramInt, l);
  }
  


  private native String dispatch_glGetString1(int paramInt, long paramLong);
  

  public void glGetTexEnviv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexEnviv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnviv" }));
    }
    dispatch_glGetTexEnviv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexEnviv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexEnviv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexEnviv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnviv" }));
    }
    dispatch_glGetTexEnviv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexEnvxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexEnvxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnvxv" }));
    }
    dispatch_glGetTexEnvxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexEnvxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexEnvxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexEnvxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexEnvxv" }));
    }
    dispatch_glGetTexEnvxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameteriv" }));
    }
    dispatch_glGetTexParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameteriv" }));
    }
    dispatch_glGetTexParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameterxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterxv" }));
    }
    dispatch_glGetTexParameterxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameterxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameterxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterxv" }));
    }
    dispatch_glGetTexParameterxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glHint(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glHint;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glHint" }));
    }
    dispatch_glHint1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glHint1(int paramInt1, int paramInt2, long paramLong);
  

  public boolean glIsBuffer(int paramInt)
  {
    long l = _pat._addressof_glIsBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsBuffer" }));
    }
    return dispatch_glIsBuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsBuffer1(int paramInt, long paramLong);
  

  public boolean glIsEnabled(int paramInt)
  {
    long l = _pat._addressof_glIsEnabled;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnabled" }));
    }
    return dispatch_glIsEnabled1(paramInt, l);
  }
  

  private native boolean dispatch_glIsEnabled1(int paramInt, long paramLong);
  

  public boolean glIsTexture(int paramInt)
  {
    long l = _pat._addressof_glIsTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsTexture" }));
    }
    return dispatch_glIsTexture1(paramInt, l);
  }
  

  private native boolean dispatch_glIsTexture1(int paramInt, long paramLong);
  

  public void glLightModelx(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glLightModelx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelx" }));
    }
    dispatch_glLightModelx1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glLightModelx1(int paramInt1, int paramInt2, long paramLong);
  

  public void glLightModelxv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glLightModelxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelxv" }));
    }
    dispatch_glLightModelxv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glLightModelxv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glLightModelxv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glLightModelxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightModelxv" }));
    }
    dispatch_glLightModelxv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glLightx(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glLightx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightx" }));
    }
    dispatch_glLightx1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glLightx1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glLightxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glLightxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightxv" }));
    }
    dispatch_glLightxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glLightxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glLightxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glLightxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLightxv" }));
    }
    dispatch_glLightxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glLineWidthx(int paramInt)
  {
    long l = _pat._addressof_glLineWidthx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLineWidthx" }));
    }
    dispatch_glLineWidthx1(paramInt, l);
  }
  

  private native void dispatch_glLineWidthx1(int paramInt, long paramLong);
  

  public void glLoadIdentity()
  {
    long l = _pat._addressof_glLoadIdentity;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadIdentity" }));
    }
    dispatch_glLoadIdentity1(l);
  }
  


  private native void dispatch_glLoadIdentity1(long paramLong);
  

  public void glLoadMatrixx(IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glLoadMatrixx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadMatrixx" }));
    }
    dispatch_glLoadMatrixx1(bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glLoadMatrixx1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glLoadMatrixx(int[] paramArrayOfInt, int paramInt)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt))
      throw new GLException("array offset argument \"m_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glLoadMatrixx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadMatrixx" }));
    }
    dispatch_glLoadMatrixx1(paramArrayOfInt, 4 * paramInt, false, l);
  }
  

  public void glLogicOp(int paramInt)
  {
    long l = _pat._addressof_glLogicOp;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLogicOp" }));
    }
    dispatch_glLogicOp1(paramInt, l);
  }
  

  private native void dispatch_glLogicOp1(int paramInt, long paramLong);
  

  public void glMaterialx(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glMaterialx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialx" }));
    }
    dispatch_glMaterialx1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glMaterialx1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glMaterialxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glMaterialxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialxv" }));
    }
    dispatch_glMaterialxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glMaterialxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glMaterialxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glMaterialxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMaterialxv" }));
    }
    dispatch_glMaterialxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glMatrixMode(int paramInt)
  {
    long l = _pat._addressof_glMatrixMode;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMatrixMode" }));
    }
    dispatch_glMatrixMode1(paramInt, l);
  }
  


  private native void dispatch_glMatrixMode1(int paramInt, long paramLong);
  

  public void glMultMatrixx(IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glMultMatrixx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultMatrixx" }));
    }
    dispatch_glMultMatrixx1(bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glMultMatrixx1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glMultMatrixx(int[] paramArrayOfInt, int paramInt)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt))
      throw new GLException("array offset argument \"m_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glMultMatrixx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultMatrixx" }));
    }
    dispatch_glMultMatrixx1(paramArrayOfInt, 4 * paramInt, false, l);
  }
  

  public void glMultiTexCoord4x(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glMultiTexCoord4x;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiTexCoord4x" }));
    }
    dispatch_glMultiTexCoord4x1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glMultiTexCoord4x1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glNormal3x(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glNormal3x;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNormal3x" }));
    }
    dispatch_glNormal3x1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glNormal3x1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glNormalPointer(int paramInt1, int paramInt2, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glNormalPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNormalPointer" }));
    }
    dispatch_glNormalPointer0(paramInt1, paramInt2, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glNormalPointer0(int paramInt1, int paramInt2, Object paramObject, int paramInt3, long paramLong);
  

  public void glNormalPointer(int paramInt1, int paramInt2, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glNormalPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNormalPointer" }));
    }
    dispatch_glNormalPointer0(paramInt1, paramInt2, paramLong, l);
  }
  

  private native void dispatch_glNormalPointer0(int paramInt1, int paramInt2, long paramLong1, long paramLong2);
  

  public void glOrthox(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glOrthox;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glOrthox" }));
    }
    dispatch_glOrthox1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glOrthox1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glPixelStorei(int paramInt1, int paramInt2)
  {
    if ((paramInt1 != 3333) && (paramInt1 != 3317)) {
      throw new GLException("Unsupported pixel store parameter name 0x" + Integer.toHexString(paramInt1));
    }
    glStateTracker.setInt(paramInt1, paramInt2);
    long l = _pat._addressof_glPixelStorei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPixelStorei" }));
    }
    dispatch_glPixelStorei1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPixelStorei1(int paramInt1, int paramInt2, long paramLong);
  

  public void glPointParameterx(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPointParameterx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterx" }));
    }
    dispatch_glPointParameterx1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glPointParameterx1(int paramInt1, int paramInt2, long paramLong);
  

  public void glPointParameterxv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glPointParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterxv" }));
    }
    dispatch_glPointParameterxv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glPointParameterxv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glPointParameterxv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glPointParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointParameterxv" }));
    }
    dispatch_glPointParameterxv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glPointSizex(int paramInt)
  {
    long l = _pat._addressof_glPointSizex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointSizex" }));
    }
    dispatch_glPointSizex1(paramInt, l);
  }
  

  private native void dispatch_glPointSizex1(int paramInt, long paramLong);
  

  public void glPolygonOffsetx(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPolygonOffsetx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPolygonOffsetx" }));
    }
    dispatch_glPolygonOffsetx1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPolygonOffsetx1(int paramInt1, int paramInt2, long paramLong);
  

  public void glPopMatrix()
  {
    long l = _pat._addressof_glPopMatrix;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPopMatrix" }));
    }
    dispatch_glPopMatrix1(l);
  }
  

  private native void dispatch_glPopMatrix1(long paramLong);
  

  public void glPushMatrix()
  {
    long l = _pat._addressof_glPushMatrix;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPushMatrix" }));
    }
    dispatch_glPushMatrix1(l);
  }
  


  private native void dispatch_glPushMatrix1(long paramLong);
  

  public void glReadPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, Buffer paramBuffer)
  {
    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt5, paramInt6, paramInt3, paramInt4, 1, true));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glReadPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadPixels" }));
    }
    dispatch_glReadPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glReadPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, Object paramObject, int paramInt7, boolean paramBoolean, long paramLong);
  

  public void glReadPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong)
  {
    checkPackPBOBound(true);
    long l = _pat._addressof_glReadPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadPixels" }));
    }
    dispatch_glReadPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramLong, l);
  }
  

  private native void dispatch_glReadPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong1, long paramLong2);
  

  public void glRotatex(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glRotatex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRotatex" }));
    }
    dispatch_glRotatex1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glRotatex1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glSampleCoverage(float paramFloat, boolean paramBoolean)
  {
    long l = _pat._addressof_glSampleCoverage;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSampleCoverage" }));
    }
    dispatch_glSampleCoverage1(paramFloat, paramBoolean, l);
  }
  

  private native void dispatch_glSampleCoverage1(float paramFloat, boolean paramBoolean, long paramLong);
  

  public void glSampleCoveragex(int paramInt, boolean paramBoolean)
  {
    long l = _pat._addressof_glSampleCoveragex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSampleCoveragex" }));
    }
    dispatch_glSampleCoveragex1(paramInt, paramBoolean, l);
  }
  

  private native void dispatch_glSampleCoveragex1(int paramInt, boolean paramBoolean, long paramLong);
  

  public void glScalex(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glScalex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScalex" }));
    }
    dispatch_glScalex1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glScalex1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glScissor(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glScissor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissor" }));
    }
    dispatch_glScissor1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glScissor1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glShadeModel(int paramInt)
  {
    long l = _pat._addressof_glShadeModel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glShadeModel" }));
    }
    dispatch_glShadeModel1(paramInt, l);
  }
  

  private native void dispatch_glShadeModel1(int paramInt, long paramLong);
  

  public void glStencilFunc(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glStencilFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilFunc" }));
    }
    dispatch_glStencilFunc1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glStencilFunc1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glStencilMask(int paramInt)
  {
    long l = _pat._addressof_glStencilMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilMask" }));
    }
    dispatch_glStencilMask1(paramInt, l);
  }
  

  private native void dispatch_glStencilMask1(int paramInt, long paramLong);
  

  public void glStencilOp(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glStencilOp;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilOp" }));
    }
    dispatch_glStencilOp1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glStencilOp1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexCoordPointer(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glTexCoordPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexCoordPointer" }));
    }
    dispatch_glTexCoordPointer0(paramInt1, paramInt2, paramInt3, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glTexCoordPointer0(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, long paramLong);
  

  public void glTexCoordPointer(int paramInt1, int paramInt2, int paramInt3, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glTexCoordPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexCoordPointer" }));
    }
    dispatch_glTexCoordPointer0(paramInt1, paramInt2, paramInt3, paramLong, l);
  }
  

  private native void dispatch_glTexCoordPointer0(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2);
  

  public void glTexEnvi(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexEnvi;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvi" }));
    }
    dispatch_glTexEnvi1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glTexEnvi1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexEnvx(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexEnvx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvx" }));
    }
    dispatch_glTexEnvx1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTexEnvx1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexEnviv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexEnviv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnviv" }));
    }
    dispatch_glTexEnviv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexEnviv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexEnviv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexEnviv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnviv" }));
    }
    dispatch_glTexEnviv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexEnvxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexEnvxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvxv" }));
    }
    dispatch_glTexEnvxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexEnvxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexEnvxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexEnvxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexEnvxv" }));
    }
    dispatch_glTexEnvxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt7, paramInt8, paramInt4, paramInt5, 1, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage2D" }));
    }
    dispatch_glTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage2D" }));
    }
    dispatch_glTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glTexParameteri(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteri" }));
    }
    dispatch_glTexParameteri1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glTexParameteri1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexParameterx(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexParameterx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterx" }));
    }
    dispatch_glTexParameterx1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTexParameterx1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteriv" }));
    }
    dispatch_glTexParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteriv" }));
    }
    dispatch_glTexParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexParameterxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterxv" }));
    }
    dispatch_glTexParameterxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameterxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameterxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexParameterxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterxv" }));
    }
    dispatch_glTexParameterxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt7, paramInt8, paramInt5, paramInt6, 1, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage2D" }));
    }
    dispatch_glTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage2D" }));
    }
    dispatch_glTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glTranslatex(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTranslatex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTranslatex" }));
    }
    dispatch_glTranslatex1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTranslatex1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glVertexPointer(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glVertexPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexPointer" }));
    }
    dispatch_glVertexPointer0(paramInt1, paramInt2, paramInt3, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glVertexPointer0(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, long paramLong);
  

  public void glVertexPointer(int paramInt1, int paramInt2, int paramInt3, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glVertexPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexPointer" }));
    }
    dispatch_glVertexPointer0(paramInt1, paramInt2, paramInt3, paramLong, l);
  }
  

  private native void dispatch_glVertexPointer0(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2);
  

  public void glViewport(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glViewport;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewport" }));
    }
    dispatch_glViewport1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glViewport1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glPointSizePointerOES(int paramInt1, int paramInt2, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glPointSizePointerOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPointSizePointerOES" }));
    }
    dispatch_glPointSizePointerOES1(paramInt1, paramInt2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glPointSizePointerOES1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexStorage1D(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glTexStorage1D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage1D" }));
    }
    dispatch_glTexStorage1D1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glTexStorage1D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glTexStorage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glTexStorage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage2D" }));
    }
    dispatch_glTexStorage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glTexStorage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glTexStorage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glTexStorage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage3D" }));
    }
    dispatch_glTexStorage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glTexStorage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glTextureStorage1DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glTextureStorage1DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage1DEXT" }));
    }
    dispatch_glTextureStorage1DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glTextureStorage1DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glTextureStorage2DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glTextureStorage2DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage2DEXT" }));
    }
    dispatch_glTextureStorage2DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glTextureStorage2DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glTextureStorage3DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7)
  {
    long l = _pat._addressof_glTextureStorage3DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage3DEXT" }));
    }
    dispatch_glTextureStorage3DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, l);
  }
  

  private native void dispatch_glTextureStorage3DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong);
  

  public void glBlendEquationSeparate(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendEquationSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationSeparate" }));
    }
    dispatch_glBlendEquationSeparate1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendEquationSeparate1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendFuncSeparate(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glBlendFuncSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFuncSeparate" }));
    }
    dispatch_glBlendFuncSeparate1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glBlendFuncSeparate1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glBlendEquation(int paramInt)
  {
    long l = _pat._addressof_glBlendEquation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquation" }));
    }
    dispatch_glBlendEquation1(paramInt, l);
  }
  

  private native void dispatch_glBlendEquation1(int paramInt, long paramLong);
  

  public void glDrawTexsOES(short paramShort1, short paramShort2, short paramShort3, short paramShort4, short paramShort5)
  {
    long l = _pat._addressof_glDrawTexsOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexsOES" }));
    }
    dispatch_glDrawTexsOES1(paramShort1, paramShort2, paramShort3, paramShort4, paramShort5, l);
  }
  

  private native void dispatch_glDrawTexsOES1(short paramShort1, short paramShort2, short paramShort3, short paramShort4, short paramShort5, long paramLong);
  

  public void glDrawTexiOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glDrawTexiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexiOES" }));
    }
    dispatch_glDrawTexiOES1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glDrawTexiOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glDrawTexxOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glDrawTexxOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexxOES" }));
    }
    dispatch_glDrawTexxOES1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glDrawTexxOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glDrawTexsvOES(java.nio.ShortBuffer paramShortBuffer)
  {
    boolean bool = Buffers.isDirect(paramShortBuffer);
    long l = _pat._addressof_glDrawTexsvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexsvOES" }));
    }
    dispatch_glDrawTexsvOES1(bool ? paramShortBuffer : Buffers.getArray(paramShortBuffer), bool ? Buffers.getDirectBufferByteOffset(paramShortBuffer) : Buffers.getIndirectBufferByteOffset(paramShortBuffer), bool, l);
  }
  


  private native void dispatch_glDrawTexsvOES1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glDrawTexsvOES(short[] paramArrayOfShort, int paramInt)
  {
    if ((paramArrayOfShort != null) && (paramArrayOfShort.length <= paramInt))
      throw new GLException("array offset argument \"coords_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfShort.length + ")");
    long l = _pat._addressof_glDrawTexsvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexsvOES" }));
    }
    dispatch_glDrawTexsvOES1(paramArrayOfShort, 2 * paramInt, false, l);
  }
  


  public void glDrawTexivOES(IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDrawTexivOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexivOES" }));
    }
    dispatch_glDrawTexivOES1(bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDrawTexivOES1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glDrawTexivOES(int[] paramArrayOfInt, int paramInt)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt))
      throw new GLException("array offset argument \"coords_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDrawTexivOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexivOES" }));
    }
    dispatch_glDrawTexivOES1(paramArrayOfInt, 4 * paramInt, false, l);
  }
  


  public void glDrawTexxvOES(IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDrawTexxvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexxvOES" }));
    }
    dispatch_glDrawTexxvOES1(bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDrawTexxvOES1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glDrawTexxvOES(int[] paramArrayOfInt, int paramInt)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt))
      throw new GLException("array offset argument \"coords_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDrawTexxvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexxvOES" }));
    }
    dispatch_glDrawTexxvOES1(paramArrayOfInt, 4 * paramInt, false, l);
  }
  

  public void glDrawTexfOES(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5)
  {
    long l = _pat._addressof_glDrawTexfOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexfOES" }));
    }
    dispatch_glDrawTexfOES1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, l);
  }
  


  private native void dispatch_glDrawTexfOES1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, long paramLong);
  

  public void glDrawTexfvOES(FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glDrawTexfvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexfvOES" }));
    }
    dispatch_glDrawTexfvOES1(bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glDrawTexfvOES1(Object paramObject, int paramInt, boolean paramBoolean, long paramLong);
  

  public void glDrawTexfvOES(float[] paramArrayOfFloat, int paramInt)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt))
      throw new GLException("array offset argument \"coords_offset\" (" + paramInt + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glDrawTexfvOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawTexfvOES" }));
    }
    dispatch_glDrawTexfvOES1(paramArrayOfFloat, 4 * paramInt, false, l);
  }
  

  public void glEGLImageTargetTexture2DOES(int paramInt, long paramLong)
  {
    long l = _pat._addressof_glEGLImageTargetTexture2DOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEGLImageTargetTexture2DOES" }));
    }
    dispatch_glEGLImageTargetTexture2DOES1(paramInt, paramLong, l);
  }
  

  private native void dispatch_glEGLImageTargetTexture2DOES1(int paramInt, long paramLong1, long paramLong2);
  

  public void glEGLImageTargetRenderbufferStorageOES(int paramInt, long paramLong)
  {
    long l = _pat._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEGLImageTargetRenderbufferStorageOES" }));
    }
    dispatch_glEGLImageTargetRenderbufferStorageOES1(paramInt, paramLong, l);
  }
  

  private native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int paramInt, long paramLong1, long paramLong2);
  

  public boolean glIsRenderbuffer(int paramInt)
  {
    long l = _pat._addressof_glIsRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsRenderbuffer" }));
    }
    return dispatch_glIsRenderbuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsRenderbuffer1(int paramInt, long paramLong);
  

  public void glBindRenderbuffer(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindRenderbuffer" }));
    }
    dispatch_glBindRenderbuffer1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glBindRenderbuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDeleteRenderbuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteRenderbuffers" }));
    }
    dispatch_glDeleteRenderbuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteRenderbuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteRenderbuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteRenderbuffers" }));
    }
    dispatch_glDeleteRenderbuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenRenderbuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenRenderbuffers" }));
    }
    dispatch_glGenRenderbuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenRenderbuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenRenderbuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenRenderbuffers" }));
    }
    dispatch_glGenRenderbuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glRenderbufferStorage(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glRenderbufferStorage;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorage" }));
    }
    dispatch_glRenderbufferStorage1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glRenderbufferStorage1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glGetRenderbufferParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetRenderbufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetRenderbufferParameteriv" }));
    }
    dispatch_glGetRenderbufferParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetRenderbufferParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetRenderbufferParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetRenderbufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetRenderbufferParameteriv" }));
    }
    dispatch_glGetRenderbufferParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public boolean glIsFramebuffer(int paramInt)
  {
    long l = _pat._addressof_glIsFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsFramebuffer" }));
    }
    return dispatch_glIsFramebuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsFramebuffer1(int paramInt, long paramLong);
  

  public void glBindFramebuffer(int paramInt1, int paramInt2)
  {
    if (0 == paramInt2) {
      if ((36160 == paramInt1) || (36009 == paramInt1)) {
        paramInt2 = _context.getDefaultDrawFramebuffer();
      } else if (36008 == paramInt1) {
        paramInt2 = _context.getDefaultReadFramebuffer();
      }
    }
    long l = _pat._addressof_glBindFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFramebuffer" }));
    }
    dispatch_glBindFramebuffer1(paramInt1, paramInt2, l);
    _context.setBoundFramebuffer(paramInt1, paramInt2);
  }
  


  private native void dispatch_glBindFramebuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDeleteFramebuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteFramebuffers" }));
    }
    dispatch_glDeleteFramebuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteFramebuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteFramebuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteFramebuffers" }));
    }
    dispatch_glDeleteFramebuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenFramebuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenFramebuffers" }));
    }
    dispatch_glGenFramebuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenFramebuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenFramebuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenFramebuffers" }));
    }
    dispatch_glGenFramebuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public int glCheckFramebufferStatus(int paramInt)
  {
    long l = _pat._addressof_glCheckFramebufferStatus;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCheckFramebufferStatus" }));
    }
    return dispatch_glCheckFramebufferStatus1(paramInt, l);
  }
  

  private native int dispatch_glCheckFramebufferStatus1(int paramInt, long paramLong);
  

  public void glFramebufferRenderbuffer(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glFramebufferRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferRenderbuffer" }));
    }
    dispatch_glFramebufferRenderbuffer1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glFramebufferRenderbuffer1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glFramebufferTexture2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glFramebufferTexture2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2D" }));
    }
    dispatch_glFramebufferTexture2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glFramebufferTexture2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glGetFramebufferAttachmentParameteriv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferAttachmentParameteriv" }));
    }
    dispatch_glGetFramebufferAttachmentParameteriv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetFramebufferAttachmentParameteriv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferAttachmentParameteriv" }));
    }
    dispatch_glGetFramebufferAttachmentParameteriv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  

  public void glGenerateMipmap(int paramInt)
  {
    long l = _pat._addressof_glGenerateMipmap;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenerateMipmap" }));
    }
    dispatch_glGenerateMipmap1(paramInt, l);
  }
  







  private native void dispatch_glGenerateMipmap1(int paramInt, long paramLong);
  







  private long glMapBufferDelegate(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glMapBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMapBuffer" }));
    }
    return dispatch_glMapBufferDelegate1(paramInt1, paramInt2, l);
  }
  







  private native long dispatch_glMapBufferDelegate1(int paramInt1, int paramInt2, long paramLong);
  







  private boolean glUnmapBufferDelegate(int paramInt)
  {
    long l = _pat._addressof_glUnmapBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUnmapBuffer" }));
    }
    return dispatch_glUnmapBufferDelegate1(paramInt, l);
  }
  

  private native boolean dispatch_glUnmapBufferDelegate1(int paramInt, long paramLong);
  

  public void glCurrentPaletteMatrixOES(int paramInt)
  {
    long l = _pat._addressof_glCurrentPaletteMatrixOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCurrentPaletteMatrixOES" }));
    }
    dispatch_glCurrentPaletteMatrixOES1(paramInt, l);
  }
  

  private native void dispatch_glCurrentPaletteMatrixOES1(int paramInt, long paramLong);
  

  public void glLoadPaletteFromModelViewMatrixOES()
  {
    long l = _pat._addressof_glLoadPaletteFromModelViewMatrixOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLoadPaletteFromModelViewMatrixOES" }));
    }
    dispatch_glLoadPaletteFromModelViewMatrixOES1(l);
  }
  


  private native void dispatch_glLoadPaletteFromModelViewMatrixOES1(long paramLong);
  

  public void glMatrixIndexPointerOES(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glMatrixIndexPointerOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMatrixIndexPointerOES" }));
    }
    dispatch_glMatrixIndexPointerOES1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glMatrixIndexPointerOES1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  


  public void glWeightPointerOES(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glWeightPointerOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glWeightPointerOES" }));
    }
    dispatch_glWeightPointerOES1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  



  private native void dispatch_glWeightPointerOES1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  


  public int glQueryMatrixxOES(IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glQueryMatrixxOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glQueryMatrixxOES" }));
    }
    return dispatch_glQueryMatrixxOES1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native int dispatch_glQueryMatrixxOES1(Object paramObject1, int paramInt1, boolean paramBoolean1, Object paramObject2, int paramInt2, boolean paramBoolean2, long paramLong);
  


  public int glQueryMatrixxOES(int[] paramArrayOfInt1, int paramInt1, int[] paramArrayOfInt2, int paramInt2)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"mantissa_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt2))
      throw new GLException("array offset argument \"exponent_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glQueryMatrixxOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glQueryMatrixxOES" }));
    }
    return dispatch_glQueryMatrixxOES1(paramArrayOfInt1, 4 * paramInt1, false, paramArrayOfInt2, 4 * paramInt2, false, l);
  }
  

  public void glTexGenf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glTexGenf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenf" }));
    }
    dispatch_glTexGenf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glTexGenf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glTexGenfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glTexGenfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenfv" }));
    }
    dispatch_glTexGenfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glTexGenfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexGenfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glTexGenfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenfv" }));
    }
    dispatch_glTexGenfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glTexGeni(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexGeni;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGeni" }));
    }
    dispatch_glTexGeni1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTexGeni1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexGeniv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexGeniv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGeniv" }));
    }
    dispatch_glTexGeniv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexGeniv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexGeniv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexGeniv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGeniv" }));
    }
    dispatch_glTexGeniv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glTexGenx(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexGenx;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenx" }));
    }
    dispatch_glTexGenx1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTexGenx1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexGenxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexGenxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenxv" }));
    }
    dispatch_glTexGenxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexGenxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexGenxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexGenxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexGenxv" }));
    }
    dispatch_glTexGenxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexGenfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetTexGenfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGenfv" }));
    }
    dispatch_glGetTexGenfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexGenfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexGenfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetTexGenfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGenfv" }));
    }
    dispatch_glGetTexGenfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetTexGeniv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexGeniv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGeniv" }));
    }
    dispatch_glGetTexGeniv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexGeniv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexGeniv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexGeniv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGeniv" }));
    }
    dispatch_glGetTexGeniv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexGenxv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexGenxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGenxv" }));
    }
    dispatch_glGetTexGenxv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexGenxv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexGenxv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexGenxv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexGenxv" }));
    }
    dispatch_glGetTexGenxv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glBindVertexArrayOES(int paramInt)
  {
    long l = _pat._addressof_glBindVertexArrayOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindVertexArrayOES" }));
    }
    dispatch_glBindVertexArrayOES1(paramInt, l);
  }
  


  private native void dispatch_glBindVertexArrayOES1(int paramInt, long paramLong);
  

  public void glDeleteVertexArraysOES(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArraysOES" }));
    }
    dispatch_glDeleteVertexArraysOES1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteVertexArraysOES1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteVertexArraysOES(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArraysOES" }));
    }
    dispatch_glDeleteVertexArraysOES1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenVertexArraysOES(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArraysOES" }));
    }
    dispatch_glGenVertexArraysOES1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenVertexArraysOES1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenVertexArraysOES(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArraysOES" }));
    }
    dispatch_glGenVertexArraysOES1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsVertexArrayOES(int paramInt)
  {
    long l = _pat._addressof_glIsVertexArrayOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsVertexArrayOES" }));
    }
    return dispatch_glIsVertexArrayOES1(paramInt, l);
  }
  

  private native boolean dispatch_glIsVertexArrayOES1(int paramInt, long paramLong);
  

  public void glCopyTextureLevelsAPPLE(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glCopyTextureLevelsAPPLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTextureLevelsAPPLE" }));
    }
    dispatch_glCopyTextureLevelsAPPLE1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glCopyTextureLevelsAPPLE1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glRenderbufferStorageMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisample" }));
    }
    dispatch_glRenderbufferStorageMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glResolveMultisampleFramebuffer()
  {
    long l = _pat._addressof_glResolveMultisampleFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glResolveMultisampleFramebuffer" }));
    }
    dispatch_glResolveMultisampleFramebuffer1(l);
  }
  


  private native void dispatch_glResolveMultisampleFramebuffer1(long paramLong);
  

  public void glDiscardFramebufferEXT(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDiscardFramebufferEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDiscardFramebufferEXT" }));
    }
    dispatch_glDiscardFramebufferEXT1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDiscardFramebufferEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glDiscardFramebufferEXT(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"attachments_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDiscardFramebufferEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDiscardFramebufferEXT" }));
    }
    dispatch_glDiscardFramebufferEXT1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  















  private long glMapBufferRangeDelegate(int paramInt1, long paramLong1, long paramLong2, int paramInt2)
  {
    long l = _pat._addressof_glMapBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMapBufferRange" }));
    }
    return dispatch_glMapBufferRangeDelegate1(paramInt1, paramLong1, paramLong2, paramInt2, l);
  }
  








  private native long dispatch_glMapBufferRangeDelegate1(int paramInt1, long paramLong1, long paramLong2, int paramInt2, long paramLong3);
  








  public void glFlushMappedBufferRange(int paramInt, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glFlushMappedBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFlushMappedBufferRange" }));
    }
    dispatch_glFlushMappedBufferRange1(paramInt, paramLong1, paramLong2, l);
  }
  

  private native void dispatch_glFlushMappedBufferRange1(int paramInt, long paramLong1, long paramLong2, long paramLong3);
  

  public void glRenderbufferStorageMultisampleEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisampleEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisampleEXT" }));
    }
    dispatch_glRenderbufferStorageMultisampleEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisampleEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFramebufferTexture2DMultisampleEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTexture2DMultisampleEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2DMultisampleEXT" }));
    }
    dispatch_glFramebufferTexture2DMultisampleEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glFramebufferTexture2DMultisampleEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public int glGetGraphicsResetStatus()
  {
    long l = _pat._addressof_glGetGraphicsResetStatus;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetGraphicsResetStatus" }));
    }
    return dispatch_glGetGraphicsResetStatus1(l);
  }
  


  private native int dispatch_glGetGraphicsResetStatus1(long paramLong);
  

  public void glReadnPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glReadnPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadnPixels" }));
    }
    dispatch_glReadnPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glReadnPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Object paramObject, int paramInt8, boolean paramBoolean, long paramLong);
  


  public void glGetnUniformfv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetnUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformfv" }));
    }
    dispatch_glGetnUniformfv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetnUniformfv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetnUniformfv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetnUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformfv" }));
    }
    dispatch_glGetnUniformfv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glGetnUniformiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetnUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformiv" }));
    }
    dispatch_glGetnUniformiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetnUniformiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetnUniformiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetnUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformiv" }));
    }
    dispatch_glGetnUniformiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glClipPlanefIMG(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glClipPlanefIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanefIMG" }));
    }
    dispatch_glClipPlanefIMG1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glClipPlanefIMG1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glClipPlanefIMG(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"arg1_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glClipPlanefIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanefIMG" }));
    }
    dispatch_glClipPlanefIMG1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glClipPlanexIMG(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glClipPlanexIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanexIMG" }));
    }
    dispatch_glClipPlanexIMG1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glClipPlanexIMG1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glClipPlanexIMG(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arg1_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glClipPlanexIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClipPlanexIMG" }));
    }
    dispatch_glClipPlanexIMG1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glRenderbufferStorageMultisampleIMG(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisampleIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisampleIMG" }));
    }
    dispatch_glRenderbufferStorageMultisampleIMG1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisampleIMG1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFramebufferTexture2DMultisampleIMG(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTexture2DMultisampleIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2DMultisampleIMG" }));
    }
    dispatch_glFramebufferTexture2DMultisampleIMG1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glFramebufferTexture2DMultisampleIMG1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  


  public void glGetDriverControlsQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetDriverControlsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlsQCOM" }));
    }
    dispatch_glGetDriverControlsQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetDriverControlsQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glGetDriverControlsQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"num_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"driverControls_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetDriverControlsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlsQCOM" }));
    }
    dispatch_glGetDriverControlsQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glGetDriverControlStringQCOM(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetDriverControlStringQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlStringQCOM" }));
    }
    dispatch_glGetDriverControlStringQCOM1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetDriverControlStringQCOM1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetDriverControlStringQCOM(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"driverControlString_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetDriverControlStringQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlStringQCOM" }));
    }
    dispatch_glGetDriverControlStringQCOM1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  

  public void glEnableDriverControlQCOM(int paramInt)
  {
    long l = _pat._addressof_glEnableDriverControlQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableDriverControlQCOM" }));
    }
    dispatch_glEnableDriverControlQCOM1(paramInt, l);
  }
  

  private native void dispatch_glEnableDriverControlQCOM1(int paramInt, long paramLong);
  

  public void glDisableDriverControlQCOM(int paramInt)
  {
    long l = _pat._addressof_glDisableDriverControlQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableDriverControlQCOM" }));
    }
    dispatch_glDisableDriverControlQCOM1(paramInt, l);
  }
  


  private native void dispatch_glDisableDriverControlQCOM1(int paramInt, long paramLong);
  


  public void glExtGetTexturesQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetTexturesQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexturesQCOM" }));
    }
    dispatch_glExtGetTexturesQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetTexturesQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetTexturesQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numTextures_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetTexturesQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexturesQCOM" }));
    }
    dispatch_glExtGetTexturesQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetBuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetBuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBuffersQCOM" }));
    }
    dispatch_glExtGetBuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetBuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetBuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numBuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetBuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBuffersQCOM" }));
    }
    dispatch_glExtGetBuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetRenderbuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetRenderbuffersQCOM" }));
    }
    dispatch_glExtGetRenderbuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetRenderbuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetRenderbuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetRenderbuffersQCOM" }));
    }
    dispatch_glExtGetRenderbuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetFramebuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetFramebuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetFramebuffersQCOM" }));
    }
    dispatch_glExtGetFramebuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetFramebuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetFramebuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetFramebuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetFramebuffersQCOM" }));
    }
    dispatch_glExtGetFramebuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  


  public void glExtGetTexLevelParameterivQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexLevelParameterivQCOM" }));
    }
    dispatch_glExtGetTexLevelParameterivQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject, int paramInt5, boolean paramBoolean, long paramLong);
  

  public void glExtGetTexLevelParameterivQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt5))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexLevelParameterivQCOM" }));
    }
    dispatch_glExtGetTexLevelParameterivQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, 4 * paramInt5, false, l);
  }
  

  public void glExtTexObjectStateOverrideiQCOM(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glExtTexObjectStateOverrideiQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtTexObjectStateOverrideiQCOM" }));
    }
    dispatch_glExtTexObjectStateOverrideiQCOM1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glExtTexObjectStateOverrideiQCOM1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glExtGetTexSubImageQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glExtGetTexSubImageQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexSubImageQCOM" }));
    }
    dispatch_glExtGetTexSubImageQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glExtGetTexSubImageQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Object paramObject, int paramInt11, boolean paramBoolean, long paramLong);
  


  public void glExtGetBufferPointervQCOM(int paramInt, com.jogamp.common.nio.PointerBuffer paramPointerBuffer)
  {
    if (!Buffers.isDirect(paramPointerBuffer))
      throw new GLException("Argument \"params\" is not a direct buffer");
    long l = _pat._addressof_glExtGetBufferPointervQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBufferPointervQCOM" }));
    }
    dispatch_glExtGetBufferPointervQCOM0(paramInt, paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(paramPointerBuffer), l);
  }
  



  private native void dispatch_glExtGetBufferPointervQCOM0(int paramInt1, Object paramObject, int paramInt2, long paramLong);
  


  public void glExtGetShadersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetShadersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetShadersQCOM" }));
    }
    dispatch_glExtGetShadersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetShadersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetShadersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"shaders_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numShaders_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetShadersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetShadersQCOM" }));
    }
    dispatch_glExtGetShadersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetProgramsQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetProgramsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramsQCOM" }));
    }
    dispatch_glExtGetProgramsQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetProgramsQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetProgramsQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"programs_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numPrograms_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetProgramsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramsQCOM" }));
    }
    dispatch_glExtGetProgramsQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  

  public boolean glExtIsProgramBinaryQCOM(int paramInt)
  {
    long l = _pat._addressof_glExtIsProgramBinaryQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtIsProgramBinaryQCOM" }));
    }
    return dispatch_glExtIsProgramBinaryQCOM1(paramInt, l);
  }
  


  private native boolean dispatch_glExtIsProgramBinaryQCOM1(int paramInt, long paramLong);
  


  public void glExtGetProgramBinarySourceQCOM(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer, IntBuffer paramIntBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramByteBuffer);
    boolean bool2 = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramBinarySourceQCOM" }));
    }
    dispatch_glExtGetProgramBinarySourceQCOM1(paramInt1, paramInt2, bool1 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool1, bool2 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool2, l);
  }
  


  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glExtGetProgramBinarySourceQCOM(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"source_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramBinarySourceQCOM" }));
    }
    dispatch_glExtGetProgramBinarySourceQCOM1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  

  public void glStartTilingQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glStartTilingQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStartTilingQCOM" }));
    }
    dispatch_glStartTilingQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glStartTilingQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glEndTilingQCOM(int paramInt)
  {
    long l = _pat._addressof_glEndTilingQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEndTilingQCOM" }));
    }
    dispatch_glEndTilingQCOM1(paramInt, l);
  }
  



  private native void dispatch_glEndTilingQCOM1(int paramInt, long paramLong);
  


  public void glOrtho(double paramDouble1, double paramDouble2, double paramDouble3, double paramDouble4, double paramDouble5, double paramDouble6) { glOrthof((float)paramDouble1, (float)paramDouble2, (float)paramDouble3, (float)paramDouble4, (float)paramDouble5, (float)paramDouble6); }
  
  public void glFrustum(double paramDouble1, double paramDouble2, double paramDouble3, double paramDouble4, double paramDouble5, double paramDouble6) { glFrustumf((float)paramDouble1, (float)paramDouble2, (float)paramDouble3, (float)paramDouble4, (float)paramDouble5, (float)paramDouble6); }
  
  public void glClearDepth(double paramDouble) { glClearDepthf((float)paramDouble); }
  
  public void glDepthRange(double paramDouble1, double paramDouble2) { glDepthRangef((float)paramDouble1, (float)paramDouble2); }
  


  public com.jogamp.opengl.GLProfile getGLProfile()
  {
    return glProfile;
  }
  
  public final int getBoundBuffer(int paramInt)
  {
    return bufferStateTracker.getBoundBufferObject(paramInt, this);
  }
  
  public final com.jogamp.opengl.GLBufferStorage getBufferStorage(int paramInt)
  {
    return bufferObjectTracker.getBufferStorage(paramInt);
  }
  
  public final boolean isVBOArrayBound()
  {
    return checkArrayVBOBound(false);
  }
  
  public final boolean isVBOElementArrayBound()
  {
    return checkElementVBOBound(false);
  }
  
  public final com.jogamp.opengl.GL getDownstreamGL() throws GLException
  {
    return null;
  }
  
  public final com.jogamp.opengl.GL getRootGL() throws GLException
  {
    return this;
  }
  
  public final boolean isGL()
  {
    return true;
  }
  
  public final com.jogamp.opengl.GL getGL() throws GLException
  {
    return this;
  }
  
  public final boolean isFunctionAvailable(String paramString)
  {
    return _context.isFunctionAvailable(paramString);
  }
  
  public final boolean isExtensionAvailable(String paramString)
  {
    return _context.isExtensionAvailable(paramString);
  }
  

  public final Object getExtension(String paramString)
  {
    return null;
  }
  
  public final boolean hasBasicFBOSupport()
  {
    return _context.hasBasicFBOSupport();
  }
  
  public final boolean hasFullFBOSupport()
  {
    return _context.hasFullFBOSupport();
  }
  
  public final int getMaxRenderbufferSamples()
  {
    return _context.getMaxRenderbufferSamples();
  }
  
  public final boolean isTextureFormatBGRA8888Available()
  {
    return _context.isTextureFormatBGRA8888Available();
  }
  
  public final com.jogamp.opengl.GLContext getContext()
  {
    return _context;
  }
  



  public final void setSwapInterval(int paramInt)
  {
    _context.setSwapInterval(paramInt);
  }
  



  public final int getSwapInterval()
  {
    return _context.getSwapInterval();
  }
  
  public final Object getPlatformGLExtensions()
  {
    return _context.getPlatformGLExtensions();
  }
  
  public final int getBoundFramebuffer(int paramInt)
  {
    return _context.getBoundFramebuffer(paramInt);
  }
  
  public final int getDefaultDrawFramebuffer()
  {
    return _context.getDefaultDrawFramebuffer();
  }
  
  public final int getDefaultReadFramebuffer()
  {
    return _context.getDefaultReadFramebuffer();
  }
  
  public final int getDefaultReadBuffer()
  {
    return _context.getDefaultReadBuffer();
  }
  








  public final void glBufferData(int paramInt1, long paramLong, Buffer paramBuffer, int paramInt2)
  {
    bufferObjectTracker.createBufferStorage(bufferStateTracker, this, paramInt1, paramLong, paramBuffer, paramInt2, 0, glBufferDataDispatch);
  }
  

  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch = new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch()
  {
    public final void create(int paramAnonymousInt1, long paramAnonymousLong, Buffer paramAnonymousBuffer, int paramAnonymousInt2) {
      GLES1Impl.this.glBufferDataDelegate(paramAnonymousInt1, paramAnonymousLong, paramAnonymousBuffer, paramAnonymousInt2);
    }
  };
  


  public boolean glUnmapBuffer(int paramInt) { return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, paramInt, glUnmapBufferDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch = new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch()
  {
    public final boolean unmap(int paramAnonymousInt) {
      return GLES1Impl.this.glUnmapBufferDelegate(paramAnonymousInt);
    }
  };
  
  public final ByteBuffer glMapBuffer(int paramInt1, int paramInt2)
  {
    return mapBuffer(paramInt1, paramInt2).getMappedBuffer();
  }
  

  public final com.jogamp.opengl.GLBufferStorage mapBuffer(int paramInt1, int paramInt2) { return bufferObjectTracker.mapBuffer(bufferStateTracker, this, paramInt1, paramInt2, glMapBufferDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch = new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch()
  {
    public final ByteBuffer allocNioByteBuffer(long paramAnonymousLong1, long paramAnonymousLong2) { return GLES1Impl.this.newDirectByteBuffer(paramAnonymousLong1, paramAnonymousLong2); }
    
    public final long mapBuffer(int paramAnonymousInt1, int paramAnonymousInt2) { return GLES1Impl.this.glMapBufferDelegate(paramAnonymousInt1, paramAnonymousInt2); }
  };
  

  public final ByteBuffer glMapBufferRange(int paramInt1, long paramLong1, long paramLong2, int paramInt2)
  {
    return mapBufferRange(paramInt1, paramLong1, paramLong2, paramInt2).getMappedBuffer();
  }
  

  public final com.jogamp.opengl.GLBufferStorage mapBufferRange(int paramInt1, long paramLong1, long paramLong2, int paramInt2) { return bufferObjectTracker.mapBuffer(bufferStateTracker, this, paramInt1, paramLong1, paramLong2, paramInt2, glMapBufferRangeDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch = new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch()
  {
    public final ByteBuffer allocNioByteBuffer(long paramAnonymousLong1, long paramAnonymousLong2) { return GLES1Impl.this.newDirectByteBuffer(paramAnonymousLong1, paramAnonymousLong2); }
    
    public final long mapBuffer(int paramAnonymousInt1, long paramAnonymousLong1, long paramAnonymousLong2, int paramAnonymousInt2) { return GLES1Impl.this.glMapBufferRangeDelegate(paramAnonymousInt1, paramAnonymousLong1, paramAnonymousLong2, paramAnonymousInt2); }
  };
  
  private final GLES1ProcAddressTable _pat;
  
  private native ByteBuffer newDirectByteBuffer(long paramLong1, long paramLong2);
  
  public GLES1Impl(com.jogamp.opengl.GLProfile paramGLProfile, GLContextImpl paramGLContextImpl)
  {
    _context = paramGLContextImpl;
    _pat = ((GLES1ProcAddressTable)_context.getGLProcAddressTable());
    bufferObjectTracker = paramGLContextImpl.getBufferObjectTracker();
    bufferStateTracker = paramGLContextImpl.getBufferStateTracker();
    glStateTracker = paramGLContextImpl.getGLStateTracker();
    glProfile = paramGLProfile;
  }
  

  public final void finalizeInit() {}
  
  private int[] imageSizeTemp = new int[1];
  
  private final int imageSizeInBytes(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean) {
    return com.jogamp.opengl.util.GLBuffers.sizeof(this, imageSizeTemp, paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramBoolean); }
  

  public final boolean isGL4bc()
  {
    return false;
  }
  
  public final boolean isGL4()
  {
    return false;
  }
  
  public final boolean isGL3bc()
  {
    return false;
  }
  
  public final boolean isGL3()
  {
    return false;
  }
  
  public final boolean isGL2()
  {
    return false;
  }
  
  public final boolean isGLES1()
  {
    return true;
  }
  
  public final boolean isGLES2()
  {
    return false;
  }
  
  public final boolean isGLES3()
  {
    return false;
  }
  
  public final boolean isGLES()
  {
    return true;
  }
  
  public final boolean isGL2ES1()
  {
    return true;
  }
  
  public final boolean isGL2ES2()
  {
    return false;
  }
  
  public final boolean isGL2ES3()
  {
    return false;
  }
  
  public final boolean isGL3ES3()
  {
    return false;
  }
  
  public final boolean isGL4ES3()
  {
    return false;
  }
  
  public final boolean isGL4core()
  {
    return false;
  }
  
  public final boolean isGL3core()
  {
    return false;
  }
  
  public final boolean isGLcore()
  {
    return false;
  }
  
  public final boolean isGLES2Compatible()
  {
    return false;
  }
  
  public final boolean isGLES3Compatible()
  {
    return false;
  }
  
  public final boolean isGLES31Compatible()
  {
    return false;
  }
  
  public final boolean isGLES32Compatible()
  {
    return false;
  }
  
  public final boolean isGL2GL3()
  {
    return false;
  }
  
  public final boolean hasGLSL()
  {
    return false;
  }
  
  public boolean isNPOTTextureAvailable()
  {
    return false;
  }
  
  public final com.jogamp.opengl.GL4bc getGL4bc() throws GLException
  {
    throw new GLException("Not a GL4bc implementation");
  }
  
  public final com.jogamp.opengl.GL4 getGL4() throws GLException
  {
    throw new GLException("Not a GL4 implementation");
  }
  
  public final com.jogamp.opengl.GL3bc getGL3bc() throws GLException
  {
    throw new GLException("Not a GL3bc implementation");
  }
  
  public final com.jogamp.opengl.GL3 getGL3() throws GLException
  {
    throw new GLException("Not a GL3 implementation");
  }
  
  public final com.jogamp.opengl.GL2 getGL2() throws GLException
  {
    throw new GLException("Not a GL2 implementation");
  }
  
  public final com.jogamp.opengl.GLES1 getGLES1() throws GLException
  {
    return this;
  }
  
  public final com.jogamp.opengl.GLES2 getGLES2() throws GLException
  {
    throw new GLException("Not a GLES2 implementation");
  }
  
  public final com.jogamp.opengl.GLES3 getGLES3() throws GLException
  {
    throw new GLException("Not a GLES3 implementation");
  }
  
  public final com.jogamp.opengl.GL2ES1 getGL2ES1() throws GLException
  {
    return this;
  }
  
  public final com.jogamp.opengl.GL2ES3 getGL2ES3() throws GLException
  {
    throw new GLException("Not a GL2ES3 implementation");
  }
  
  public final com.jogamp.opengl.GL2ES2 getGL2ES2() throws GLException
  {
    throw new GLException("Not a GL2ES2 implementation");
  }
  
  public final com.jogamp.opengl.GL3ES3 getGL3ES3() throws GLException
  {
    throw new GLException("Not a GL3ES3 implementation");
  }
  
  public final com.jogamp.opengl.GL4ES3 getGL4ES3() throws GLException
  {
    throw new GLException("Not a GL4ES3 implementation");
  }
  
  public final com.jogamp.opengl.GL2GL3 getGL2GL3() throws GLException
  {
    throw new GLException("Not a GL2GL3 implementation");
  }
  





  private final boolean checkBufferObject(boolean paramBoolean1, int paramInt, String paramString, boolean paramBoolean2)
  {
    int i = bufferStateTracker.getBoundBufferObject(paramInt, this);
    if (paramBoolean1) {
      if (0 == i) {
        if (paramBoolean2) {
          throw new GLException(paramString + " must be bound to call this method");
        }
        return false;
      }
    }
    else if (0 != i) {
      if (paramBoolean2) {
        throw new GLException(paramString + " must be unbound to call this method");
      }
      return false;
    }
    
    return true;
  }
  
  private final boolean checkArrayVBOUnbound(boolean paramBoolean) {
    return checkBufferObject(false, 34962, "array vertex_buffer_object", paramBoolean);
  }
  

  private final boolean checkArrayVBOBound(boolean paramBoolean)
  {
    return checkBufferObject(true, 34962, "array vertex_buffer_object", paramBoolean);
  }
  

  private final boolean checkElementVBOUnbound(boolean paramBoolean)
  {
    return checkBufferObject(false, 34963, "element vertex_buffer_object", paramBoolean);
  }
  

  private final boolean checkElementVBOBound(boolean paramBoolean)
  {
    return checkBufferObject(true, 34963, "element vertex_buffer_object", paramBoolean);
  }
  


  private final boolean checkUnpackPBOUnbound(boolean paramBoolean)
  {
    return true;
  }
  
  private final boolean checkUnpackPBOBound(boolean paramBoolean)
  {
    return false;
  }
  
  private final boolean checkPackPBOUnbound(boolean paramBoolean)
  {
    return true;
  }
  
  private final boolean checkPackPBOBound(boolean paramBoolean)
  {
    return false;
  }
  
  public final void glVertexPointer(GLArrayData paramGLArrayData)
  {
    if (paramGLArrayData.getComponentCount() == 0) return;
    if (paramGLArrayData.isVBO()) {
      glVertexPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getVBOOffset());
    } else {
      glVertexPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getBuffer());
    }
  }
  
  public final void glColorPointer(GLArrayData paramGLArrayData) {
    if (paramGLArrayData.getComponentCount() == 0) return;
    if (paramGLArrayData.isVBO()) {
      glColorPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getVBOOffset());
    } else {
      glColorPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getBuffer());
    }
  }
  
  public final void glNormalPointer(GLArrayData paramGLArrayData)
  {
    if (paramGLArrayData.getComponentCount() == 0) return;
    if (paramGLArrayData.getComponentCount() != 3) {
      throw new GLException("Only 3 components per normal allowed");
    }
    if (paramGLArrayData.isVBO()) {
      glNormalPointer(paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getVBOOffset());
    } else {
      glNormalPointer(paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getBuffer());
    }
  }
  
  public final void glTexCoordPointer(GLArrayData paramGLArrayData) {
    if (paramGLArrayData.getComponentCount() == 0) return;
    if (paramGLArrayData.isVBO()) {
      glTexCoordPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getVBOOffset());
    } else {
      glTexCoordPointer(paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData.getStride(), paramGLArrayData.getBuffer());
    }
  }
}
