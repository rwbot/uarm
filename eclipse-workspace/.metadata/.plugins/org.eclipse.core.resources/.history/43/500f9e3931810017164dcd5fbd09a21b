package processing.opengl;

import java.nio.Buffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Stack;
import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PMatrix;
import processing.core.PMatrix2D;
import processing.core.PMatrix3D;
import processing.core.PShape;
import processing.core.PVector;





































































public class PShapeOpenGL
  extends PShape
{
  public static final int POSITION = 0;
  public static final int NORMAL = 1;
  public static final int TEXCOORD = 2;
  public static final int DIRECTION = 3;
  public static final int OFFSET = 4;
  protected static final int TRANSLATE = 0;
  protected static final int ROTATE = 1;
  protected static final int SCALE = 2;
  protected static final int MATRIX = 3;
  protected PGraphicsOpenGL pg;
  protected PGL pgl;
  protected int context;
  protected PShapeOpenGL root;
  protected PGraphicsOpenGL.InGeometry inGeo;
  protected PGraphicsOpenGL.TessGeometry tessGeo;
  protected PGraphicsOpenGL.Tessellator tessellator;
  protected PGraphicsOpenGL.AttributeMap polyAttribs;
  protected HashSet<PImage> textures;
  protected boolean strokedTexture;
  protected boolean untexChild;
  protected VertexBuffer bufPolyVertex;
  protected VertexBuffer bufPolyColor;
  protected VertexBuffer bufPolyNormal;
  protected VertexBuffer bufPolyTexcoord;
  protected VertexBuffer bufPolyAmbient;
  protected VertexBuffer bufPolySpecular;
  protected VertexBuffer bufPolyEmissive;
  protected VertexBuffer bufPolyShininess;
  protected VertexBuffer bufPolyIndex;
  protected VertexBuffer bufLineVertex;
  protected VertexBuffer bufLineColor;
  protected VertexBuffer bufLineAttrib;
  protected VertexBuffer bufLineIndex;
  protected VertexBuffer bufPointVertex;
  protected VertexBuffer bufPointColor;
  protected VertexBuffer bufPointAttrib;
  protected VertexBuffer bufPointIndex;
  public int glUsage = PGL.STATIC_DRAW;
  
  protected int polyVertCopyOffset;
  
  protected int polyIndCopyOffset;
  
  protected int lineVertCopyOffset;
  
  protected int lineIndCopyOffset;
  
  protected int pointVertCopyOffset;
  
  protected int pointIndCopyOffset;
  
  protected int polyIndexOffset;
  
  protected int polyVertexOffset;
  
  protected int polyVertexAbs;
  
  protected int polyVertexRel;
  
  protected int lineIndexOffset;
  
  protected int lineVertexOffset;
  
  protected int lineVertexAbs;
  
  protected int lineVertexRel;
  
  protected int pointIndexOffset;
  
  protected int pointVertexOffset;
  
  protected int pointVertexAbs;
  
  protected int pointVertexRel;
  
  protected int firstPolyIndexCache;
  
  protected int lastPolyIndexCache;
  protected int firstLineIndexCache;
  protected int lastLineIndexCache;
  protected int firstPointIndexCache;
  protected int lastPointIndexCache;
  protected int firstPolyVertex;
  protected int lastPolyVertex;
  protected int firstLineVertex;
  protected int lastLineVertex;
  protected int firstPointVertex;
  protected int lastPointVertex;
  protected PMatrix transform;
  protected Stack<PMatrix> transformStack;
  protected boolean tessellated;
  protected boolean needBufferInit = false;
  

  protected boolean solid = true;
  
  protected boolean breakShape = false;
  protected boolean shapeCreated = false;
  
  protected boolean hasPolys;
  
  protected boolean hasLines;
  
  protected boolean hasPoints;
  
  protected int bezierDetail;
  
  protected int curveDetail;
  
  protected float curveTightness;
  
  protected int savedBezierDetail;
  
  protected int savedCurveDetail;
  
  protected float savedCurveTightness;
  
  protected float normalX;
  
  protected float normalY;
  
  protected float normalZ;
  
  protected static final int NORMAL_MODE_AUTO = 0;
  
  protected static final int NORMAL_MODE_SHAPE = 1;
  
  protected static final int NORMAL_MODE_VERTEX = 2;
  
  protected int normalMode;
  
  protected boolean modified;
  
  protected boolean modifiedPolyVertices;
  
  protected boolean modifiedPolyColors;
  
  protected boolean modifiedPolyNormals;
  
  protected boolean modifiedPolyTexCoords;
  
  protected boolean modifiedPolyAmbient;
  
  protected boolean modifiedPolySpecular;
  
  protected boolean modifiedPolyEmissive;
  
  protected boolean modifiedPolyShininess;
  
  protected boolean modifiedLineVertices;
  
  protected boolean modifiedLineColors;
  
  protected boolean modifiedLineAttributes;
  
  protected boolean modifiedPointVertices;
  
  protected boolean modifiedPointColors;
  
  protected boolean modifiedPointAttributes;
  
  protected int firstModifiedPolyVertex;
  
  protected int lastModifiedPolyVertex;
  
  protected int firstModifiedPolyColor;
  
  protected int lastModifiedPolyColor;
  
  protected int firstModifiedPolyNormal;
  
  protected int lastModifiedPolyNormal;
  
  protected int firstModifiedPolyTexcoord;
  
  protected int lastModifiedPolyTexcoord;
  
  protected int firstModifiedPolyAmbient;
  
  protected int lastModifiedPolyAmbient;
  
  protected int firstModifiedPolySpecular;
  
  protected int lastModifiedPolySpecular;
  
  protected int firstModifiedPolyEmissive;
  
  protected int lastModifiedPolyEmissive;
  
  protected int firstModifiedPolyShininess;
  protected int lastModifiedPolyShininess;
  protected int firstModifiedLineVertex;
  protected int lastModifiedLineVertex;
  protected int firstModifiedLineColor;
  protected int lastModifiedLineColor;
  protected int firstModifiedLineAttribute;
  protected int lastModifiedLineAttribute;
  protected int firstModifiedPointVertex;
  protected int lastModifiedPointVertex;
  protected int firstModifiedPointColor;
  protected int lastModifiedPointColor;
  protected int firstModifiedPointAttribute;
  protected int lastModifiedPointAttribute;
  protected boolean savedStroke;
  protected int savedStrokeColor;
  protected float savedStrokeWeight;
  protected int savedStrokeCap;
  protected int savedStrokeJoin;
  protected boolean savedFill;
  protected int savedFillColor;
  protected boolean savedTint;
  protected int savedTintColor;
  protected int savedAmbientColor;
  protected int savedSpecularColor;
  protected int savedEmissiveColor;
  protected float savedShininess;
  protected int savedTextureMode;
  
  PShapeOpenGL() {}
  
  public PShapeOpenGL(PGraphicsOpenGL pg, int family)
  {
    this.pg = pg;
    this.family = family;
    
    pgl = pgl;
    context = pgl.createEmptyContext();
    
    bufPolyVertex = null;
    bufPolyColor = null;
    bufPolyNormal = null;
    bufPolyTexcoord = null;
    bufPolyAmbient = null;
    bufPolySpecular = null;
    bufPolyEmissive = null;
    bufPolyShininess = null;
    bufPolyIndex = null;
    
    bufLineVertex = null;
    bufLineColor = null;
    bufLineAttrib = null;
    bufLineIndex = null;
    
    bufPointVertex = null;
    bufPointColor = null;
    bufPointAttrib = null;
    bufPointIndex = null;
    
    tessellator = tessellator;
    root = this;
    parent = null;
    tessellated = false;
    
    if ((family == 103) || (family == 101) || (family == 102)) {
      polyAttribs = PGraphicsOpenGL.newAttributeMap();
      inGeo = PGraphicsOpenGL.newInGeometry(pg, polyAttribs, 1);
    }
    

    textureMode = textureMode;
    
    colorMode(colorMode, 
      colorModeX, colorModeY, colorModeZ, colorModeA);
    





    fill = fill;
    fillColor = fillColor;
    
    stroke = stroke;
    strokeColor = strokeColor;
    strokeWeight = strokeWeight;
    strokeCap = strokeCap;
    strokeJoin = strokeJoin;
    
    tint = tint;
    tintColor = tintColor;
    
    setAmbient = setAmbient;
    ambientColor = ambientColor;
    specularColor = specularColor;
    emissiveColor = emissiveColor;
    shininess = shininess;
    
    sphereDetailU = sphereDetailU;
    sphereDetailV = sphereDetailV;
    
    bezierDetail = bezierDetail;
    curveDetail = curveDetail;
    curveTightness = curveTightness;
    
    rectMode = rectMode;
    ellipseMode = ellipseMode;
    
    normalX = (this.normalY = 0.0F);
    normalZ = 1.0F;
    
    normalMode = 0;
    


    breakShape = false;
    
    if (family == 0)
    {
      shapeCreated = true;
    }
    

    perVertexStyles = true;
  }
  

  public PShapeOpenGL(PGraphicsOpenGL pg, int kind, float... p)
  {
    this(pg, 101);
    setKind(kind);
    setParams(p);
  }
  

  public void addChild(PShape who)
  {
    if ((who instanceof PShapeOpenGL)) {
      if (family == 0) {
        PShapeOpenGL c3d = (PShapeOpenGL)who;
        
        super.addChild(c3d);
        c3d.updateRoot(root);
        markForTessellation();
        
        if (family == 0) {
          if (textures != null) {
            for (PImage tex : textures) {
              addTexture(tex);
            }
          } else {
            untexChild(true);
          }
          if (strokedTexture) {
            strokedTexture(true);
          }
        }
        else if (image != null) {
          addTexture(image);
          if (stroke) {
            strokedTexture(true);
          }
        } else {
          untexChild(true);
        }
      }
      else
      {
        PGraphics.showWarning("Cannot add child shape to non-group shape.");
      }
    } else {
      PGraphics.showWarning("Shape must be OpenGL to be added to the group.");
    }
  }
  

  public void addChild(PShape who, int idx)
  {
    if ((who instanceof PShapeOpenGL)) {
      if (family == 0) {
        PShapeOpenGL c3d = (PShapeOpenGL)who;
        
        super.addChild(c3d, idx);
        c3d.updateRoot(root);
        markForTessellation();
        
        if (family == 0) {
          if (textures != null) {
            for (PImage tex : textures) {
              addTexture(tex);
            }
          } else {
            untexChild(true);
          }
          if (strokedTexture) {
            strokedTexture(true);
          }
        }
        else if (image != null) {
          addTexture(image);
          if (stroke) {
            strokedTexture(true);
          }
        } else {
          untexChild(true);
        }
      }
      else
      {
        PGraphics.showWarning("Cannot add child shape to non-group shape.");
      }
    } else {
      PGraphics.showWarning("Shape must be OpenGL to be added to the group.");
    }
  }
  

  public void removeChild(int idx)
  {
    super.removeChild(idx);
    strokedTexture(false);
    untexChild(false);
    markForTessellation();
  }
  
  protected void updateRoot(PShape root)
  {
    this.root = ((PShapeOpenGL)root);
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.updateRoot(root);
      }
    }
  }
  






  public static PShapeOpenGL createShape(PGraphicsOpenGL pg, PShape src)
  {
    PShapeOpenGL dest = null;
    if (src.getFamily() == 0)
    {
      dest = (PShapeOpenGL)pg.createShapeFamily(0);
      copyGroup(pg, src, dest);
    } else if (src.getFamily() == 101)
    {
      dest = (PShapeOpenGL)pg.createShapePrimitive(src.getKind(), src.getParams());
      PShape.copyPrimitive(src, dest);
    } else if (src.getFamily() == 103)
    {
      dest = (PShapeOpenGL)pg.createShapeFamily(103);
      PShape.copyGeometry(src, dest);
    } else if (src.getFamily() == 102) {
      dest = (PShapeOpenGL)pg.createShapeFamily(102);
      
      PShape.copyPath(src, dest);
    }
    dest.setName(src.getName());
    width = width;
    height = height;
    depth = depth;
    return dest;
  }
  



























  public static void copyGroup(PGraphicsOpenGL pg, PShape src, PShape dest)
  {
    copyMatrix(src, dest);
    copyStyles(src, dest);
    copyImage(src, dest);
    
    for (int i = 0; i < src.getChildCount(); i++) {
      PShape c = createShape(pg, src.getChild(i));
      dest.addChild(c);
    }
  }
  





















  public float getWidth()
  {
    PVector min = new PVector(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 
      Float.POSITIVE_INFINITY);
    PVector max = new PVector(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 
      Float.NEGATIVE_INFINITY);
    if (shapeCreated) {
      getVertexMin(min);
      getVertexMax(max);
    }
    width = (x - x);
    return width;
  }
  

  public float getHeight()
  {
    PVector min = new PVector(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 
      Float.POSITIVE_INFINITY);
    PVector max = new PVector(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 
      Float.NEGATIVE_INFINITY);
    if (shapeCreated) {
      getVertexMin(min);
      getVertexMax(max);
    }
    height = (y - y);
    return height;
  }
  

  public float getDepth()
  {
    PVector min = new PVector(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 
      Float.POSITIVE_INFINITY);
    PVector max = new PVector(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 
      Float.NEGATIVE_INFINITY);
    if (shapeCreated) {
      getVertexMin(min);
      getVertexMax(max);
    }
    depth = (z - z);
    return depth;
  }
  
  protected void getVertexMin(PVector min)
  {
    updateTessellation();
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.getVertexMin(min);
      }
    } else {
      if (hasPolys) {
        tessGeo.getPolyVertexMin(min, firstPolyVertex, lastPolyVertex);
      }
      if (is3D()) {
        if (hasLines) {
          tessGeo.getLineVertexMin(min, firstLineVertex, lastLineVertex);
        }
        if (hasPoints) {
          tessGeo.getPointVertexMin(min, firstPointVertex, lastPointVertex);
        }
      }
    }
  }
  
  protected void getVertexMax(PVector max)
  {
    updateTessellation();
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.getVertexMax(max);
      }
    } else {
      if (hasPolys) {
        tessGeo.getPolyVertexMax(max, firstPolyVertex, lastPolyVertex);
      }
      if (is3D()) {
        if (hasLines) {
          tessGeo.getLineVertexMax(max, firstLineVertex, lastLineVertex);
        }
        if (hasPoints) {
          tessGeo.getPointVertexMax(max, firstPointVertex, lastPointVertex);
        }
      }
    }
  }
  
  protected int getVertexSum(PVector sum, int count)
  {
    updateTessellation();
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        count += child.getVertexSum(sum, count);
      }
    } else {
      if (hasPolys) {
        count += tessGeo.getPolyVertexSum(sum, firstPolyVertex, lastPolyVertex);
      }
      if (is3D()) {
        if (hasLines)
        {
          count = count + tessGeo.getLineVertexSum(sum, firstLineVertex, lastLineVertex);
        }
        if (hasPoints)
        {
          count = count + tessGeo.getPointVertexSum(sum, firstPointVertex, lastPointVertex);
        }
      }
    }
    return count;
  }
  








  public void setTextureMode(int mode)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTextureMode()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setTextureMode(mode);
      }
    } else {
      setTextureModeImpl(mode);
    }
  }
  
  protected void setTextureModeImpl(int mode)
  {
    if (textureMode == mode) return;
    textureMode = mode;
    if (image != null) {
      float uFactor = image.width;
      float vFactor = image.height;
      if (textureMode == 1) {
        uFactor = 1.0F / uFactor;
        vFactor = 1.0F / vFactor;
      }
      scaleTextureUV(uFactor, vFactor);
    }
  }
  

  public void setTexture(PImage tex)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTexture()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setTexture(tex);
      }
    } else {
      setTextureImpl(tex);
    }
  }
  
  protected void setTextureImpl(PImage tex)
  {
    PImage image0 = image;
    image = tex;
    
    if ((textureMode == 2) && (image0 != image))
    {
      float uFactor = 1.0F;
      float vFactor = 1.0F;
      if (image != null) {
        uFactor /= image.width;
        vFactor /= image.height;
      }
      if (image0 != null) {
        uFactor *= width;
        vFactor *= height;
      }
      scaleTextureUV(uFactor, vFactor);
    }
    
    if ((image0 != tex) && (parent != null)) {
      ((PShapeOpenGL)parent).removeTexture(image0, this);
    }
    if (parent != null) {
      ((PShapeOpenGL)parent).addTexture(image);
      if ((is2D()) && (stroke)) {
        ((PShapeOpenGL)parent).strokedTexture(true);
      }
    }
  }
  
  protected void scaleTextureUV(float uFactor, float vFactor)
  {
    if ((PGraphicsOpenGL.same(uFactor, 1.0F)) && 
      (PGraphicsOpenGL.same(vFactor, 1.0F))) { return;
    }
    for (int i = 0; i < inGeo.vertexCount; i++) {
      float u = inGeo.texcoords[(2 * i + 0)];
      float v = inGeo.texcoords[(2 * i + 1)];
      inGeo.texcoords[(2 * i + 0)] = PApplet.min(1.0F, u * uFactor);
      inGeo.texcoords[(2 * i + 1)] = PApplet.min(1.0F, v * uFactor);
    }
    
    if ((shapeCreated) && (tessellated) && (hasPolys)) {
      int last1 = 0;
      if (is3D()) {
        last1 = lastPolyVertex + 1;
      } else if (is2D()) {
        last1 = lastPolyVertex + 1;
        if (-1 < firstLineVertex) last1 = firstLineVertex;
        if (-1 < firstPointVertex) last1 = firstPointVertex;
      }
      for (int i = firstLineVertex; i < last1; i++) {
        float u = tessGeo.polyTexCoords[(2 * i + 0)];
        float v = tessGeo.polyTexCoords[(2 * i + 1)];
        tessGeo.polyTexCoords[(2 * i + 0)] = PApplet.min(1.0F, u * uFactor);
        tessGeo.polyTexCoords[(2 * i + 1)] = PApplet.min(1.0F, v * uFactor);
      }
      root.setModifiedPolyTexCoords(firstPolyVertex, last1 - 1);
    }
  }
  
  protected void addTexture(PImage tex)
  {
    if (textures == null) {
      textures = new HashSet();
    }
    textures.add(tex);
    if (parent != null) {
      ((PShapeOpenGL)parent).addTexture(tex);
    }
  }
  
  protected void removeTexture(PImage tex, PShapeOpenGL caller)
  {
    if ((textures == null) || (!textures.contains(tex))) { return;
    }
    
    boolean childHasTex = false;
    for (int i = 0; i < childCount; i++) {
      PShapeOpenGL child = (PShapeOpenGL)children[i];
      if ((child != caller) && 
        (child.hasTexture(tex))) {
        childHasTex = true;
        break;
      }
    }
    
    if (!childHasTex)
    {
      textures.remove(tex);
      if (textures.size() == 0) {
        textures = null;
      }
    }
    


    if (parent != null) {
      ((PShapeOpenGL)parent).removeTexture(tex, this);
    }
  }
  
  protected void strokedTexture(boolean newValue)
  {
    strokedTexture(newValue, null);
  }
  
  protected void strokedTexture(boolean newValue, PShapeOpenGL caller)
  {
    if (strokedTexture == newValue) { return;
    }
    if (newValue) {
      strokedTexture = true;
    }
    else {
      strokedTexture = false;
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        if ((child != caller) && 
          (child.hasStrokedTexture())) {
          strokedTexture = true;
          break;
        }
      }
    }
    

    if (parent != null) {
      ((PShapeOpenGL)parent).strokedTexture(newValue, this);
    }
  }
  
  protected void untexChild(boolean newValue)
  {
    untexChild(newValue, null);
  }
  
  protected void untexChild(boolean newValue, PShapeOpenGL caller)
  {
    if (untexChild == newValue) { return;
    }
    if (newValue) {
      untexChild = true;
    }
    else {
      untexChild = false;
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        if ((child != caller) && 
          (!child.hasTexture())) {
          untexChild = true;
          break;
        }
      }
    }
    

    if (parent != null) {
      ((PShapeOpenGL)parent).untexChild(newValue, this);
    }
  }
  
  protected boolean hasTexture()
  {
    if (family == 0) {
      return (textures != null) && (textures.size() > 0);
    }
    return image != null;
  }
  

  protected boolean hasTexture(PImage tex)
  {
    if (family == 0) {
      return (textures != null) && (textures.contains(tex));
    }
    return image == tex;
  }
  

  protected boolean hasStrokedTexture()
  {
    if (family == 0) {
      return strokedTexture;
    }
    return (image != null) && (stroke);
  }
  


  public void solid(boolean solid)
  {
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.solid(solid);
      }
    } else {
      this.solid = solid;
    }
  }
  

  protected void beginContourImpl()
  {
    breakShape = true;
  }
  


  protected void endContourImpl() {}
  


  public void vertex(float x, float y)
  {
    vertexImpl(x, y, 0.0F, 0.0F, 0.0F);
    if (image != null) {
      PGraphics.showWarning("No uv texture coordinates supplied with vertex() call");
    }
  }
  
  public void vertex(float x, float y, float u, float v)
  {
    vertexImpl(x, y, 0.0F, u, v);
  }
  

  public void vertex(float x, float y, float z)
  {
    vertexImpl(x, y, z, 0.0F, 0.0F);
    if (image != null) {
      PGraphics.showWarning("No uv texture coordinates supplied with vertex() call");
    }
  }
  
  public void vertex(float x, float y, float z, float u, float v)
  {
    vertexImpl(x, y, z, u, v);
  }
  
  protected void vertexImpl(float x, float y, float z, float u, float v)
  {
    if (!openShape) {
      PGraphics.showWarning("%1$s can only be called between beginShape() and endShape()", new Object[] { "vertex()" });
      return;
    }
    
    if (family == 0) {
      PGraphics.showWarning("Cannot add vertices to GROUP shape");
      return;
    }
    
    boolean textured = image != null;
    int fcolor = 0;
    if ((fill) || (textured)) {
      if (!textured) {
        fcolor = fillColor;
      }
      else if (tint) {
        fcolor = tintColor;
      } else {
        fcolor = -1;
      }
    }
    

    if ((textureMode == 2) && (image != null)) {
      u /= image.width;
      v /= image.height;
    }
    
    int scolor = 0;
    float sweight = 0.0F;
    if (stroke) {
      scolor = strokeColor;
      sweight = strokeWeight;
    }
    
    inGeo.addVertex(x, y, z, 
      fcolor, 
      normalX, normalY, normalZ, 
      u, v, 
      scolor, sweight, 
      ambientColor, specularColor, emissiveColor, shininess, 
      0, vertexBreak());
    
    markForTessellation();
  }
  
  protected boolean vertexBreak()
  {
    if (breakShape) {
      breakShape = false;
      return true;
    }
    return false;
  }
  

  public void normal(float nx, float ny, float nz)
  {
    if (!openShape) {
      PGraphics.showWarning("%1$s can only be called between beginShape() and endShape()", new Object[] { "normal()" });
      return;
    }
    
    if (family == 0) {
      PGraphics.showWarning("Cannot set normal in GROUP shape");
      return;
    }
    
    normalX = nx;
    normalY = ny;
    normalZ = nz;
    


    if (normalMode == 0)
    {
      normalMode = 1;
    } else if (normalMode == 1)
    {
      normalMode = 2;
    }
  }
  

  public void attribPosition(String name, float x, float y, float z)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 0, 
      PGL.FLOAT, 3);
    if (attrib != null) { attrib.set(x, y, z);
    }
  }
  
  public void attribNormal(String name, float nx, float ny, float nz)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 1, 
      PGL.FLOAT, 3);
    if (attrib != null) { attrib.set(nx, ny, nz);
    }
  }
  
  public void attribColor(String name, int color)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 2, PGL.INT, 1);
    if (attrib != null) { attrib.set(new int[] { color });
    }
  }
  
  public void attrib(String name, float... values)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 3, PGL.FLOAT, 
      values.length);
    if (attrib != null) { attrib.set(values);
    }
  }
  
  public void attrib(String name, int... values)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 3, PGL.INT, 
      values.length);
    if (attrib != null) { attrib.set(values);
    }
  }
  
  public void attrib(String name, boolean... values)
  {
    PGraphicsOpenGL.VertexAttribute attrib = attribImpl(name, 3, PGL.BOOL, 
      values.length);
    if (attrib != null) attrib.set(values);
  }
  
  protected PGraphicsOpenGL.VertexAttribute attribImpl(String name, int kind, int type, int size)
  {
    if (4 < size) {
      PGraphics.showWarning("Vertex attributes cannot have more than 4 values");
      return null;
    }
    PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
    if (attrib == null) {
      attrib = new PGraphicsOpenGL.VertexAttribute(pg, name, kind, type, size);
      polyAttribs.put(name, attrib);
      inGeo.initAttrib(attrib);
    }
    if (kind != kind) {
      PGraphics.showWarning("The attribute kind cannot be changed after creation");
      return null;
    }
    if (type != type) {
      PGraphics.showWarning("The attribute type cannot be changed after creation");
      return null;
    }
    if (size != size) {
      PGraphics.showWarning("New value for vertex attribute has wrong number of values");
      return null;
    }
    return attrib;
  }
  

  public void endShape(int mode)
  {
    super.endShape(mode);
    


    inGeo.trim();
    
    close = (mode == 2);
    markForTessellation();
    shapeCreated = true;
  }
  

  public void setParams(float[] source)
  {
    if (family != 101) {
      PGraphics.showWarning("Parameters can only be set to PRIMITIVE shapes");
      return;
    }
    
    super.setParams(source);
    markForTessellation();
    shapeCreated = true;
  }
  

  public void setPath(int vcount, float[][] verts, int ccount, int[] codes)
  {
    if (family != 102) {
      PGraphics.showWarning("Vertex coordinates and codes can only be set to PATH shapes");
      
      return;
    }
    
    super.setPath(vcount, verts, ccount, codes);
    markForTessellation();
    shapeCreated = true;
  }
  








  public void translate(float tx, float ty)
  {
    if (is3D) {
      transform(0, new float[] { tx, ty, 0.0F });
    } else {
      transform(0, new float[] { tx, ty });
    }
  }
  

  public void translate(float tx, float ty, float tz)
  {
    transform(0, new float[] { tx, ty, tz });
  }
  

  public void rotate(float angle)
  {
    transform(1, new float[] { angle });
  }
  

  public void rotateX(float angle)
  {
    rotate(angle, 1.0F, 0.0F, 0.0F);
  }
  

  public void rotateY(float angle)
  {
    rotate(angle, 0.0F, 1.0F, 0.0F);
  }
  

  public void rotateZ(float angle)
  {
    transform(1, new float[] { angle });
  }
  

  public void rotate(float angle, float v0, float v1, float v2)
  {
    transform(1, new float[] { angle, v0, v1, v2 });
  }
  

  public void scale(float s)
  {
    if (is3D) {
      transform(2, new float[] { s, s, s });
    } else {
      transform(2, new float[] { s, s });
    }
  }
  

  public void scale(float x, float y)
  {
    if (is3D) {
      transform(2, new float[] { x, y, 1.0F });
    } else {
      transform(2, new float[] { x, y });
    }
  }
  

  public void scale(float x, float y, float z)
  {
    transform(2, new float[] { x, y, z });
  }
  

  public void applyMatrix(PMatrix2D source)
  {
    transform(3, new float[] { m00, m01, m02, 
      m10, m11, m12 });
  }
  


  public void applyMatrix(float n00, float n01, float n02, float n10, float n11, float n12)
  {
    transform(3, new float[] { n00, n01, n02, 
      n10, n11, n12 });
  }
  




  public void applyMatrix(float n00, float n01, float n02, float n03, float n10, float n11, float n12, float n13, float n20, float n21, float n22, float n23, float n30, float n31, float n32, float n33)
  {
    transform(3, new float[] { n00, n01, n02, n03, 
      n10, n11, n12, n13, 
      n20, n21, n22, n23, 
      n30, n31, n32, n33 });
  }
  

  public void resetMatrix()
  {
    if ((shapeCreated) && (matrix != null) && (transformStack != null)) {
      if (family == 0) {
        updateTessellation();
      }
      if (tessellated) {
        PMatrix mat = popTransform();
        while (mat != null) {
          boolean res = mat.invert();
          if (res) {
            applyMatrixImpl(mat);
          } else {
            PGraphics.showWarning("Transformation applied on the shape cannot be inverted");
          }
          mat = popTransform();
        }
      }
      matrix.reset();
      transformStack.clear();
    }
  }
  
  protected void transform(int type, float... args)
  {
    int dimensions = is3D ? 3 : 2;
    checkMatrix(dimensions);
    if (transform == null) {
      if (dimensions == 2) {
        transform = new PMatrix2D();
      } else {
        transform = new PMatrix3D();
      }
    } else {
      transform.reset();
    }
    
    int ncoords = args.length;
    if (type == 1) {
      ncoords = args.length == 1 ? 2 : 3;
    } else if (type == 3) {
      ncoords = args.length == 6 ? 2 : 3;
    }
    
    switch (type) {
    case 0: 
      if (ncoords == 3) {
        transform.translate(args[0], args[1], args[2]);
      } else {
        transform.translate(args[0], args[1]);
      }
      break;
    case 1: 
      if (ncoords == 3) {
        transform.rotate(args[0], args[1], args[2], args[3]);
      } else {
        transform.rotate(args[0]);
      }
      break;
    case 2: 
      if (ncoords == 3) {
        transform.scale(args[0], args[1], args[2]);
      } else {
        transform.scale(args[0], args[1]);
      }
      break;
    case 3: 
      if (ncoords == 3) {
        transform.set(args[0], args[1], args[2], args[3], 
          args[4], args[5], args[6], args[7], 
          args[8], args[9], args[10], args[11], 
          args[12], args[13], args[14], args[15]);
      } else {
        transform.set(args[0], args[1], args[2], 
          args[3], args[4], args[5]);
      }
      break;
    }
    matrix.apply(transform);
    pushTransform();
    if (tessellated) applyMatrixImpl(transform);
  }
  
  protected void pushTransform()
  {
    if (transformStack == null) transformStack = new Stack();
    PMatrix mat;
    PMatrix mat; if ((transform instanceof PMatrix2D)) {
      mat = new PMatrix2D();
    } else {
      mat = new PMatrix3D();
    }
    mat.set(transform);
    transformStack.push(mat);
  }
  
  protected PMatrix popTransform()
  {
    if ((transformStack == null) || (transformStack.size() == 0)) return null;
    return (PMatrix)transformStack.pop();
  }
  
  protected void applyMatrixImpl(PMatrix matrix) {
    if (hasPolys) {
      tessGeo.applyMatrixOnPolyGeometry(matrix, 
        firstPolyVertex, lastPolyVertex);
      root.setModifiedPolyVertices(firstPolyVertex, lastPolyVertex);
      root.setModifiedPolyNormals(firstPolyVertex, lastPolyVertex);
      for (PGraphicsOpenGL.VertexAttribute attrib : polyAttribs.values()) {
        if ((attrib.isPosition()) || (attrib.isNormal())) {
          root.setModifiedPolyAttrib(attrib, firstPolyVertex, lastPolyVertex);
        }
      }
    }
    
    if (is3D()) {
      if (hasLines) {
        tessGeo.applyMatrixOnLineGeometry(matrix, 
          firstLineVertex, lastLineVertex);
        root.setModifiedLineVertices(firstLineVertex, lastLineVertex);
        root.setModifiedLineAttributes(firstLineVertex, lastLineVertex);
      }
      
      if (hasPoints) {
        tessGeo.applyMatrixOnPointGeometry(matrix, 
          firstPointVertex, lastPointVertex);
        root.setModifiedPointVertices(firstPointVertex, lastPointVertex);
        root.setModifiedPointAttributes(firstPointVertex, lastPointVertex);
      }
    }
  }
  








  public void bezierDetail(int detail)
  {
    bezierDetail = detail;
    if (inGeo.codeCount > 0) {
      markForTessellation();
    }
  }
  




  public void bezierVertex(float x2, float y2, float x3, float y3, float x4, float y4)
  {
    bezierVertexImpl(x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      x4, y4, 0.0F);
  }
  



  public void bezierVertex(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4)
  {
    bezierVertexImpl(x2, y2, z2, 
      x3, y3, z3, 
      x4, y4, z4);
  }
  


  protected void bezierVertexImpl(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4)
  {
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addBezierVertex(x2, y2, z2, 
      x3, y3, z3, 
      x4, y4, z4, vertexBreak());
  }
  


  public void quadraticVertex(float cx, float cy, float x3, float y3)
  {
    quadraticVertexImpl(cx, cy, 0.0F, 
      x3, y3, 0.0F);
  }
  


  public void quadraticVertex(float cx, float cy, float cz, float x3, float y3, float z3)
  {
    quadraticVertexImpl(cx, cy, cz, 
      x3, y3, z3);
  }
  

  protected void quadraticVertexImpl(float cx, float cy, float cz, float x3, float y3, float z3)
  {
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addQuadraticVertex(cx, cy, cz, 
      x3, y3, z3, vertexBreak());
  }
  








  public void curveDetail(int detail)
  {
    curveDetail = detail;
    
    if (inGeo.codeCount > 0) {
      markForTessellation();
    }
  }
  

  public void curveTightness(float tightness)
  {
    curveTightness = tightness;
    
    if (inGeo.codeCount > 0) {
      markForTessellation();
    }
  }
  

  public void curveVertex(float x, float y)
  {
    curveVertexImpl(x, y, 0.0F);
  }
  

  public void curveVertex(float x, float y, float z)
  {
    curveVertexImpl(x, y, z);
  }
  
  protected void curveVertexImpl(float x, float y, float z)
  {
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addCurveVertex(x, y, z, vertexBreak());
  }
  








  public int getVertexCount()
  {
    if (family == 0) { return 0;
    }
    if ((family == 101) || (family == 102))
    {

      updateTessellation();
    }
    return inGeo.vertexCount;
  }
  


  public PVector getVertex(int index, PVector vec)
  {
    if (vec == null) {
      vec = new PVector();
    }
    x = inGeo.vertices[(3 * index + 0)];
    y = inGeo.vertices[(3 * index + 1)];
    z = inGeo.vertices[(3 * index + 2)];
    return vec;
  }
  

  public float getVertexX(int index)
  {
    return inGeo.vertices[(3 * index + 0)];
  }
  

  public float getVertexY(int index)
  {
    return inGeo.vertices[(3 * index + 1)];
  }
  

  public float getVertexZ(int index)
  {
    return inGeo.vertices[(3 * index + 2)];
  }
  

  public void setVertex(int index, float x, float y)
  {
    setVertex(index, x, y, 0.0F);
  }
  

  public void setVertex(int index, float x, float y, float z)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setVertex()" });
      return;
    }
    





    if (family == 102) {
      if ((vertexCodes != null) && (vertexCodeCount > 0) && 
        (vertexCodes[index] != 0)) {
        PGraphics.showWarning("%1$s can not be called on quadratic or bezier vertices", new Object[] { "setVertex()" });
        return;
      }
      vertices[index][0] = x;
      vertices[index][1] = y;
      if (is3D) vertices[index][2] = z;
    } else {
      inGeo.vertices[(3 * index + 0)] = x;
      inGeo.vertices[(3 * index + 1)] = y;
      inGeo.vertices[(3 * index + 2)] = z;
    }
    markForTessellation();
  }
  

  public void setVertex(int index, PVector vec)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setVertex()" });
      return;
    }
    
    inGeo.vertices[(3 * index + 0)] = x;
    inGeo.vertices[(3 * index + 1)] = y;
    inGeo.vertices[(3 * index + 2)] = z;
    markForTessellation();
  }
  

  public PVector getNormal(int index, PVector vec)
  {
    if (vec == null) {
      vec = new PVector();
    }
    x = inGeo.normals[(3 * index + 0)];
    y = inGeo.normals[(3 * index + 1)];
    z = inGeo.normals[(3 * index + 2)];
    return vec;
  }
  

  public float getNormalX(int index)
  {
    return inGeo.normals[(3 * index + 0)];
  }
  

  public float getNormalY(int index)
  {
    return inGeo.normals[(3 * index + 1)];
  }
  

  public float getNormalZ(int index)
  {
    return inGeo.normals[(3 * index + 2)];
  }
  

  public void setNormal(int index, float nx, float ny, float nz)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setNormal()" });
      return;
    }
    
    inGeo.normals[(3 * index + 0)] = nx;
    inGeo.normals[(3 * index + 1)] = ny;
    inGeo.normals[(3 * index + 2)] = nz;
    markForTessellation();
  }
  

  public void setAttrib(String name, int index, float... values)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setNormal()" });
      return;
    }
    
    PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
    float[] array = (float[])inGeo.fattribs.get(name);
    for (int i = 0; i < values.length; i++) {
      array[(size * index + 0)] = values[i];
    }
    markForTessellation();
  }
  

  public void setAttrib(String name, int index, int... values)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setNormal()" });
      return;
    }
    
    PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
    int[] array = (int[])inGeo.iattribs.get(name);
    for (int i = 0; i < values.length; i++) {
      array[(size * index + 0)] = values[i];
    }
    markForTessellation();
  }
  

  public void setAttrib(String name, int index, boolean... values)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setNormal()" });
      return;
    }
    
    PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
    byte[] array = (byte[])inGeo.battribs.get(name);
    for (int i = 0; i < values.length; i++) {
      array[(size * index + 0)] = ((byte)(values[i] != 0 ? 1 : 0));
    }
    markForTessellation();
  }
  

  public float getTextureU(int index)
  {
    return inGeo.texcoords[(2 * index + 0)];
  }
  

  public float getTextureV(int index)
  {
    return inGeo.texcoords[(2 * index + 1)];
  }
  

  public void setTextureUV(int index, float u, float v)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTextureUV()" });
      return;
    }
    
    if ((textureMode == 2) && (image != null)) {
      u /= image.width;
      v /= image.height;
    }
    inGeo.texcoords[(2 * index + 0)] = u;
    inGeo.texcoords[(2 * index + 1)] = v;
    
    markForTessellation();
  }
  

  public int getFill(int index)
  {
    if ((family != 0) && (image == null)) {
      return PGL.nativeToJavaARGB(inGeo.colors[index]);
    }
    return 0;
  }
  


  public void setFill(boolean fill)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setFill()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setFill(fill);
      }
    } else if (this.fill != fill) {
      markForTessellation();
    }
    this.fill = fill;
  }
  

  public void setFill(int fill)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setFill()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setFill(fill);
      }
    } else {
      setFillImpl(fill);
    }
  }
  
  protected void setFillImpl(int fill)
  {
    if (fillColor == fill) return;
    fillColor = fill;
    
    if (image == null) {
      Arrays.fill(inGeo.colors, 0, inGeo.vertexCount, 
        PGL.javaToNativeARGB(fillColor));
      if ((shapeCreated) && (tessellated) && (hasPolys)) {
        if (is3D()) {
          Arrays.fill(tessGeo.polyColors, firstPolyVertex, lastPolyVertex + 1, 
            PGL.javaToNativeARGB(fillColor));
          root.setModifiedPolyColors(firstPolyVertex, lastPolyVertex);
        } else if (is2D()) {
          int last1 = lastPolyVertex + 1;
          if (-1 < firstLineVertex) last1 = firstLineVertex;
          if (-1 < firstPointVertex) last1 = firstPointVertex;
          Arrays.fill(tessGeo.polyColors, firstPolyVertex, last1, 
            PGL.javaToNativeARGB(fillColor));
          root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
        }
      }
    }
    
    if (!setAmbient)
    {



      setAmbientImpl(fill);
      setAmbient = false;
    }
  }
  

  public void setFill(int index, int fill)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setFill()" });
      return;
    }
    
    if (image == null) {
      inGeo.colors[index] = PGL.javaToNativeARGB(fill);
      markForTessellation();
    }
  }
  

  public int getTint(int index)
  {
    if ((family != 0) && (image != null)) {
      return PGL.nativeToJavaARGB(inGeo.colors[index]);
    }
    return 0;
  }
  


  public void setTint(boolean tint)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTint()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setTint(fill);
      }
    } else if ((this.tint) && (!tint)) {
      setTintImpl(-1);
    }
    this.tint = tint;
  }
  

  public void setTint(int tint)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTint()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setTint(tint);
      }
    } else {
      setTintImpl(tint);
    }
  }
  
  protected void setTintImpl(int tint)
  {
    if (tintColor == tint) return;
    tintColor = tint;
    
    if (image != null) {
      Arrays.fill(inGeo.colors, 0, inGeo.vertexCount, 
        PGL.javaToNativeARGB(tintColor));
      if ((shapeCreated) && (tessellated) && (hasPolys)) {
        if (is3D()) {
          Arrays.fill(tessGeo.polyColors, firstPolyVertex, lastPolyVertex + 1, 
            PGL.javaToNativeARGB(tintColor));
          root.setModifiedPolyColors(firstPolyVertex, lastPolyVertex);
        } else if (is2D()) {
          int last1 = lastPolyVertex + 1;
          if (-1 < firstLineVertex) last1 = firstLineVertex;
          if (-1 < firstPointVertex) last1 = firstPointVertex;
          Arrays.fill(tessGeo.polyColors, firstPolyVertex, last1, 
            PGL.javaToNativeARGB(tintColor));
          root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
        }
      }
    }
  }
  

  public void setTint(int index, int tint)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setTint()" });
      return;
    }
    
    if (image != null) {
      inGeo.colors[index] = PGL.javaToNativeARGB(tint);
      markForTessellation();
    }
  }
  

  public int getStroke(int index)
  {
    if (family != 0) {
      return PGL.nativeToJavaARGB(inGeo.strokeColors[index]);
    }
    return 0;
  }
  


  public void setStroke(boolean stroke)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStroke()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setStroke(stroke);
      }
      this.stroke = stroke;
    } else {
      setStrokeImpl(stroke);
    }
  }
  
  protected void setStrokeImpl(boolean stroke)
  {
    if (this.stroke != stroke) {
      if (stroke)
      {


        int color = strokeColor;
        strokeColor += 1;
        setStrokeImpl(color);
      }
      
      markForTessellation();
      if ((is2D()) && (parent != null)) {
        ((PShapeOpenGL)parent).strokedTexture((stroke) && (image != null));
      }
      
      this.stroke = stroke;
    }
  }
  

  public void setStroke(int stroke)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStroke()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setStroke(stroke);
      }
    } else {
      setStrokeImpl(stroke);
    }
  }
  
  protected void setStrokeImpl(int stroke)
  {
    if (strokeColor == stroke) return;
    strokeColor = stroke;
    
    Arrays.fill(inGeo.strokeColors, 0, inGeo.vertexCount, 
      PGL.javaToNativeARGB(strokeColor));
    if ((shapeCreated) && (tessellated) && ((hasLines) || (hasPoints))) {
      if (hasLines) {
        if (is3D()) {
          Arrays.fill(tessGeo.lineColors, firstLineVertex, lastLineVertex + 1, 
            PGL.javaToNativeARGB(strokeColor));
          root.setModifiedLineColors(firstLineVertex, lastLineVertex);
        } else if (is2D()) {
          Arrays.fill(tessGeo.polyColors, firstLineVertex, lastLineVertex + 1, 
            PGL.javaToNativeARGB(strokeColor));
          root.setModifiedPolyColors(firstLineVertex, lastLineVertex);
        }
      }
      if (hasPoints) {
        if (is3D()) {
          Arrays.fill(tessGeo.pointColors, firstPointVertex, lastPointVertex + 1, 
            PGL.javaToNativeARGB(strokeColor));
          root.setModifiedPointColors(firstPointVertex, lastPointVertex);
        } else if (is2D()) {
          Arrays.fill(tessGeo.polyColors, firstPointVertex, lastPointVertex + 1, 
            PGL.javaToNativeARGB(strokeColor));
          root.setModifiedPolyColors(firstPointVertex, lastPointVertex);
        }
      }
    }
  }
  

  public void setStroke(int index, int stroke)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStroke()" });
      return;
    }
    
    inGeo.strokeColors[index] = PGL.javaToNativeARGB(stroke);
    markForTessellation();
  }
  

  public float getStrokeWeight(int index)
  {
    if (family != 0) {
      return inGeo.strokeWeights[index];
    }
    return 0.0F;
  }
  


  public void setStrokeWeight(float weight)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStrokeWeight()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setStrokeWeight(weight);
      }
    } else {
      setStrokeWeightImpl(weight);
    }
  }
  
  protected void setStrokeWeightImpl(float weight)
  {
    if (PGraphicsOpenGL.same(strokeWeight, weight)) return;
    float oldWeight = strokeWeight;
    strokeWeight = weight;
    
    Arrays.fill(inGeo.strokeWeights, 0, inGeo.vertexCount, strokeWeight);
    if ((shapeCreated) && (tessellated) && ((hasLines) || (hasPoints))) {
      float resizeFactor = weight / oldWeight;
      if (hasLines) {
        if (is3D()) {
          for (int i = firstLineVertex; i <= lastLineVertex; i++) {
            tessGeo.lineDirections[(4 * i + 3)] *= resizeFactor;
          }
          root.setModifiedLineAttributes(firstLineVertex, lastLineVertex);
        } else if (is2D())
        {


          markForTessellation();
        }
      }
      if (hasPoints) {
        if (is3D()) {
          for (int i = firstPointVertex; i <= lastPointVertex; i++) {
            tessGeo.pointOffsets[(2 * i + 0)] *= resizeFactor;
            tessGeo.pointOffsets[(2 * i + 1)] *= resizeFactor;
          }
          root.setModifiedPointAttributes(firstPointVertex, lastPointVertex);
        } else if (is2D())
        {


          markForTessellation();
        }
      }
    }
  }
  

  public void setStrokeWeight(int index, float weight)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStrokeWeight()" });
      return;
    }
    
    inGeo.strokeWeights[index] = weight;
    markForTessellation();
  }
  

  public void setStrokeJoin(int join)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStrokeJoin()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setStrokeJoin(join);
      }
    } else {
      if ((is2D()) && (strokeJoin != join))
      {


        markForTessellation();
      }
      strokeJoin = join;
    }
  }
  

  public void setStrokeCap(int cap)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setStrokeCap()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setStrokeCap(cap);
      }
    } else {
      if ((is2D()) && (strokeCap != cap))
      {


        markForTessellation();
      }
      strokeCap = cap;
    }
  }
  

  public int getAmbient(int index)
  {
    if (family != 0) {
      return PGL.nativeToJavaARGB(inGeo.ambient[index]);
    }
    return 0;
  }
  


  public void setAmbient(int ambient)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setAmbient()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setAmbient(ambient);
      }
    } else {
      setAmbientImpl(ambient);
    }
  }
  
  protected void setAmbientImpl(int ambient)
  {
    if (ambientColor == ambient) return;
    ambientColor = ambient;
    
    Arrays.fill(inGeo.ambient, 0, inGeo.vertexCount, 
      PGL.javaToNativeARGB(ambientColor));
    if ((shapeCreated) && (tessellated) && (hasPolys)) {
      if (is3D()) {
        Arrays.fill(tessGeo.polyAmbient, firstPolyVertex, lastPolyVertex + 1, 
          PGL.javaToNativeARGB(ambientColor));
        root.setModifiedPolyAmbient(firstPolyVertex, lastPolyVertex);
      } else if (is2D()) {
        int last1 = lastPolyVertex + 1;
        if (-1 < firstLineVertex) last1 = firstLineVertex;
        if (-1 < firstPointVertex) last1 = firstPointVertex;
        Arrays.fill(tessGeo.polyAmbient, firstPolyVertex, last1, 
          PGL.javaToNativeARGB(ambientColor));
        root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
      }
    }
    setAmbient = true;
  }
  

  public void setAmbient(int index, int ambient)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setAmbient()" });
      return;
    }
    
    inGeo.ambient[index] = PGL.javaToNativeARGB(ambient);
    markForTessellation();
    setAmbient = true;
  }
  

  public int getSpecular(int index)
  {
    if (family == 0) {
      return PGL.nativeToJavaARGB(inGeo.specular[index]);
    }
    return 0;
  }
  


  public void setSpecular(int specular)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setSpecular()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setSpecular(specular);
      }
    } else {
      setSpecularImpl(specular);
    }
  }
  
  protected void setSpecularImpl(int specular)
  {
    if (specularColor == specular) return;
    specularColor = specular;
    
    Arrays.fill(inGeo.specular, 0, inGeo.vertexCount, 
      PGL.javaToNativeARGB(specularColor));
    if ((shapeCreated) && (tessellated) && (hasPolys)) {
      if (is3D()) {
        Arrays.fill(tessGeo.polySpecular, firstPolyVertex, lastPolyVertex + 1, 
          PGL.javaToNativeARGB(specularColor));
        root.setModifiedPolySpecular(firstPolyVertex, lastPolyVertex);
      } else if (is2D()) {
        int last1 = lastPolyVertex + 1;
        if (-1 < firstLineVertex) last1 = firstLineVertex;
        if (-1 < firstPointVertex) last1 = firstPointVertex;
        Arrays.fill(tessGeo.polySpecular, firstPolyVertex, last1, 
          PGL.javaToNativeARGB(specularColor));
        root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
      }
    }
  }
  

  public void setSpecular(int index, int specular)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setSpecular()" });
      return;
    }
    
    inGeo.specular[index] = PGL.javaToNativeARGB(specular);
    markForTessellation();
  }
  

  public int getEmissive(int index)
  {
    if (family == 0) {
      return PGL.nativeToJavaARGB(inGeo.emissive[index]);
    }
    return 0;
  }
  


  public void setEmissive(int emissive)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setEmissive()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setEmissive(emissive);
      }
    } else {
      setEmissiveImpl(emissive);
    }
  }
  
  protected void setEmissiveImpl(int emissive)
  {
    if (emissiveColor == emissive) return;
    emissiveColor = emissive;
    
    Arrays.fill(inGeo.emissive, 0, inGeo.vertexCount, 
      PGL.javaToNativeARGB(emissiveColor));
    if ((shapeCreated) && (tessellated) && (tessGeo.polyVertexCount > 0)) {
      if (is3D()) {
        Arrays.fill(tessGeo.polyEmissive, firstPolyVertex, lastPolyVertex + 1, 
          PGL.javaToNativeARGB(emissiveColor));
        root.setModifiedPolyEmissive(firstPolyVertex, lastPolyVertex);
      } else if (is2D()) {
        int last1 = lastPolyVertex + 1;
        if (-1 < firstLineVertex) last1 = firstLineVertex;
        if (-1 < firstPointVertex) last1 = firstPointVertex;
        Arrays.fill(tessGeo.polyEmissive, firstPolyVertex, last1, 
          PGL.javaToNativeARGB(emissiveColor));
        root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
      }
    }
  }
  

  public void setEmissive(int index, int emissive)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setEmissive()" });
      return;
    }
    
    inGeo.emissive[index] = PGL.javaToNativeARGB(emissive);
    markForTessellation();
  }
  

  public float getShininess(int index)
  {
    if (family == 0) {
      return inGeo.shininess[index];
    }
    return 0.0F;
  }
  


  public void setShininess(float shininess)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setShininess()" });
      return;
    }
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.setShininess(shininess);
      }
    } else {
      setShininessImpl(shininess);
    }
  }
  
  protected void setShininessImpl(float shininess)
  {
    if (PGraphicsOpenGL.same(this.shininess, shininess)) return;
    this.shininess = shininess;
    
    Arrays.fill(inGeo.shininess, 0, inGeo.vertexCount, shininess);
    if ((shapeCreated) && (tessellated) && (hasPolys)) {
      if (is3D()) {
        Arrays.fill(tessGeo.polyShininess, firstPolyVertex, lastPolyVertex + 1, 
          shininess);
        root.setModifiedPolyShininess(firstPolyVertex, lastPolyVertex);
      } else if (is2D()) {
        int last1 = lastPolyVertex + 1;
        if (-1 < firstLineVertex) last1 = firstLineVertex;
        if (-1 < firstPointVertex) last1 = firstPointVertex;
        Arrays.fill(tessGeo.polyShininess, firstPolyVertex, last1, shininess);
        root.setModifiedPolyColors(firstPolyVertex, last1 - 1);
      }
    }
  }
  

  public void setShininess(int index, float shine)
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "setShininess()" });
      return;
    }
    
    inGeo.shininess[index] = shine;
    markForTessellation();
  }
  







  public int[] getVertexCodes()
  {
    if (family == 0) { return null;
    }
    if ((family == 101) || (family == 102))
    {

      updateTessellation();
    }
    if (inGeo.codes == null) return null;
    return inGeo.codes;
  }
  


  public int getVertexCodeCount()
  {
    if (family == 0) { return 0;
    }
    if ((family == 101) || (family == 102))
    {

      updateTessellation();
    }
    return inGeo.codeCount;
  }
  





  public int getVertexCode(int index)
  {
    return inGeo.codes[index];
  }
  








  public PShape getTessellation()
  {
    updateTessellation();
    
    float[] vertices = tessGeo.polyVertices;
    float[] normals = tessGeo.polyNormals;
    int[] color = tessGeo.polyColors;
    float[] uv = tessGeo.polyTexCoords;
    short[] indices = tessGeo.polyIndices;
    











    PShape tess = pg.createShapeFamily(103);
    tess.set3D(is3D);
    tess.beginShape(9);
    tess.noStroke();
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.polyIndexCache;
    for (int n = firstPolyIndexCache; n <= lastPolyIndexCache; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      for (int tr = ioffset / 3; tr < (ioffset + icount) / 3; tr++) {
        int i0 = voffset + indices[(3 * tr + 0)];
        int i1 = voffset + indices[(3 * tr + 1)];
        int i2 = voffset + indices[(3 * tr + 2)];
        
        if (is3D()) {
          float x0 = vertices[(4 * i0 + 0)];
          float y0 = vertices[(4 * i0 + 1)];
          float z0 = vertices[(4 * i0 + 2)];
          float x1 = vertices[(4 * i1 + 0)];
          float y1 = vertices[(4 * i1 + 1)];
          float z1 = vertices[(4 * i1 + 2)];
          float x2 = vertices[(4 * i2 + 0)];
          float y2 = vertices[(4 * i2 + 1)];
          float z2 = vertices[(4 * i2 + 2)];
          
          float nx0 = normals[(3 * i0 + 0)];
          float ny0 = normals[(3 * i0 + 1)];
          float nz0 = normals[(3 * i0 + 2)];
          float nx1 = normals[(3 * i1 + 0)];
          float ny1 = normals[(3 * i1 + 1)];
          float nz1 = normals[(3 * i1 + 2)];
          float nx2 = normals[(3 * i2 + 0)];
          float ny2 = normals[(3 * i2 + 1)];
          float nz2 = normals[(3 * i2 + 2)];
          
          int argb0 = PGL.nativeToJavaARGB(color[i0]);
          int argb1 = PGL.nativeToJavaARGB(color[i1]);
          int argb2 = PGL.nativeToJavaARGB(color[i2]);
          
          tess.fill(argb0);
          tess.normal(nx0, ny0, nz0);
          tess.vertex(x0, y0, z0, uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
          
          tess.fill(argb1);
          tess.normal(nx1, ny1, nz1);
          tess.vertex(x1, y1, z1, uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
          
          tess.fill(argb2);
          tess.normal(nx2, ny2, nz2);
          tess.vertex(x2, y2, z2, uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
        } else if (is2D()) {
          float x0 = vertices[(4 * i0 + 0)];float y0 = vertices[(4 * i0 + 1)];
          float x1 = vertices[(4 * i1 + 0)];float y1 = vertices[(4 * i1 + 1)];
          float x2 = vertices[(4 * i2 + 0)];float y2 = vertices[(4 * i2 + 1)];
          
          int argb0 = PGL.nativeToJavaARGB(color[i0]);
          int argb1 = PGL.nativeToJavaARGB(color[i1]);
          int argb2 = PGL.nativeToJavaARGB(color[i2]);
          
          tess.fill(argb0);
          tess.vertex(x0, y0, uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
          
          tess.fill(argb1);
          tess.vertex(x1, y1, uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
          
          tess.fill(argb2);
          tess.vertex(x2, y2, uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
        }
      }
    }
    tess.endShape();
    
    return tess;
  }
  
  public float[] getTessellation(int kind, int data)
  {
    updateTessellation();
    
    if (kind == 9) {
      if (data == 0) {
        if (is3D()) {
          root.setModifiedPolyVertices(firstPolyVertex, lastPolyVertex);
        } else if (is2D()) {
          int last1 = lastPolyVertex + 1;
          if (-1 < firstLineVertex) last1 = firstLineVertex;
          if (-1 < firstPointVertex) last1 = firstPointVertex;
          root.setModifiedPolyVertices(firstPolyVertex, last1 - 1);
        }
        return tessGeo.polyVertices; }
      if (data == 1) {
        if (is3D()) {
          root.setModifiedPolyNormals(firstPolyVertex, lastPolyVertex);
        } else if (is2D()) {
          int last1 = lastPolyVertex + 1;
          if (-1 < firstLineVertex) last1 = firstLineVertex;
          if (-1 < firstPointVertex) last1 = firstPointVertex;
          root.setModifiedPolyNormals(firstPolyVertex, last1 - 1);
        }
        return tessGeo.polyNormals; }
      if (data == 2) {
        if (is3D()) {
          root.setModifiedPolyTexCoords(firstPolyVertex, lastPolyVertex);
        } else if (is2D()) {
          int last1 = lastPolyVertex + 1;
          if (-1 < firstLineVertex) last1 = firstLineVertex;
          if (-1 < firstPointVertex) last1 = firstPointVertex;
          root.setModifiedPolyTexCoords(firstPolyVertex, last1 - 1);
        }
        return tessGeo.polyTexCoords;
      }
    } else if (kind == 5) {
      if (data == 0) {
        if (is3D()) {
          root.setModifiedLineVertices(firstLineVertex, lastLineVertex);
        } else if (is2D()) {
          root.setModifiedPolyVertices(firstLineVertex, lastLineVertex);
        }
        return tessGeo.lineVertices; }
      if (data == 3) {
        if (is2D()) {
          root.setModifiedLineAttributes(firstLineVertex, lastLineVertex);
        }
        return tessGeo.lineDirections;
      }
    } else if (kind == 3) {
      if (data == 0) {
        if (is3D()) {
          root.setModifiedPointVertices(firstPointVertex, lastPointVertex);
        } else if (is2D()) {
          root.setModifiedPolyVertices(firstPointVertex, lastPointVertex);
        }
        return tessGeo.pointVertices; }
      if (data == 4) {
        if (is2D()) {
          root.setModifiedPointAttributes(firstPointVertex, lastPointVertex);
        }
        return tessGeo.pointOffsets;
      }
    }
    return null;
  }
  







  public boolean contains(float x, float y)
  {
    if (family == 102) {
      boolean c = false;
      int i = 0; for (int j = inGeo.vertexCount - 1; i < inGeo.vertexCount; j = i++) {
        if ((inGeo.vertices[(3 * i + 1)] > y ? 1 : 0) != (inGeo.vertices[(3 * j + 1)] > y ? 1 : 0))
        {
          if (x < (inGeo.vertices[(3 * j)] - inGeo.vertices[(3 * i)]) * (
            y - inGeo.vertices[(3 * i + 1)]) / (
            inGeo.vertices[(3 * j + 1)] - inGeo.vertices[(3 * i + 1)]) + 
            inGeo.vertices[(3 * i)])
            c = !c;
        }
      }
      return c;
    }
    throw new IllegalArgumentException("The contains() method is only implemented for paths.");
  }
  








  protected void updateTessellation()
  {
    if (!root.tessellated) {
      root.tessellate();
      root.aggregate();
      root.initModified();
      root.needBufferInit = true;
    }
  }
  
  protected void markForTessellation()
  {
    root.tessellated = false;
    tessellated = false;
  }
  
  protected void initModified()
  {
    modified = false;
    
    modifiedPolyVertices = false;
    modifiedPolyColors = false;
    modifiedPolyNormals = false;
    modifiedPolyTexCoords = false;
    modifiedPolyAmbient = false;
    modifiedPolySpecular = false;
    modifiedPolyEmissive = false;
    modifiedPolyShininess = false;
    
    modifiedLineVertices = false;
    modifiedLineColors = false;
    modifiedLineAttributes = false;
    
    modifiedPointVertices = false;
    modifiedPointColors = false;
    modifiedPointAttributes = false;
    
    firstModifiedPolyVertex = Integer.MAX_VALUE;
    lastModifiedPolyVertex = Integer.MIN_VALUE;
    firstModifiedPolyColor = Integer.MAX_VALUE;
    lastModifiedPolyColor = Integer.MIN_VALUE;
    firstModifiedPolyNormal = Integer.MAX_VALUE;
    lastModifiedPolyNormal = Integer.MIN_VALUE;
    firstModifiedPolyTexcoord = Integer.MAX_VALUE;
    lastModifiedPolyTexcoord = Integer.MIN_VALUE;
    firstModifiedPolyAmbient = Integer.MAX_VALUE;
    lastModifiedPolyAmbient = Integer.MIN_VALUE;
    firstModifiedPolySpecular = Integer.MAX_VALUE;
    lastModifiedPolySpecular = Integer.MIN_VALUE;
    firstModifiedPolyEmissive = Integer.MAX_VALUE;
    lastModifiedPolyEmissive = Integer.MIN_VALUE;
    firstModifiedPolyShininess = Integer.MAX_VALUE;
    lastModifiedPolyShininess = Integer.MIN_VALUE;
    
    firstModifiedLineVertex = Integer.MAX_VALUE;
    lastModifiedLineVertex = Integer.MIN_VALUE;
    firstModifiedLineColor = Integer.MAX_VALUE;
    lastModifiedLineColor = Integer.MIN_VALUE;
    firstModifiedLineAttribute = Integer.MAX_VALUE;
    lastModifiedLineAttribute = Integer.MIN_VALUE;
    
    firstModifiedPointVertex = Integer.MAX_VALUE;
    lastModifiedPointVertex = Integer.MIN_VALUE;
    firstModifiedPointColor = Integer.MAX_VALUE;
    lastModifiedPointColor = Integer.MIN_VALUE;
    firstModifiedPointAttribute = Integer.MAX_VALUE;
    lastModifiedPointAttribute = Integer.MIN_VALUE;
  }
  
  protected void tessellate()
  {
    if ((root == this) && (parent == null)) {
      if (polyAttribs == null) {
        polyAttribs = PGraphicsOpenGL.newAttributeMap();
        collectPolyAttribs();
      }
      
      if (tessGeo == null) {
        tessGeo = PGraphicsOpenGL.newTessGeometry(pg, polyAttribs, 1);
      }
      tessGeo.clear();
      for (int i = 0; i < polyAttribs.size(); i++) {
        PGraphicsOpenGL.VertexAttribute attrib = polyAttribs.get(i);
        tessGeo.initAttrib(attrib);
      }
      
      tessellateImpl();
      



      tessGeo.trim();
    }
  }
  
  protected void collectPolyAttribs()
  {
    PGraphicsOpenGL.AttributeMap rootAttribs = root.polyAttribs;
    
    if (family == 0) {
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.collectPolyAttribs();
      }
    } else {
      for (int i = 0; i < polyAttribs.size(); i++) {
        PGraphicsOpenGL.VertexAttribute attrib = polyAttribs.get(i);
        tessGeo.initAttrib(attrib);
        if (rootAttribs.containsKey(name)) {
          PGraphicsOpenGL.VertexAttribute rattrib = (PGraphicsOpenGL.VertexAttribute)rootAttribs.get(name);
          if (rattrib.diff(attrib)) {
            throw new RuntimeException("Children shapes cannot have different attributes with same name");
          }
        } else {
          rootAttribs.put(name, attrib);
        }
      }
    }
  }
  
  protected void tessellateImpl() {
    tessGeo = root.tessGeo;
    
    firstPolyIndexCache = -1;
    lastPolyIndexCache = -1;
    firstLineIndexCache = -1;
    lastLineIndexCache = -1;
    firstPointIndexCache = -1;
    lastPointIndexCache = -1;
    
    if (family == 0) {
      if (polyAttribs == null) {
        polyAttribs = PGraphicsOpenGL.newAttributeMap();
        collectPolyAttribs();
      }
      
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.tessellateImpl();
      }
    }
    else if (shapeCreated)
    {



      inGeo.clearEdges();
      
      tessellator.setInGeometry(inGeo);
      tessellator.setTessGeometry(tessGeo);
      tessellator.setFill((fill) || (image != null));
      tessellator.setTexCache(null, null);
      tessellator.setStroke(stroke);
      tessellator.setStrokeColor(strokeColor);
      tessellator.setStrokeWeight(strokeWeight);
      tessellator.setStrokeCap(strokeCap);
      tessellator.setStrokeJoin(strokeJoin);
      tessellator.setRenderer(pg);
      tessellator.setTransform(matrix);
      tessellator.set3D(is3D());
      
      if (family == 103) {
        if (kind == 3) {
          tessellator.tessellatePoints();
        } else if (kind == 5) {
          tessellator.tessellateLines();
        } else if (kind == 50) {
          tessellator.tessellateLineStrip();
        } else if (kind == 51) {
          tessellator.tessellateLineLoop();
        } else if ((kind == 8) || (kind == 9)) {
          if (stroke) inGeo.addTrianglesEdges();
          if (normalMode == 0) inGeo.calcTrianglesNormals();
          tessellator.tessellateTriangles();
        } else if (kind == 11) {
          if (stroke) inGeo.addTriangleFanEdges();
          if (normalMode == 0) inGeo.calcTriangleFanNormals();
          tessellator.tessellateTriangleFan();
        } else if (kind == 10) {
          if (stroke) inGeo.addTriangleStripEdges();
          if (normalMode == 0) inGeo.calcTriangleStripNormals();
          tessellator.tessellateTriangleStrip();
        } else if ((kind == 16) || (kind == 17)) {
          if (stroke) inGeo.addQuadsEdges();
          if (normalMode == 0) inGeo.calcQuadsNormals();
          tessellator.tessellateQuads();
        } else if (kind == 18) {
          if (stroke) inGeo.addQuadStripEdges();
          if (normalMode == 0) inGeo.calcQuadStripNormals();
          tessellator.tessellateQuadStrip();
        } else if (kind == 20) {
          boolean bez = inGeo.hasBezierVertex();
          boolean quad = inGeo.hasQuadraticVertex();
          boolean curv = inGeo.hasCurveVertex();
          if ((bez) || (quad)) saveBezierVertexSettings();
          if (curv) {
            saveCurveVertexSettings();
            tessellator.resetCurveVertexCount();
          }
          tessellator.tessellatePolygon(solid, close, 
            normalMode == 0);
          if ((bez) || (quad)) restoreBezierVertexSettings();
          if (curv) restoreCurveVertexSettings();
        }
      } else if (family == 101)
      {


        inGeo.clear();
        
        if (kind == 2) {
          tessellatePoint();
        } else if (kind == 4) {
          tessellateLine();
        } else if (kind == 8) {
          tessellateTriangle();
        } else if (kind == 16) {
          tessellateQuad();
        } else if (kind == 30) {
          tessellateRect();
        } else if (kind == 31) {
          tessellateEllipse();
        } else if (kind == 32) {
          tessellateArc();
        } else if (kind == 41) {
          tessellateBox();
        } else if (kind == 40) {
          tessellateSphere();
        }
      } else if (family == 102) {
        inGeo.clear();
        tessellatePath();
      }
      
      if ((image != null) && (parent != null)) {
        ((PShapeOpenGL)parent).addTexture(image);
      }
      
      firstPolyIndexCache = tessellator.firstPolyIndexCache;
      lastPolyIndexCache = tessellator.lastPolyIndexCache;
      firstLineIndexCache = tessellator.firstLineIndexCache;
      lastLineIndexCache = tessellator.lastLineIndexCache;
      firstPointIndexCache = tessellator.firstPointIndexCache;
      lastPointIndexCache = tessellator.lastPointIndexCache;
    }
    

    firstPolyVertex = (this.lastPolyVertex = -1);
    firstLineVertex = (this.lastLineVertex = -1);
    firstPointVertex = (this.lastPointVertex = -1);
    
    tessellated = true;
  }
  
  protected void tessellatePoint()
  {
    float x = 0.0F;float y = 0.0F;float z = 0.0F;
    if (params.length == 2) {
      x = params[0];
      y = params[1];
      z = 0.0F;
    } else if (params.length == 3) {
      x = params[0];
      y = params[1];
      z = params[2];
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addPoint(x, y, z, fill, stroke);
    tessellator.tessellatePoints();
  }
  
  protected void tessellateLine()
  {
    float x1 = 0.0F;float y1 = 0.0F;float z1 = 0.0F;
    float x2 = 0.0F;float y2 = 0.0F;float z2 = 0.0F;
    if (params.length == 4) {
      x1 = params[0];
      y1 = params[1];
      x2 = params[2];
      y2 = params[3];
    } else if (params.length == 6) {
      x1 = params[0];
      y1 = params[1];
      z1 = params[2];
      x2 = params[3];
      y2 = params[4];
      z2 = params[5];
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addLine(x1, y1, z1, 
      x2, y2, z2, 
      fill, stroke);
    tessellator.tessellateLines();
  }
  
  protected void tessellateTriangle()
  {
    float x1 = 0.0F;float y1 = 0.0F;
    float x2 = 0.0F;float y2 = 0.0F;
    float x3 = 0.0F;float y3 = 0.0F;
    if (params.length == 6) {
      x1 = params[0];
      y1 = params[1];
      x2 = params[2];
      y2 = params[3];
      x3 = params[4];
      y3 = params[5];
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addTriangle(x1, y1, 0.0F, 
      x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      fill, stroke);
    tessellator.tessellateTriangles();
  }
  
  protected void tessellateQuad()
  {
    float x1 = 0.0F;float y1 = 0.0F;
    float x2 = 0.0F;float y2 = 0.0F;
    float x3 = 0.0F;float y3 = 0.0F;
    float x4 = 0.0F;float y4 = 0.0F;
    if (params.length == 8) {
      x1 = params[0];
      y1 = params[1];
      x2 = params[2];
      y2 = params[3];
      x3 = params[4];
      y3 = params[5];
      x4 = params[6];
      y4 = params[7];
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addQuad(x1, y1, 0.0F, 
      x2, y2, 0.0F, 
      x3, y3, 0.0F, 
      x4, y4, 0.0F, 
      stroke);
    tessellator.tessellateQuads();
  }
  
  protected void tessellateRect()
  {
    float a = 0.0F;float b = 0.0F;float c = 0.0F;float d = 0.0F;
    float tl = 0.0F;float tr = 0.0F;float br = 0.0F;float bl = 0.0F;
    boolean rounded = false;
    int mode = rectMode;
    
    if ((params.length == 4) || (params.length == 5)) {
      a = params[0];
      b = params[1];
      c = params[2];
      d = params[3];
      rounded = false;
      if (params.length == 5) {
        tl = params[4];
        tr = params[4];
        br = params[4];
        bl = params[4];
        rounded = true;
      }
    } else if (params.length == 8) {
      a = params[0];
      b = params[1];
      c = params[2];
      d = params[3];
      tl = params[4];
      tr = params[5];
      br = params[6];
      bl = params[7];
      rounded = true;
    }
    

    switch (mode) {
    case 1: 
      break;
    case 0: 
      c += a;d += b;
      break;
    case 2: 
      float hradius = c;
      float vradius = d;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
      break;
    case 3: 
      float hradius = c / 2.0F;
      float vradius = d / 2.0F;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
    }
    
    if (a > c) {
      float temp = a;a = c;c = temp;
    }
    
    if (b > d) {
      float temp = b;b = d;d = temp;
    }
    
    float maxRounding = PApplet.min((c - a) / 2.0F, (d - b) / 2.0F);
    if (tl > maxRounding) tl = maxRounding;
    if (tr > maxRounding) tr = maxRounding;
    if (br > maxRounding) br = maxRounding;
    if (bl > maxRounding) { bl = maxRounding;
    }
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    if (rounded) {
      saveBezierVertexSettings();
      inGeo.addRect(a, b, c, d, tl, tr, br, bl, stroke);
      tessellator.tessellatePolygon(true, true, true);
      restoreBezierVertexSettings();
    } else {
      inGeo.addRect(a, b, c, d, stroke);
      tessellator.tessellateQuads();
    }
  }
  
  protected void tessellateEllipse()
  {
    float a = 0.0F;float b = 0.0F;float c = 0.0F;float d = 0.0F;
    int mode = ellipseMode;
    
    if (4 <= params.length) {
      a = params[0];
      b = params[1];
      c = params[2];
      d = params[3];
    }
    
    float x = a;
    float y = b;
    float w = c;
    float h = d;
    
    if (mode == 1) {
      w = c - a;
      h = d - b;
    }
    else if (mode == 2) {
      x = a - c;
      y = b - d;
      w = c * 2.0F;
      h = d * 2.0F;
    }
    else if (mode == 3) {
      x = a - c / 2.0F;
      y = b - d / 2.0F;
    }
    
    if (w < 0.0F) {
      x += w;
      w = -w;
    }
    
    if (h < 0.0F) {
      y += h;
      h = -h;
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.setNormal(normalX, normalY, normalZ);
    inGeo.addEllipse(x, y, w, h, fill, stroke);
    tessellator.tessellateTriangleFan();
  }
  
  protected void tessellateArc()
  {
    float a = 0.0F;float b = 0.0F;float c = 0.0F;float d = 0.0F;
    float start = 0.0F;float stop = 0.0F;
    int mode = ellipseMode;
    int arcMode = 0;
    
    if (6 <= params.length) {
      a = params[0];
      b = params[1];
      c = params[2];
      d = params[3];
      start = params[4];
      stop = params[5];
      if (params.length == 7) {
        arcMode = (int)params[6];
      }
    }
    
    float x = a;
    float y = b;
    float w = c;
    float h = d;
    
    if (mode == 1) {
      w = c - a;
      h = d - b;
    }
    else if (mode == 2) {
      x = a - c;
      y = b - d;
      w = c * 2.0F;
      h = d * 2.0F;
    }
    else if (mode == 3) {
      x = a - c / 2.0F;
      y = b - d / 2.0F;
    }
    

    if ((!Float.isInfinite(start)) && (!Float.isInfinite(stop)))
    {
      if (stop > start)
      {
        while (start < 0.0F) {
          start += 6.2831855F;
          stop += 6.2831855F;
        }
        
        if (stop - start > 6.2831855F)
        {
          stop = start + 6.2831855F;
        }
        inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
          ambientColor, specularColor, emissiveColor, shininess);
        inGeo.setNormal(normalX, normalY, normalZ);
        inGeo.addArc(x, y, w, h, start, stop, fill, stroke, arcMode);
        tessellator.tessellateTriangleFan();
      }
    }
  }
  
  protected void tessellateBox()
  {
    float w = 0.0F;float h = 0.0F;float d = 0.0F;
    if (params.length == 1) {
      w = h = d = params[0];
    } else if (params.length == 3) {
      w = params[0];
      h = params[1];
      d = params[2];
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    inGeo.addBox(w, h, d, fill, stroke);
    tessellator.tessellateQuads();
  }
  
  protected void tessellateSphere()
  {
    float r = 0.0F;
    int nu = sphereDetailU;
    int nv = sphereDetailV;
    if (1 <= params.length) {
      r = params[0];
      if (params.length == 2) {
        nu = nv = (int)params[1];
      } else if (params.length == 3) {
        nu = (int)params[1];
        nv = (int)params[2];
      }
    }
    
    if ((nu < 3) || (nv < 2)) {
      nu = nv = 30;
    }
    int savedDetailU = pg.sphereDetailU;
    int savedDetailV = pg.sphereDetailV;
    if ((pg.sphereDetailU != nu) || (pg.sphereDetailV != nv)) {
      pg.sphereDetail(nu, nv);
    }
    
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    int[] indices = inGeo.addSphere(r, nu, nv, fill, stroke);
    tessellator.tessellateTriangles(indices);
    
    if (((savedDetailU > 0) && (savedDetailU != nu)) || (
      (savedDetailV > 0) && (savedDetailV != nv))) {
      pg.sphereDetail(savedDetailU, savedDetailV);
    }
  }
  
  protected void tessellatePath()
  {
    if (vertices == null) { return;
    }
    inGeo.setMaterial(fillColor, strokeColor, strokeWeight, 
      ambientColor, specularColor, emissiveColor, shininess);
    
    if (vertexCodeCount == 0) {
      if (vertices[0].length == 2) {
        for (int i = 0; i < vertexCount; i++) {
          inGeo.addVertex(vertices[i][0], vertices[i][1], 0, false);
        }
      } else {
        for (int i = 0; i < vertexCount; i++) {
          inGeo.addVertex(vertices[i][0], vertices[i][1], vertices[i][2], 
            0, false);
        }
      }
    } else {
      int idx = 0;
      boolean brk = true;
      
      if (vertices[0].length == 2)
      {
        for (int j = 0; j < vertexCodeCount; j++) {
          switch (vertexCodes[j])
          {
          case 0: 
            inGeo.addVertex(vertices[idx][0], vertices[idx][1], 0, brk);
            brk = false;
            idx++;
            break;
          
          case 2: 
            inGeo.addQuadraticVertex(vertices[(idx + 0)][0], vertices[(idx + 0)][1], 0.0F, 
              vertices[(idx + 1)][0], vertices[(idx + 1)][1], 0.0F, 
              brk);
            brk = false;
            idx += 2;
            break;
          
          case 1: 
            inGeo.addBezierVertex(vertices[(idx + 0)][0], vertices[(idx + 0)][1], 0.0F, 
              vertices[(idx + 1)][0], vertices[(idx + 1)][1], 0.0F, 
              vertices[(idx + 2)][0], vertices[(idx + 2)][1], 0.0F, 
              brk);
            brk = false;
            idx += 3;
            break;
          
          case 3: 
            inGeo.addCurveVertex(vertices[idx][0], vertices[idx][1], 0.0F, brk);
            brk = false;
            idx++;
            break;
          
          case 4: 
            brk = true;
          }
        }
      } else {
        for (int j = 0; j < vertexCodeCount; j++) {
          switch (vertexCodes[j])
          {
          case 0: 
            inGeo.addVertex(vertices[idx][0], vertices[idx][1], 
              vertices[idx][2], brk);
            brk = false;
            idx++;
            break;
          
          case 2: 
            inGeo.addQuadraticVertex(vertices[(idx + 0)][0], 
              vertices[(idx + 0)][1], 
              vertices[(idx + 0)][2], 
              vertices[(idx + 1)][0], 
              vertices[(idx + 1)][1], 
              vertices[(idx + 0)][2], 
              brk);
            brk = false;
            idx += 2;
            break;
          
          case 1: 
            inGeo.addBezierVertex(vertices[(idx + 0)][0], 
              vertices[(idx + 0)][1], 
              vertices[(idx + 0)][2], 
              vertices[(idx + 1)][0], 
              vertices[(idx + 1)][1], 
              vertices[(idx + 1)][2], 
              vertices[(idx + 2)][0], 
              vertices[(idx + 2)][1], 
              vertices[(idx + 2)][2], 
              brk);
            brk = false;
            idx += 3;
            break;
          
          case 3: 
            inGeo.addCurveVertex(vertices[idx][0], 
              vertices[idx][1], 
              vertices[idx][2], 
              brk);
            brk = false;
            idx++;
            break;
          
          case 4: 
            brk = true;
          }
          
        }
      }
    }
    boolean bez = inGeo.hasBezierVertex();
    boolean quad = inGeo.hasQuadraticVertex();
    boolean curv = inGeo.hasCurveVertex();
    if ((bez) || (quad)) saveBezierVertexSettings();
    if (curv) {
      saveCurveVertexSettings();
      tessellator.resetCurveVertexCount();
    }
    tessellator.tessellatePolygon(true, close, true);
    if ((bez) || (quad)) restoreBezierVertexSettings();
    if (curv) restoreCurveVertexSettings();
  }
  
  protected void saveBezierVertexSettings() {
    savedBezierDetail = pg.bezierDetail;
    if (pg.bezierDetail != bezierDetail) {
      pg.bezierDetail(bezierDetail);
    }
  }
  
  protected void restoreBezierVertexSettings() {
    if (savedBezierDetail != bezierDetail) {
      pg.bezierDetail(savedBezierDetail);
    }
  }
  
  protected void saveCurveVertexSettings() {
    savedCurveDetail = pg.curveDetail;
    savedCurveTightness = pg.curveTightness;
    if (pg.curveDetail != curveDetail) {
      pg.curveDetail(curveDetail);
    }
    if (pg.curveTightness != curveTightness) {
      pg.curveTightness(curveTightness);
    }
  }
  
  protected void restoreCurveVertexSettings() {
    if (savedCurveDetail != curveDetail) {
      pg.curveDetail(savedCurveDetail);
    }
    if (savedCurveTightness != curveTightness) {
      pg.curveTightness(savedCurveTightness);
    }
  }
  






  protected void aggregate()
  {
    if ((root == this) && (parent == null))
    {

      polyIndexOffset = 0;
      polyVertexOffset = 0;
      polyVertexAbs = 0;
      polyVertexRel = 0;
      
      lineIndexOffset = 0;
      lineVertexOffset = 0;
      lineVertexAbs = 0;
      lineVertexRel = 0;
      
      pointIndexOffset = 0;
      pointVertexOffset = 0;
      pointVertexAbs = 0;
      pointVertexRel = 0;
      

      aggregateImpl();
    }
  }
  



























  protected void aggregateImpl()
  {
    if (family == 0)
    {
      hasPolys = false;
      hasLines = false;
      hasPoints = false;
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        child.aggregateImpl();
        hasPolys |= hasPolys;
        hasLines |= hasLines;
        hasPoints |= hasPoints;
      }
    } else {
      hasPolys = ((-1 < firstPolyIndexCache) && (-1 < lastPolyIndexCache));
      hasLines = ((-1 < firstLineIndexCache) && (-1 < lastLineIndexCache));
      hasPoints = ((-1 < firstPointIndexCache) && (-1 < lastPointIndexCache));
    }
    
    if (hasPolys) {
      updatePolyIndexCache();
    }
    if (is3D()) {
      if (hasLines) updateLineIndexCache();
      if (hasPoints) { updatePointIndexCache();
      }
    }
    if (matrix != null)
    {

      if (hasPolys) {
        tessGeo.applyMatrixOnPolyGeometry(matrix, 
          firstPolyVertex, lastPolyVertex);
      }
      if (is3D()) {
        if (hasLines) {
          tessGeo.applyMatrixOnLineGeometry(matrix, 
            firstLineVertex, lastLineVertex);
        }
        if (hasPoints) {
          tessGeo.applyMatrixOnPointGeometry(matrix, 
            firstPointVertex, lastPointVertex);
        }
      }
    }
  }
  

  protected void updatePolyIndexCache()
  {
    PGraphicsOpenGL.IndexCache cache = tessGeo.polyIndexCache;
    if (family == 0)
    {











      firstPolyIndexCache = (this.lastPolyIndexCache = -1);
      int gindex = -1;
      
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        
        int first = firstPolyIndexCache;
        int count = -1 < first ? lastPolyIndexCache - first + 1 : -1;
        for (int n = first; n < first + count; n++) {
          if (gindex == -1) {
            gindex = cache.addNew(n);
            firstPolyIndexCache = gindex;
          }
          else if (vertexOffset[gindex] == vertexOffset[n])
          {




            cache.incCounts(gindex, 
              indexCount[n], vertexCount[n]);
          } else {
            gindex = cache.addNew(n);
          }
        }
        


        if (-1 < firstPolyVertex) {
          if (firstPolyVertex == -1) {
            firstPolyVertex = Integer.MAX_VALUE;
          }
          firstPolyVertex = PApplet.min(firstPolyVertex, firstPolyVertex);
        }
        if (-1 < lastPolyVertex) {
          lastPolyVertex = PApplet.max(lastPolyVertex, lastPolyVertex);
        }
      }
      lastPolyIndexCache = gindex;





    }
    else
    {





      firstPolyVertex = (this.lastPolyVertex = 
        vertexOffset[firstPolyIndexCache]);
      for (int n = firstPolyIndexCache; n <= lastPolyIndexCache; n++) {
        int ioffset = indexOffset[n];
        int icount = indexCount[n];
        int vcount = vertexCount[n];
        
        if ((PGL.MAX_VERTEX_INDEX1 <= root.polyVertexRel + vcount) || (
          (is2D()) && (startStrokedTex(n)))) {
          root.polyVertexRel = 0;
          root.polyVertexOffset = root.polyVertexAbs;
          indexOffset[n] = root.polyIndexOffset;
        } else {
          tessGeo.incPolyIndices(ioffset, ioffset + icount - 1, 
            root.polyVertexRel);
        }
        vertexOffset[n] = root.polyVertexOffset;
        if (is2D()) {
          setFirstStrokeVertex(n, lastPolyVertex);
        }
        
        root.polyIndexOffset += icount;
        root.polyVertexAbs += vcount;
        root.polyVertexRel += vcount;
        lastPolyVertex += vcount;
      }
      lastPolyVertex -= 1;
      if (is2D()) {
        setLastStrokeVertex(lastPolyVertex);
      }
    }
  }
  
  protected boolean startStrokedTex(int n)
  {
    return (image != null) && ((n == firstLineIndexCache) || 
      (n == firstPointIndexCache));
  }
  
  protected void setFirstStrokeVertex(int n, int vert)
  {
    if ((n == firstLineIndexCache) && (firstLineVertex == -1)) {
      firstLineVertex = (this.lastLineVertex = vert);
    }
    if ((n == firstPointIndexCache) && (firstPointVertex == -1)) {
      firstPointVertex = (this.lastPointVertex = vert);
    }
  }
  
  protected void setLastStrokeVertex(int vert) {
    if (-1 < lastLineVertex) {
      lastLineVertex = vert;
    }
    if (-1 < lastPointVertex) {
      lastPointVertex += vert;
    }
  }
  
  protected void updateLineIndexCache() {
    PGraphicsOpenGL.IndexCache cache = tessGeo.lineIndexCache;
    if (family == 0) {
      firstLineIndexCache = (this.lastLineIndexCache = -1);
      int gindex = -1;
      
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        
        int first = firstLineIndexCache;
        int count = -1 < first ? lastLineIndexCache - first + 1 : -1;
        for (int n = first; n < first + count; n++) {
          if (gindex == -1) {
            gindex = cache.addNew(n);
            firstLineIndexCache = gindex;
          }
          else if (vertexOffset[gindex] == vertexOffset[n]) {
            cache.incCounts(gindex, indexCount[n], 
              vertexCount[n]);
          } else {
            gindex = cache.addNew(n);
          }
        }
        


        if (-1 < firstLineVertex) {
          if (firstLineVertex == -1) firstLineVertex = Integer.MAX_VALUE;
          firstLineVertex = PApplet.min(firstLineVertex, firstLineVertex);
        }
        if (-1 < lastLineVertex) {
          lastLineVertex = PApplet.max(lastLineVertex, lastLineVertex);
        }
      }
      lastLineIndexCache = gindex;
    } else {
      firstLineVertex = (this.lastLineVertex = 
        vertexOffset[firstLineIndexCache]);
      for (int n = firstLineIndexCache; n <= lastLineIndexCache; n++) {
        int ioffset = indexOffset[n];
        int icount = indexCount[n];
        int vcount = vertexCount[n];
        
        if (PGL.MAX_VERTEX_INDEX1 <= root.lineVertexRel + vcount) {
          root.lineVertexRel = 0;
          root.lineVertexOffset = root.lineVertexAbs;
          indexOffset[n] = root.lineIndexOffset;
        } else {
          tessGeo.incLineIndices(ioffset, ioffset + icount - 1, 
            root.lineVertexRel);
        }
        vertexOffset[n] = root.lineVertexOffset;
        
        root.lineIndexOffset += icount;
        root.lineVertexAbs += vcount;
        root.lineVertexRel += vcount;
        lastLineVertex += vcount;
      }
      lastLineVertex -= 1;
    }
  }
  
  protected void updatePointIndexCache()
  {
    PGraphicsOpenGL.IndexCache cache = tessGeo.pointIndexCache;
    if (family == 0) {
      firstPointIndexCache = (this.lastPointIndexCache = -1);
      int gindex = -1;
      
      for (int i = 0; i < childCount; i++) {
        PShapeOpenGL child = (PShapeOpenGL)children[i];
        
        int first = firstPointIndexCache;
        int count = -1 < first ? lastPointIndexCache - first + 1 : -1;
        for (int n = first; n < first + count; n++) {
          if (gindex == -1) {
            gindex = cache.addNew(n);
            firstPointIndexCache = gindex;
          }
          else if (vertexOffset[gindex] == vertexOffset[n])
          {




            cache.incCounts(gindex, indexCount[n], 
              vertexCount[n]);
          } else {
            gindex = cache.addNew(n);
          }
        }
        


        if (-1 < firstPointVertex) {
          if (firstPointVertex == -1) firstPointVertex = Integer.MAX_VALUE;
          firstPointVertex = PApplet.min(firstPointVertex, 
            firstPointVertex);
        }
        if (-1 < lastPointVertex) {
          lastPointVertex = PApplet.max(lastPointVertex, lastPointVertex);
        }
      }
      lastPointIndexCache = gindex;
    } else {
      firstPointVertex = (this.lastPointVertex = 
        vertexOffset[firstPointIndexCache]);
      for (int n = firstPointIndexCache; n <= lastPointIndexCache; n++) {
        int ioffset = indexOffset[n];
        int icount = indexCount[n];
        int vcount = vertexCount[n];
        
        if (PGL.MAX_VERTEX_INDEX1 <= root.pointVertexRel + vcount) {
          root.pointVertexRel = 0;
          root.pointVertexOffset = root.pointVertexAbs;
          indexOffset[n] = root.pointIndexOffset;
        } else {
          tessGeo.incPointIndices(ioffset, ioffset + icount - 1, 
            root.pointVertexRel);
        }
        vertexOffset[n] = root.pointVertexOffset;
        
        root.pointIndexOffset += icount;
        root.pointVertexAbs += vcount;
        root.pointVertexRel += vcount;
        lastPointVertex += vcount;
      }
      lastPointVertex -= 1;
    }
  }
  







  protected void initBuffers()
  {
    boolean outdated = contextIsOutdated();
    context = pgl.getCurrentContext();
    
    if ((hasPolys) && ((needBufferInit) || (outdated))) {
      initPolyBuffers();
    }
    
    if ((hasLines) && ((needBufferInit) || (outdated))) {
      initLineBuffers();
    }
    
    if ((hasPoints) && ((needBufferInit) || (outdated))) {
      initPointBuffers();
    }
    
    needBufferInit = false;
  }
  
  protected void initPolyBuffers()
  {
    int size = tessGeo.polyVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    
    tessGeo.updatePolyVerticesBuffer();
    if (bufPolyVertex == null)
      bufPolyVertex = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 4, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.polyVerticesBuffer, glUsage);
    
    tessGeo.updatePolyColorsBuffer();
    if (bufPolyColor == null)
      bufPolyColor = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.polyColorsBuffer, glUsage);
    
    tessGeo.updatePolyNormalsBuffer();
    if (bufPolyNormal == null)
      bufPolyNormal = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 3, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyNormal.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 3 * sizef, 
      tessGeo.polyNormalsBuffer, glUsage);
    
    tessGeo.updatePolyTexCoordsBuffer();
    if (bufPolyTexcoord == null)
      bufPolyTexcoord = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 2, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyTexcoord.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 2 * sizef, 
      tessGeo.polyTexCoordsBuffer, glUsage);
    
    tessGeo.updatePolyAmbientBuffer();
    if (bufPolyAmbient == null)
      bufPolyAmbient = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyAmbient.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.polyAmbientBuffer, glUsage);
    
    tessGeo.updatePolySpecularBuffer();
    if (bufPolySpecular == null)
      bufPolySpecular = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolySpecular.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.polySpecularBuffer, glUsage);
    
    tessGeo.updatePolyEmissiveBuffer();
    if (bufPolyEmissive == null)
      bufPolyEmissive = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyEmissive.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.polyEmissiveBuffer, glUsage);
    
    tessGeo.updatePolyShininessBuffer();
    if (bufPolyShininess == null)
      bufPolyShininess = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyShininess.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizef, 
      tessGeo.polyShininessBuffer, glUsage);
    
    for (String name : polyAttribs.keySet()) {
      PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
      tessGeo.updateAttribBuffer(name);
      if (!attrib.bufferCreated()) attrib.createBuffer(pgl);
      pgl.bindBuffer(PGL.ARRAY_BUFFER, buf.glId);
      pgl.bufferData(PGL.ARRAY_BUFFER, attrib.sizeInBytes(size), 
        (Buffer)tessGeo.polyAttribBuffers.get(name), glUsage);
    }
    
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    
    tessGeo.updatePolyIndicesBuffer();
    if (bufPolyIndex == null)
      bufPolyIndex = new VertexBuffer(pg, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufPolyIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.polyIndexCount * PGL.SIZEOF_INDEX, 
      tessGeo.polyIndicesBuffer, glUsage);
    
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected void initLineBuffers()
  {
    int size = tessGeo.lineVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    
    tessGeo.updateLineVerticesBuffer();
    if (bufLineVertex == null)
      bufLineVertex = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 4, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.lineVerticesBuffer, glUsage);
    
    tessGeo.updateLineColorsBuffer();
    if (bufLineColor == null)
      bufLineColor = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.lineColorsBuffer, glUsage);
    
    tessGeo.updateLineDirectionsBuffer();
    if (bufLineAttrib == null)
      bufLineAttrib = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 4, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineAttrib.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.lineDirectionsBuffer, glUsage);
    
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    
    tessGeo.updateLineIndicesBuffer();
    if (bufLineIndex == null)
      bufLineIndex = new VertexBuffer(pg, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufLineIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.lineIndexCount * PGL.SIZEOF_INDEX, 
      tessGeo.lineIndicesBuffer, glUsage);
    
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected void initPointBuffers()
  {
    int size = tessGeo.pointVertexCount;
    int sizef = size * PGL.SIZEOF_FLOAT;
    int sizei = size * PGL.SIZEOF_INT;
    
    tessGeo.updatePointVerticesBuffer();
    if (bufPointVertex == null)
      bufPointVertex = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 4, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointVertex.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 4 * sizef, 
      tessGeo.pointVerticesBuffer, glUsage);
    
    tessGeo.updatePointColorsBuffer();
    if (bufPointColor == null)
      bufPointColor = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 1, PGL.SIZEOF_INT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointColor.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, sizei, 
      tessGeo.pointColorsBuffer, glUsage);
    
    tessGeo.updatePointOffsetsBuffer();
    if (bufPointAttrib == null)
      bufPointAttrib = new VertexBuffer(pg, PGL.ARRAY_BUFFER, 2, PGL.SIZEOF_FLOAT);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointAttrib.glId);
    pgl.bufferData(PGL.ARRAY_BUFFER, 2 * sizef, 
      tessGeo.pointOffsetsBuffer, glUsage);
    
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
    
    tessGeo.updatePointIndicesBuffer();
    if (bufPointIndex == null)
      bufPointIndex = new VertexBuffer(pg, PGL.ELEMENT_ARRAY_BUFFER, 1, PGL.SIZEOF_INDEX, true);
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, bufPointIndex.glId);
    pgl.bufferData(PGL.ELEMENT_ARRAY_BUFFER, 
      tessGeo.pointIndexCount * PGL.SIZEOF_INDEX, 
      tessGeo.pointIndicesBuffer, glUsage);
    
    pgl.bindBuffer(PGL.ELEMENT_ARRAY_BUFFER, 0);
  }
  
  protected boolean contextIsOutdated()
  {
    boolean outdated = !pgl.contextIsCurrent(context);
    if (outdated) {
      bufPolyVertex.dispose();
      bufPolyColor.dispose();
      bufPolyNormal.dispose();
      bufPolyTexcoord.dispose();
      bufPolyAmbient.dispose();
      bufPolySpecular.dispose();
      bufPolyEmissive.dispose();
      bufPolyShininess.dispose();
      for (PGraphicsOpenGL.VertexAttribute attrib : polyAttribs.values()) {
        buf.dispose();
      }
      bufPolyIndex.dispose();
      
      bufLineVertex.dispose();
      bufLineColor.dispose();
      bufLineAttrib.dispose();
      bufLineIndex.dispose();
      
      bufPointVertex.dispose();
      bufPointColor.dispose();
      bufPointAttrib.dispose();
      bufPointIndex.dispose();
    }
    return outdated;
  }
  







  protected void updateGeometry()
  {
    root.initBuffers();
    if (root.modified) {
      root.updateGeometryImpl();
    }
  }
  
  protected void updateGeometryImpl()
  {
    if (modifiedPolyVertices) {
      int offset = firstModifiedPolyVertex;
      int size = lastModifiedPolyVertex - offset + 1;
      copyPolyVertices(offset, size);
      modifiedPolyVertices = false;
      firstModifiedPolyVertex = Integer.MAX_VALUE;
      lastModifiedPolyVertex = Integer.MIN_VALUE;
    }
    if (modifiedPolyColors) {
      int offset = firstModifiedPolyColor;
      int size = lastModifiedPolyColor - offset + 1;
      copyPolyColors(offset, size);
      modifiedPolyColors = false;
      firstModifiedPolyColor = Integer.MAX_VALUE;
      lastModifiedPolyColor = Integer.MIN_VALUE;
    }
    if (modifiedPolyNormals) {
      int offset = firstModifiedPolyNormal;
      int size = lastModifiedPolyNormal - offset + 1;
      copyPolyNormals(offset, size);
      modifiedPolyNormals = false;
      firstModifiedPolyNormal = Integer.MAX_VALUE;
      lastModifiedPolyNormal = Integer.MIN_VALUE;
    }
    if (modifiedPolyTexCoords) {
      int offset = firstModifiedPolyTexcoord;
      int size = lastModifiedPolyTexcoord - offset + 1;
      copyPolyTexCoords(offset, size);
      modifiedPolyTexCoords = false;
      firstModifiedPolyTexcoord = Integer.MAX_VALUE;
      lastModifiedPolyTexcoord = Integer.MIN_VALUE;
    }
    if (modifiedPolyAmbient) {
      int offset = firstModifiedPolyAmbient;
      int size = lastModifiedPolyAmbient - offset + 1;
      copyPolyAmbient(offset, size);
      modifiedPolyAmbient = false;
      firstModifiedPolyAmbient = Integer.MAX_VALUE;
      lastModifiedPolyAmbient = Integer.MIN_VALUE;
    }
    if (modifiedPolySpecular) {
      int offset = firstModifiedPolySpecular;
      int size = lastModifiedPolySpecular - offset + 1;
      copyPolySpecular(offset, size);
      modifiedPolySpecular = false;
      firstModifiedPolySpecular = Integer.MAX_VALUE;
      lastModifiedPolySpecular = Integer.MIN_VALUE;
    }
    if (modifiedPolyEmissive) {
      int offset = firstModifiedPolyEmissive;
      int size = lastModifiedPolyEmissive - offset + 1;
      copyPolyEmissive(offset, size);
      modifiedPolyEmissive = false;
      firstModifiedPolyEmissive = Integer.MAX_VALUE;
      lastModifiedPolyEmissive = Integer.MIN_VALUE; }
    int size;
    if (modifiedPolyShininess) {
      int offset = firstModifiedPolyShininess;
      size = lastModifiedPolyShininess - offset + 1;
      copyPolyShininess(offset, size);
      modifiedPolyShininess = false;
      firstModifiedPolyShininess = Integer.MAX_VALUE;
      lastModifiedPolyShininess = Integer.MIN_VALUE;
    }
    for (String name : polyAttribs.keySet()) {
      PGraphicsOpenGL.VertexAttribute attrib = (PGraphicsOpenGL.VertexAttribute)polyAttribs.get(name);
      if (modified) {
        int offset = firstModifiedPolyVertex;
        int size = lastModifiedPolyVertex - offset + 1;
        copyPolyAttrib(attrib, offset, size);
        modified = false;
        firstModified = Integer.MAX_VALUE;
        lastModified = Integer.MIN_VALUE;
      }
    }
    
    if (modifiedLineVertices) {
      int offset = firstModifiedLineVertex;
      int size = lastModifiedLineVertex - offset + 1;
      copyLineVertices(offset, size);
      modifiedLineVertices = false;
      firstModifiedLineVertex = Integer.MAX_VALUE;
      lastModifiedLineVertex = Integer.MIN_VALUE;
    }
    if (modifiedLineColors) {
      int offset = firstModifiedLineColor;
      int size = lastModifiedLineColor - offset + 1;
      copyLineColors(offset, size);
      modifiedLineColors = false;
      firstModifiedLineColor = Integer.MAX_VALUE;
      lastModifiedLineColor = Integer.MIN_VALUE;
    }
    if (modifiedLineAttributes) {
      int offset = firstModifiedLineAttribute;
      int size = lastModifiedLineAttribute - offset + 1;
      copyLineAttributes(offset, size);
      modifiedLineAttributes = false;
      firstModifiedLineAttribute = Integer.MAX_VALUE;
      lastModifiedLineAttribute = Integer.MIN_VALUE;
    }
    
    if (modifiedPointVertices) {
      int offset = firstModifiedPointVertex;
      int size = lastModifiedPointVertex - offset + 1;
      copyPointVertices(offset, size);
      modifiedPointVertices = false;
      firstModifiedPointVertex = Integer.MAX_VALUE;
      lastModifiedPointVertex = Integer.MIN_VALUE;
    }
    if (modifiedPointColors) {
      int offset = firstModifiedPointColor;
      int size = lastModifiedPointColor - offset + 1;
      copyPointColors(offset, size);
      modifiedPointColors = false;
      firstModifiedPointColor = Integer.MAX_VALUE;
      lastModifiedPointColor = Integer.MIN_VALUE;
    }
    if (modifiedPointAttributes) {
      int offset = firstModifiedPointAttribute;
      int size = lastModifiedPointAttribute - offset + 1;
      copyPointAttributes(offset, size);
      modifiedPointAttributes = false;
      firstModifiedPointAttribute = Integer.MAX_VALUE;
      lastModifiedPointAttribute = Integer.MIN_VALUE;
    }
    
    modified = false;
  }
  
  protected void copyPolyVertices(int offset, int size)
  {
    tessGeo.updatePolyVerticesBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyVertex.glId);
    tessGeo.polyVerticesBuffer.position(4 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 4 * offset * PGL.SIZEOF_FLOAT, 
      4 * size * PGL.SIZEOF_FLOAT, tessGeo.polyVerticesBuffer);
    tessGeo.polyVerticesBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyColors(int offset, int size)
  {
    tessGeo.updatePolyColorsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyColor.glId);
    tessGeo.polyColorsBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.polyColorsBuffer);
    tessGeo.polyColorsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyNormals(int offset, int size)
  {
    tessGeo.updatePolyNormalsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyNormal.glId);
    tessGeo.polyNormalsBuffer.position(3 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 3 * offset * PGL.SIZEOF_FLOAT, 
      3 * size * PGL.SIZEOF_FLOAT, tessGeo.polyNormalsBuffer);
    tessGeo.polyNormalsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyTexCoords(int offset, int size)
  {
    tessGeo.updatePolyTexCoordsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyTexcoord.glId);
    tessGeo.polyTexCoordsBuffer.position(2 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 2 * offset * PGL.SIZEOF_FLOAT, 
      2 * size * PGL.SIZEOF_FLOAT, tessGeo.polyTexCoordsBuffer);
    tessGeo.polyTexCoordsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyAmbient(int offset, int size)
  {
    tessGeo.updatePolyAmbientBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyAmbient.glId);
    tessGeo.polyAmbientBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.polyAmbientBuffer);
    tessGeo.polyAmbientBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolySpecular(int offset, int size)
  {
    tessGeo.updatePolySpecularBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolySpecular.glId);
    tessGeo.polySpecularBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.polySpecularBuffer);
    tessGeo.polySpecularBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyEmissive(int offset, int size)
  {
    tessGeo.updatePolyEmissiveBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyEmissive.glId);
    tessGeo.polyEmissiveBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.polyEmissiveBuffer);
    tessGeo.polyEmissiveBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyShininess(int offset, int size)
  {
    tessGeo.updatePolyShininessBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPolyShininess.glId);
    tessGeo.polyShininessBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_FLOAT, 
      size * PGL.SIZEOF_FLOAT, tessGeo.polyShininessBuffer);
    tessGeo.polyShininessBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPolyAttrib(PGraphicsOpenGL.VertexAttribute attrib, int offset, int size)
  {
    tessGeo.updateAttribBuffer(name, offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, buf.glId);
    Buffer buf = (Buffer)tessGeo.polyAttribBuffers.get(name);
    buf.position(size * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, attrib.sizeInBytes(offset), 
      attrib.sizeInBytes(size), buf);
    buf.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyLineVertices(int offset, int size)
  {
    tessGeo.updateLineVerticesBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineVertex.glId);
    tessGeo.lineVerticesBuffer.position(4 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 4 * offset * PGL.SIZEOF_FLOAT, 
      4 * size * PGL.SIZEOF_FLOAT, tessGeo.lineVerticesBuffer);
    tessGeo.lineVerticesBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyLineColors(int offset, int size)
  {
    tessGeo.updateLineColorsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineColor.glId);
    tessGeo.lineColorsBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.lineColorsBuffer);
    tessGeo.lineColorsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyLineAttributes(int offset, int size)
  {
    tessGeo.updateLineDirectionsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufLineAttrib.glId);
    tessGeo.lineDirectionsBuffer.position(4 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 4 * offset * PGL.SIZEOF_FLOAT, 
      4 * size * PGL.SIZEOF_FLOAT, tessGeo.lineDirectionsBuffer);
    tessGeo.lineDirectionsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPointVertices(int offset, int size)
  {
    tessGeo.updatePointVerticesBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointVertex.glId);
    tessGeo.pointVerticesBuffer.position(4 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 4 * offset * PGL.SIZEOF_FLOAT, 
      4 * size * PGL.SIZEOF_FLOAT, tessGeo.pointVerticesBuffer);
    tessGeo.pointVerticesBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPointColors(int offset, int size)
  {
    tessGeo.updatePointColorsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointColor.glId);
    tessGeo.pointColorsBuffer.position(offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, offset * PGL.SIZEOF_INT, 
      size * PGL.SIZEOF_INT, tessGeo.pointColorsBuffer);
    tessGeo.pointColorsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void copyPointAttributes(int offset, int size)
  {
    tessGeo.updatePointOffsetsBuffer(offset, size);
    pgl.bindBuffer(PGL.ARRAY_BUFFER, bufPointAttrib.glId);
    tessGeo.pointOffsetsBuffer.position(2 * offset);
    pgl.bufferSubData(PGL.ARRAY_BUFFER, 2 * offset * PGL.SIZEOF_FLOAT, 
      2 * size * PGL.SIZEOF_FLOAT, tessGeo.pointOffsetsBuffer);
    tessGeo.pointOffsetsBuffer.rewind();
    pgl.bindBuffer(PGL.ARRAY_BUFFER, 0);
  }
  
  protected void setModifiedPolyVertices(int first, int last)
  {
    if (first < firstModifiedPolyVertex) firstModifiedPolyVertex = first;
    if (last > lastModifiedPolyVertex) lastModifiedPolyVertex = last;
    modifiedPolyVertices = true;
    modified = true;
  }
  
  protected void setModifiedPolyColors(int first, int last)
  {
    if (first < firstModifiedPolyColor) firstModifiedPolyColor = first;
    if (last > lastModifiedPolyColor) lastModifiedPolyColor = last;
    modifiedPolyColors = true;
    modified = true;
  }
  
  protected void setModifiedPolyNormals(int first, int last)
  {
    if (first < firstModifiedPolyNormal) firstModifiedPolyNormal = first;
    if (last > lastModifiedPolyNormal) lastModifiedPolyNormal = last;
    modifiedPolyNormals = true;
    modified = true;
  }
  
  protected void setModifiedPolyTexCoords(int first, int last)
  {
    if (first < firstModifiedPolyTexcoord) firstModifiedPolyTexcoord = first;
    if (last > lastModifiedPolyTexcoord) lastModifiedPolyTexcoord = last;
    modifiedPolyTexCoords = true;
    modified = true;
  }
  
  protected void setModifiedPolyAmbient(int first, int last)
  {
    if (first < firstModifiedPolyAmbient) firstModifiedPolyAmbient = first;
    if (last > lastModifiedPolyAmbient) lastModifiedPolyAmbient = last;
    modifiedPolyAmbient = true;
    modified = true;
  }
  
  protected void setModifiedPolySpecular(int first, int last)
  {
    if (first < firstModifiedPolySpecular) firstModifiedPolySpecular = first;
    if (last > lastModifiedPolySpecular) lastModifiedPolySpecular = last;
    modifiedPolySpecular = true;
    modified = true;
  }
  
  protected void setModifiedPolyEmissive(int first, int last)
  {
    if (first < firstModifiedPolyEmissive) firstModifiedPolyEmissive = first;
    if (last > lastModifiedPolyEmissive) lastModifiedPolyEmissive = last;
    modifiedPolyEmissive = true;
    modified = true;
  }
  
  protected void setModifiedPolyShininess(int first, int last)
  {
    if (first < firstModifiedPolyShininess) firstModifiedPolyShininess = first;
    if (last > lastModifiedPolyShininess) lastModifiedPolyShininess = last;
    modifiedPolyShininess = true;
    modified = true;
  }
  
  protected void setModifiedPolyAttrib(PGraphicsOpenGL.VertexAttribute attrib, int first, int last)
  {
    if (first < firstModified) firstModified = first;
    if (last > lastModified) lastModified = last;
    modified = true;
    modified = true;
  }
  
  protected void setModifiedLineVertices(int first, int last)
  {
    if (first < firstModifiedLineVertex) firstModifiedLineVertex = first;
    if (last > lastModifiedLineVertex) lastModifiedLineVertex = last;
    modifiedLineVertices = true;
    modified = true;
  }
  
  protected void setModifiedLineColors(int first, int last)
  {
    if (first < firstModifiedLineColor) firstModifiedLineColor = first;
    if (last > lastModifiedLineColor) lastModifiedLineColor = last;
    modifiedLineColors = true;
    modified = true;
  }
  
  protected void setModifiedLineAttributes(int first, int last)
  {
    if (first < firstModifiedLineAttribute) firstModifiedLineAttribute = first;
    if (last > lastModifiedLineAttribute) lastModifiedLineAttribute = last;
    modifiedLineAttributes = true;
    modified = true;
  }
  
  protected void setModifiedPointVertices(int first, int last)
  {
    if (first < firstModifiedPointVertex) firstModifiedPointVertex = first;
    if (last > lastModifiedPointVertex) lastModifiedPointVertex = last;
    modifiedPointVertices = true;
    modified = true;
  }
  
  protected void setModifiedPointColors(int first, int last)
  {
    if (first < firstModifiedPointColor) firstModifiedPointColor = first;
    if (last > lastModifiedPointColor) lastModifiedPointColor = last;
    modifiedPointColors = true;
    modified = true;
  }
  
  protected void setModifiedPointAttributes(int first, int last)
  {
    if (first < firstModifiedPointAttribute) firstModifiedPointAttribute = first;
    if (last > lastModifiedPointAttribute) lastModifiedPointAttribute = last;
    modifiedPointAttributes = true;
    modified = true;
  }
  








  public void disableStyle()
  {
    if (openShape) {
      PGraphics.showWarning("%1$s can only be called outside beginShape() and endShape()", new Object[] { "disableStyle()" });
      return;
    }
    

    savedStroke = stroke;
    savedStrokeColor = strokeColor;
    savedStrokeWeight = strokeWeight;
    savedStrokeCap = strokeCap;
    savedStrokeJoin = strokeJoin;
    savedFill = fill;
    savedFillColor = fillColor;
    savedTint = tint;
    savedTintColor = tintColor;
    savedAmbientColor = ambientColor;
    savedSpecularColor = specularColor;
    savedEmissiveColor = emissiveColor;
    savedShininess = shininess;
    savedTextureMode = textureMode;
    
    super.disableStyle();
  }
  

  public void enableStyle()
  {
    if (savedStroke) {
      setStroke(true);
      setStroke(savedStrokeColor);
      setStrokeWeight(savedStrokeWeight);
      setStrokeCap(savedStrokeCap);
      setStrokeJoin(savedStrokeJoin);
    } else {
      setStroke(false);
    }
    
    if (savedFill) {
      setFill(true);
      setFill(savedFillColor);
    } else {
      setFill(false);
    }
    
    if (savedTint) {
      setTint(true);
      setTint(savedTintColor);
    }
    
    setAmbient(savedAmbientColor);
    setSpecular(savedSpecularColor);
    setEmissive(savedEmissiveColor);
    setShininess(savedShininess);
    
    if (image != null) {
      setTextureMode(savedTextureMode);
    }
    
    super.enableStyle();
  }
  

  protected void styles(PGraphics g)
  {
    if ((g instanceof PGraphicsOpenGL)) {
      if (stroke) {
        setStroke(true);
        setStroke(strokeColor);
        setStrokeWeight(strokeWeight);
        setStrokeCap(strokeCap);
        setStrokeJoin(strokeJoin);
      } else {
        setStroke(false);
      }
      
      if (fill) {
        setFill(true);
        setFill(fillColor);
      } else {
        setFill(false);
      }
      
      if (tint) {
        setTint(true);
        setTint(tintColor);
      }
      
      setAmbient(ambientColor);
      setSpecular(specularColor);
      setEmissive(emissiveColor);
      setShininess(shininess);
      
      if (image != null) {
        setTextureMode(textureMode);
      }
    } else {
      super.styles(g);
    }
  }
  















  public void draw(PGraphics g)
  {
    if ((g instanceof PGraphicsOpenGL)) {
      PGraphicsOpenGL gl = (PGraphicsOpenGL)g;
      if (visible) {
        pre(gl);
        
        updateTessellation();
        updateGeometry();
        
        if (family == 0) {
          if (fragmentedGroup(gl)) {
            for (int i = 0; i < childCount; i++) {
              ((PShapeOpenGL)children[i]).draw(gl);
            }
          } else {
            PImage tex = null;
            if ((textures != null) && (textures.size() == 1)) {
              tex = (PImage)textures.toArray()[0];
            }
            render(gl, tex);
          }
        } else {
          render(gl, image);
        }
        post(gl);
      }
      
    }
    else
    {
      super.draw(g);
    }
  }
  






  protected boolean fragmentedGroup(PGraphicsOpenGL g)
  {
    return (g.getHint(6)) || 
      ((textures != null) && ((1 < textures.size()) || (untexChild))) || 
      (strokedTexture);
  }
  

  protected void pre(PGraphics g)
  {
    if ((g instanceof PGraphicsOpenGL)) {
      if (!style) {
        styles(g);
      }
    } else {
      super.pre(g);
    }
  }
  

  protected void post(PGraphics g)
  {
    if (!(g instanceof PGraphicsOpenGL))
    {
      super.post(g);
    }
  }
  

  protected void drawGeometry(PGraphics g)
  {
    vertexCount = inGeo.vertexCount;
    vertices = inGeo.getVertexData();
    
    super.drawGeometry(g);
    
    vertexCount = 0;
    vertices = null;
  }
  


  protected void render(PGraphicsOpenGL g, PImage texture)
  {
    if (root == null)
    {
      throw new RuntimeException("Error rendering PShapeOpenGL, root shape is null");
    }
    

    if (hasPolys) {
      renderPolys(g, texture);
      if (g.haveRaw()) {
        rawPolys(g, texture);
      }
    }
    
    if (is3D())
    {

      if (hasLines) {
        renderLines(g);
        if (g.haveRaw()) {
          rawLines(g);
        }
      }
      
      if (hasPoints) {
        renderPoints(g);
        if (g.haveRaw()) {
          rawPoints(g);
        }
      }
    }
  }
  
  protected void renderPolys(PGraphicsOpenGL g, PImage textureImage)
  {
    boolean customShader = polyShader != null;
    boolean needNormals = customShader ? polyShader.accessNormals() : false;
    boolean needTexCoords = customShader ? polyShader.accessTexCoords() : false;
    
    Texture tex = textureImage != null ? g.getTexture(textureImage) : null;
    
    boolean renderingFill = false;boolean renderingStroke = false;
    PShader shader = null;
    PGraphicsOpenGL.IndexCache cache = tessGeo.polyIndexCache;
    int ioffset; for (int n = firstPolyIndexCache; n <= lastPolyIndexCache; n++) {
      if ((is3D()) || ((tex != null) && ((firstLineIndexCache == -1) || 
        (n < firstLineIndexCache)) && (
        (firstPointIndexCache == -1) || 
        (n < firstPointIndexCache))))
      {
        if (!renderingFill) {
          shader = g.getPolyShader(lights, tex != null);
          shader.bind();
          renderingFill = true;
        }
        
      }
      else if (!renderingStroke) {
        if (tex != null) {
          tex.unbind();
          tex = null;
        }
        
        if ((shader != null) && (shader.bound())) {
          shader.unbind();
        }
        


        shader = g.getPolyShader(lights, false);
        shader.bind();
        
        renderingFill = false;
        renderingStroke = true;
      }
      

      ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      shader.setVertexAttribute(root.bufPolyVertex.glId, 4, PGL.FLOAT, 
        0, 4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(root.bufPolyColor.glId, 4, PGL.UNSIGNED_BYTE, 
        0, 4 * voffset * PGL.SIZEOF_BYTE);
      
      if (lights) {
        shader.setNormalAttribute(root.bufPolyNormal.glId, 3, PGL.FLOAT, 
          0, 3 * voffset * PGL.SIZEOF_FLOAT);
        shader.setAmbientAttribute(root.bufPolyAmbient.glId, 4, PGL.UNSIGNED_BYTE, 
          0, 4 * voffset * PGL.SIZEOF_BYTE);
        shader.setSpecularAttribute(root.bufPolySpecular.glId, 4, PGL.UNSIGNED_BYTE, 
          0, 4 * voffset * PGL.SIZEOF_BYTE);
        shader.setEmissiveAttribute(root.bufPolyEmissive.glId, 4, PGL.UNSIGNED_BYTE, 
          0, 4 * voffset * PGL.SIZEOF_BYTE);
        shader.setShininessAttribute(root.bufPolyShininess.glId, 1, PGL.FLOAT, 
          0, voffset * PGL.SIZEOF_FLOAT);
      }
      if ((lights) || (needNormals)) {
        shader.setNormalAttribute(root.bufPolyNormal.glId, 3, PGL.FLOAT, 
          0, 3 * voffset * PGL.SIZEOF_FLOAT);
      }
      
      if ((tex != null) || (needTexCoords)) {
        shader.setTexcoordAttribute(root.bufPolyTexcoord.glId, 2, PGL.FLOAT, 
          0, 2 * voffset * PGL.SIZEOF_FLOAT);
        shader.setTexture(tex);
      }
      
      for (PGraphicsOpenGL.VertexAttribute attrib : polyAttribs.values()) {
        if (attrib.active(shader)) {
          attrib.bind(pgl);
          shader.setAttributeVBO(glLoc, buf.glId, 
            tessSize, type, 
            attrib.isColor(), 0, attrib.sizeInBytes(voffset));
        }
      }
      shader.draw(root.bufPolyIndex.glId, icount, ioffset);
    }
    
    for (PGraphicsOpenGL.VertexAttribute attrib : polyAttribs.values()) {
      if (attrib.active(shader)) attrib.unbind(pgl);
    }
    if ((shader != null) && (shader.bound())) {
      shader.unbind();
    }
  }
  
  protected void rawPolys(PGraphicsOpenGL g, PImage textureImage)
  {
    PGraphics raw = g.getRaw();
    
    raw.colorMode(1);
    raw.noStroke();
    raw.beginShape(9);
    
    float[] vertices = tessGeo.polyVertices;
    int[] color = tessGeo.polyColors;
    float[] uv = tessGeo.polyTexCoords;
    short[] indices = tessGeo.polyIndices;
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.polyIndexCache;
    for (int n = firstPolyIndexCache; n <= lastPolyIndexCache; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      for (int tr = ioffset / 3; tr < (ioffset + icount) / 3; tr++) {
        int i0 = voffset + indices[(3 * tr + 0)];
        int i1 = voffset + indices[(3 * tr + 1)];
        int i2 = voffset + indices[(3 * tr + 2)];
        
        float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] src1 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] src2 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] pt1 = { 0.0F, 0.0F, 0.0F, 0.0F };
        float[] pt2 = { 0.0F, 0.0F, 0.0F, 0.0F };
        int argb0 = PGL.nativeToJavaARGB(color[i0]);
        int argb1 = PGL.nativeToJavaARGB(color[i1]);
        int argb2 = PGL.nativeToJavaARGB(color[i2]);
        
        PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i1, src1, 0, 4);
        PApplet.arrayCopy(vertices, 4 * i2, src2, 0, 4);
        

        modelview.mult(src0, pt0);
        modelview.mult(src1, pt1);
        modelview.mult(src2, pt2);
        
        if (textureImage != null) {
          raw.texture(textureImage);
          if (raw.is3D()) {
            raw.fill(argb0);
            raw.vertex(pt0[0], pt0[1], pt0[2], uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
            raw.fill(argb1);
            raw.vertex(pt1[0], pt1[1], pt1[2], uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
            raw.fill(argb2);
            raw.vertex(pt2[0], pt2[1], pt2[2], uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
          } else if (raw.is2D()) {
            float sx0 = g.screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sy0 = g.screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sx1 = g.screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sy1 = g.screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sx2 = g.screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
            float sy2 = g.screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
            raw.fill(argb0);
            raw.vertex(sx0, sy0, uv[(2 * i0 + 0)], uv[(2 * i0 + 1)]);
            raw.fill(argb1);
            raw.vertex(sx1, sy1, uv[(2 * i1 + 0)], uv[(2 * i1 + 1)]);
            raw.fill(argb1);
            raw.vertex(sx2, sy2, uv[(2 * i2 + 0)], uv[(2 * i2 + 1)]);
          }
        }
        else if (raw.is3D()) {
          raw.fill(argb0);
          raw.vertex(pt0[0], pt0[1], pt0[2]);
          raw.fill(argb1);
          raw.vertex(pt1[0], pt1[1], pt1[2]);
          raw.fill(argb2);
          raw.vertex(pt2[0], pt2[1], pt2[2]);
        } else if (raw.is2D()) {
          float sx0 = g.screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sy0 = g.screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sx1 = g.screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
          float sy1 = g.screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
          float sx2 = g.screenXImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
          float sy2 = g.screenYImpl(pt2[0], pt2[1], pt2[2], pt2[3]);
          raw.fill(argb0);
          raw.vertex(sx0, sy0);
          raw.fill(argb1);
          raw.vertex(sx1, sy1);
          raw.fill(argb2);
          raw.vertex(sx2, sy2);
        }
      }
    }
    

    raw.endShape();
  }
  
  protected void renderLines(PGraphicsOpenGL g)
  {
    PShader shader = g.getLineShader();
    shader.bind();
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.lineIndexCache;
    for (int n = firstLineIndexCache; n <= lastLineIndexCache; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      shader.setVertexAttribute(root.bufLineVertex.glId, 4, PGL.FLOAT, 
        0, 4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(root.bufLineColor.glId, 4, PGL.UNSIGNED_BYTE, 
        0, 4 * voffset * PGL.SIZEOF_BYTE);
      shader.setLineAttribute(root.bufLineAttrib.glId, 4, PGL.FLOAT, 
        0, 4 * voffset * PGL.SIZEOF_FLOAT);
      
      shader.draw(root.bufLineIndex.glId, icount, ioffset);
    }
    
    shader.unbind();
  }
  
  protected void rawLines(PGraphicsOpenGL g)
  {
    PGraphics raw = g.getRaw();
    
    raw.colorMode(1);
    raw.noFill();
    raw.strokeCap(strokeCap);
    raw.strokeJoin(strokeJoin);
    raw.beginShape(5);
    
    float[] vertices = tessGeo.lineVertices;
    int[] color = tessGeo.lineColors;
    float[] attribs = tessGeo.lineDirections;
    short[] indices = tessGeo.lineIndices;
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.lineIndexCache;
    for (int n = firstLineIndexCache; n <= lastLineIndexCache; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      for (int ln = ioffset / 6; ln < (ioffset + icount) / 6; ln++)
      {




        int i0 = voffset + indices[(6 * ln + 0)];
        int i1 = voffset + indices[(6 * ln + 5)];
        float sw0 = 2.0F * attribs[(4 * i0 + 3)];
        float sw1 = 2.0F * attribs[(4 * i1 + 3)];
        
        if (!PGraphicsOpenGL.zero(sw0))
        {
          float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] src1 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
          float[] pt1 = { 0.0F, 0.0F, 0.0F, 0.0F };
          int argb0 = PGL.nativeToJavaARGB(color[i0]);
          int argb1 = PGL.nativeToJavaARGB(color[i1]);
          
          PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
          PApplet.arrayCopy(vertices, 4 * i1, src1, 0, 4);
          

          modelview.mult(src0, pt0);
          modelview.mult(src1, pt1);
          
          if (raw.is3D()) {
            raw.strokeWeight(sw0);
            raw.stroke(argb0);
            raw.vertex(pt0[0], pt0[1], pt0[2]);
            raw.strokeWeight(sw1);
            raw.stroke(argb1);
            raw.vertex(pt1[0], pt1[1], pt1[2]);
          } else if (raw.is2D()) {
            float sx0 = g.screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sy0 = g.screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
            float sx1 = g.screenXImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            float sy1 = g.screenYImpl(pt1[0], pt1[1], pt1[2], pt1[3]);
            raw.strokeWeight(sw0);
            raw.stroke(argb0);
            raw.vertex(sx0, sy0);
            raw.strokeWeight(sw1);
            raw.stroke(argb1);
            raw.vertex(sx1, sy1);
          }
        }
      }
    }
    raw.endShape();
  }
  
  protected void renderPoints(PGraphicsOpenGL g)
  {
    PShader shader = g.getPointShader();
    shader.bind();
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.pointIndexCache;
    for (int n = firstPointIndexCache; n <= lastPointIndexCache; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      shader.setVertexAttribute(root.bufPointVertex.glId, 4, PGL.FLOAT, 
        0, 4 * voffset * PGL.SIZEOF_FLOAT);
      shader.setColorAttribute(root.bufPointColor.glId, 4, PGL.UNSIGNED_BYTE, 
        0, 4 * voffset * PGL.SIZEOF_BYTE);
      shader.setPointAttribute(root.bufPointAttrib.glId, 2, PGL.FLOAT, 
        0, 2 * voffset * PGL.SIZEOF_FLOAT);
      
      shader.draw(root.bufPointIndex.glId, icount, ioffset);
    }
    
    shader.unbind();
  }
  
  protected void rawPoints(PGraphicsOpenGL g)
  {
    PGraphics raw = g.getRaw();
    
    raw.colorMode(1);
    raw.noFill();
    raw.strokeCap(strokeCap);
    raw.beginShape(3);
    
    float[] vertices = tessGeo.pointVertices;
    int[] color = tessGeo.pointColors;
    float[] attribs = tessGeo.pointOffsets;
    short[] indices = tessGeo.pointIndices;
    
    PGraphicsOpenGL.IndexCache cache = tessGeo.pointIndexCache;
    for (int n = 0; n < size; n++) {
      int ioffset = indexOffset[n];
      int icount = indexCount[n];
      int voffset = vertexOffset[n];
      
      int pt = ioffset;
      while (pt < (ioffset + icount) / 3) {
        float size = attribs[(2 * pt + 2)];
        int perim;
        float weight;
        int perim; if (0.0F < size) {
          float weight = size / 0.5F;
          perim = PApplet.min(200, 
            PApplet.max(20, 
            (int)(6.2831855F * weight / 
            10.0F))) + 1;
        } else {
          weight = -size / 0.5F;
          perim = 5;
        }
        
        int i0 = voffset + indices[(3 * pt)];
        int argb0 = PGL.nativeToJavaARGB(color[i0]);
        float[] pt0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        
        float[] src0 = { 0.0F, 0.0F, 0.0F, 0.0F };
        PApplet.arrayCopy(vertices, 4 * i0, src0, 0, 4);
        modelview.mult(src0, pt0);
        
        if (raw.is3D()) {
          raw.strokeWeight(weight);
          raw.stroke(argb0);
          raw.vertex(pt0[0], pt0[1], pt0[2]);
        } else if (raw.is2D()) {
          float sx0 = g.screenXImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          float sy0 = g.screenYImpl(pt0[0], pt0[1], pt0[2], pt0[3]);
          raw.strokeWeight(weight);
          raw.stroke(argb0);
          raw.vertex(sx0, sy0);
        }
        
        pt += perim;
      }
    }
    
    raw.endShape();
  }
}
