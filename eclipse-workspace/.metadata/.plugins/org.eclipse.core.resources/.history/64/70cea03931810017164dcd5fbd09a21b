package processing.opengl;

import com.jogamp.common.util.VersionNumber;
import com.jogamp.newt.opengl.GLWindow;
import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2;
import com.jogamp.opengl.GL2ES2;
import com.jogamp.opengl.GL2GL3;
import com.jogamp.opengl.GL3ES3;
import com.jogamp.opengl.GLAutoDrawable;
import com.jogamp.opengl.GLCapabilities;
import com.jogamp.opengl.GLCapabilitiesImmutable;
import com.jogamp.opengl.GLContext;
import com.jogamp.opengl.GLDrawable;
import com.jogamp.opengl.GLException;
import com.jogamp.opengl.glu.GLU;
import com.jogamp.opengl.glu.GLUtessellator;
import com.jogamp.opengl.glu.GLUtessellatorCallbackAdapter;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.PathIterator;
import java.io.IOException;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PMatrix3D;
import processing.core.PSurface;



























public class PJOGL
  extends PGL
{
  public static int profile = 2;
  

  protected static String[] icons = null;
  



  public static final int AWT = 0;
  



  public static final int NEWT = 1;
  


  public GL gl;
  


  public GLU glu;
  


  public GLContext context;
  


  protected static int DRAW_TIMEOUT_MILLIS = 500;
  



  protected GLCapabilitiesImmutable capabilities;
  



  protected GLDrawable drawable;
  



  protected GL2ES2 gl2;
  



  protected GL2GL3 gl3;
  



  protected GL2 gl2x;
  



  protected GL3ES3 gl3es3;
  



  protected Exception drawException;
  



  protected float[] projMatrix;
  



  protected float[] mvMatrix;
  



  public PJOGL(PGraphicsOpenGL pg)
  {
    super(pg);
    glu = new GLU();
  }
  

  public Object getNative()
  {
    return sketch.getSurface().getNative();
  }
  
















  public static void setIcon(String... icons)
  {
    icons = new String[icons.length];
    PApplet.arrayCopy(icons, icons);
  }
  





  public void setCaps(GLCapabilities caps)
  {
    reqNumSamples = caps.getNumSamples();
    capabilities = caps;
  }
  
  public GLCapabilitiesImmutable getCaps()
  {
    return capabilities;
  }
  
  public void setFps(float fps)
  {
    if ((!setFps) || (targetFps != fps)) {
      if (60.0F < fps)
      {
        gl.setSwapInterval(0);
      } else if (30.0F < fps) {
        gl.setSwapInterval(1);
      } else {
        gl.setSwapInterval(2);
      }
      targetFps = (this.currentFps = fps);
      setFps = true;
    }
  }
  

  protected int getDepthBits()
  {
    return capabilities.getDepthBits();
  }
  

  protected int getStencilBits()
  {
    return capabilities.getStencilBits();
  }
  

  protected float getPixelScale()
  {
    PSurface surf = sketch.getSurface();
    if (surf == null)
      return graphics.pixelDensity;
    if ((surf instanceof PSurfaceJOGL)) {
      return ((PSurfaceJOGL)surf).getPixelScale();
    }
    throw new RuntimeException("Renderer cannot find a JOGL surface");
  }
  


  protected void getGL(PGL pgl)
  {
    PJOGL pjogl = (PJOGL)pgl;
    
    drawable = drawable;
    context = context;
    glContext = glContext;
    setThread(glThread);
    
    gl = gl;
    gl2 = gl2;
    gl2x = gl2x;
    gl3 = gl3;
    gl3es3 = gl3es3;
  }
  
  public void getGL(GLAutoDrawable glDrawable)
  {
    context = glDrawable.getContext();
    glContext = context.hashCode();
    setThread(Thread.currentThread());
    
    gl = context.getGL();
    gl2 = gl.getGL2ES2();
    try {
      gl2x = gl.getGL2();
    } catch (GLException localGLException1) {
      gl2x = null;
    }
    try {
      gl3 = gl.getGL2GL3();
    } catch (GLException localGLException2) {
      gl3 = null;
    }
    try {
      gl3es3 = gl.getGL3ES3();
    } catch (GLException localGLException3) {
      gl3es3 = null;
    }
  }
  
  protected boolean canDraw()
  {
    return true;
  }
  








  protected void swapBuffers()
  {
    PSurfaceJOGL surf = (PSurfaceJOGL)sketch.getSurface();
    window.swapBuffers();
  }
  

  protected void initFBOLayer()
  {
    if (sketch.frameCount > 0) {
      if (isES()) initFBOLayerES(); else {
        initFBOLayerGL();
      }
    }
  }
  
  private void initFBOLayerES() {
    IntBuffer buf = allocateDirectIntBuffer(fboWidth * fboHeight);
    
    if (hasReadBuffer()) readBuffer(BACK);
    readPixelsImpl(0, 0, fboWidth, fboHeight, RGBA, UNSIGNED_BYTE, buf);
    bindTexture(TEXTURE_2D, glColorTex.get(frontTex));
    texSubImage2D(TEXTURE_2D, 0, 0, 0, fboWidth, fboHeight, RGBA, UNSIGNED_BYTE, buf);
    
    bindTexture(TEXTURE_2D, glColorTex.get(backTex));
    texSubImage2D(TEXTURE_2D, 0, 0, 0, fboWidth, fboHeight, RGBA, UNSIGNED_BYTE, buf);
    
    bindTexture(TEXTURE_2D, 0);
    bindFramebufferImpl(FRAMEBUFFER, 0);
  }
  





  private void initFBOLayerGL()
  {
    if ((pclearColor) || (pgeomCount > 0) || (!sketch.isLooping())) {
      if (hasReadBuffer()) { readBuffer(FRONT);
      }
      

    }
    else {
      readBuffer(BACK);
    }
    bindFramebufferImpl(DRAW_FRAMEBUFFER, glColorFbo.get(0));
    framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0, 
      TEXTURE_2D, glColorTex.get(frontTex), 0);
    if (hasDrawBuffer()) drawBuffer(COLOR_ATTACHMENT0);
    blitFramebuffer(0, 0, fboWidth, fboHeight, 
      0, 0, fboWidth, fboHeight, 
      COLOR_BUFFER_BIT, NEAREST);
    
    readBuffer(BACK);
    bindFramebufferImpl(DRAW_FRAMEBUFFER, glColorFbo.get(0));
    framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0, 
      TEXTURE_2D, glColorTex.get(backTex), 0);
    drawBuffer(COLOR_ATTACHMENT0);
    blitFramebuffer(0, 0, fboWidth, fboHeight, 
      0, 0, fboWidth, fboHeight, 
      COLOR_BUFFER_BIT, NEAREST);
    
    bindFramebufferImpl(FRAMEBUFFER, 0);
  }
  

  protected void beginGL()
  {
    PMatrix3D proj = graphics.projection;
    PMatrix3D mdl = graphics.modelview;
    if (gl2x != null) {
      if (projMatrix == null) {
        projMatrix = new float[16];
      }
      gl2x.glMatrixMode(5889);
      projMatrix[0] = m00;
      projMatrix[1] = m10;
      projMatrix[2] = m20;
      projMatrix[3] = m30;
      projMatrix[4] = m01;
      projMatrix[5] = m11;
      projMatrix[6] = m21;
      projMatrix[7] = m31;
      projMatrix[8] = m02;
      projMatrix[9] = m12;
      projMatrix[10] = m22;
      projMatrix[11] = m32;
      projMatrix[12] = m03;
      projMatrix[13] = m13;
      projMatrix[14] = m23;
      projMatrix[15] = m33;
      gl2x.glLoadMatrixf(projMatrix, 0);
      
      if (mvMatrix == null) {
        mvMatrix = new float[16];
      }
      gl2x.glMatrixMode(5888);
      mvMatrix[0] = m00;
      mvMatrix[1] = m10;
      mvMatrix[2] = m20;
      mvMatrix[3] = m30;
      mvMatrix[4] = m01;
      mvMatrix[5] = m11;
      mvMatrix[6] = m21;
      mvMatrix[7] = m31;
      mvMatrix[8] = m02;
      mvMatrix[9] = m12;
      mvMatrix[10] = m22;
      mvMatrix[11] = m32;
      mvMatrix[12] = m03;
      mvMatrix[13] = m13;
      mvMatrix[14] = m23;
      mvMatrix[15] = m33;
      gl2x.glLoadMatrixf(mvMatrix, 0);
    }
  }
  

  protected boolean hasFBOs()
  {
    if (context.hasBasicFBOSupport()) return true;
    return super.hasFBOs();
  }
  

  protected boolean hasShaders()
  {
    if (context.hasGLSL()) return true;
    return super.hasShaders();
  }
  
  public void init(GLAutoDrawable glDrawable)
  {
    capabilities = glDrawable.getChosenGLCapabilities();
    if (!hasFBOs()) {
      throw new RuntimeException("Framebuffer objects are not supported by this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.");
    }
    if (!hasShaders()) {
      throw new RuntimeException("GLSL shaders are not supported by this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.");
    }
  }
  






  protected void enableTexturing(int target)
  {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = true;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = true;
    }
  }
  

  protected void disableTexturing(int target)
  {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = false;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = false;
    }
  }
  






  private FontMetrics getFontMetrics(Font font)
  {
    return Toolkit.getDefaultToolkit().getFontMetrics(font);
  }
  



  private FontRenderContext getFontRenderContext(Font font)
  {
    return getFontMetrics(font).getFontRenderContext();
  }
  

  protected int getFontAscent(Object font)
  {
    return getFontMetrics((Font)font).getAscent();
  }
  

  protected int getFontDescent(Object font)
  {
    return getFontMetrics((Font)font).getDescent();
  }
  


  protected int getTextWidth(Object font, char[] buffer, int start, int stop)
  {
    int length = stop - start;
    FontMetrics metrics = getFontMetrics((Font)font);
    return metrics.charsWidth(buffer, start, length);
  }
  

  protected Object getDerivedFont(Object font, float size)
  {
    return ((Font)font).deriveFont(size);
  }
  
  protected int getGLSLVersion()
  {
    VersionNumber vn = context.getGLSLVersionNumber();
    return vn.getMajor() * 100 + vn.getMinor();
  }
  

  protected String[] loadVertexShader(String filename)
  {
    return loadVertexShader(filename, getGLSLVersion());
  }
  

  protected String[] loadFragmentShader(String filename)
  {
    return loadFragmentShader(filename, getGLSLVersion());
  }
  

  protected String[] loadVertexShader(URL url)
  {
    return loadVertexShader(url, getGLSLVersion());
  }
  

  protected String[] loadFragmentShader(URL url)
  {
    return loadFragmentShader(url, getGLSLVersion());
  }
  

  protected String[] loadFragmentShader(String filename, int version)
  {
    String[] fragSrc0 = sketch.loadStrings(filename);
    return preprocessFragmentSource(fragSrc0, version);
  }
  

  protected String[] loadVertexShader(String filename, int version)
  {
    String[] vertSrc0 = sketch.loadStrings(filename);
    return preprocessVertexSource(vertSrc0, version);
  }
  
  protected String[] loadFragmentShader(URL url, int version)
  {
    try
    {
      String[] fragSrc0 = PApplet.loadStrings(url.openStream());
      return preprocessFragmentSource(fragSrc0, version);
    } catch (IOException localIOException) {
      PGraphics.showException("Cannot load fragment shader " + url.getFile());
    }
    return null;
  }
  
  protected String[] loadVertexShader(URL url, int version)
  {
    try
    {
      String[] vertSrc0 = PApplet.loadStrings(url.openStream());
      return preprocessVertexSource(vertSrc0, version);
    } catch (IOException localIOException) {
      PGraphics.showException("Cannot load vertex shader " + url.getFile());
    }
    return null;
  }
  






  protected Tessellator createTessellator(PGL.TessellatorCallback callback)
  {
    return new Tessellator(callback);
  }
  
  protected static class Tessellator implements PGL.Tessellator
  {
    protected GLUtessellator tess;
    protected PGL.TessellatorCallback callback;
    protected GLUCallback gluCallback;
    
    public Tessellator(PGL.TessellatorCallback callback) {
      this.callback = callback;
      tess = GLU.gluNewTess();
      gluCallback = new GLUCallback();
      
      GLU.gluTessCallback(tess, 100100, gluCallback);
      GLU.gluTessCallback(tess, 100102, gluCallback);
      GLU.gluTessCallback(tess, 100101, gluCallback);
      GLU.gluTessCallback(tess, 100105, gluCallback);
      GLU.gluTessCallback(tess, 100103, gluCallback);
    }
    
    public void beginPolygon()
    {
      GLU.gluTessBeginPolygon(tess, null);
    }
    
    public void endPolygon()
    {
      GLU.gluTessEndPolygon(tess);
    }
    
    public void setWindingRule(int rule)
    {
      GLU.gluTessProperty(tess, 100140, rule);
    }
    
    public void beginContour()
    {
      GLU.gluTessBeginContour(tess);
    }
    
    public void endContour()
    {
      GLU.gluTessEndContour(tess);
    }
    
    public void addVertex(double[] v)
    {
      GLU.gluTessVertex(tess, v, 0, v);
    }
    
    protected class GLUCallback extends GLUtessellatorCallbackAdapter {
      protected GLUCallback() {}
      
      public void begin(int type) { callback.begin(type); }
      

      public void end()
      {
        callback.end();
      }
      
      public void vertex(Object data)
      {
        callback.vertex(data);
      }
      

      public void combine(double[] coords, Object[] data, float[] weight, Object[] outData)
      {
        callback.combine(coords, data, weight, outData);
      }
      
      public void error(int errnum)
      {
        callback.error(errnum);
      }
    }
  }
  

  protected String tessError(int err)
  {
    return glu.gluErrorString(err);
  }
  
















  protected FontOutline createFontOutline(char ch, Object font)
  {
    return new FontOutline(ch, (Font)font);
  }
  
  protected class FontOutline implements PGL.FontOutline
  {
    PathIterator iter;
    
    public FontOutline(char ch, Font font) {
      char[] textArray = { ch };
      FontRenderContext frc = PJOGL.this.getFontRenderContext(font);
      GlyphVector gv = font.createGlyphVector(frc, textArray);
      Shape shp = gv.getOutline();
      iter = shp.getPathIterator(null);
    }
    
    public boolean isDone() {
      return iter.isDone();
    }
    
    public int currentSegment(float[] coords) {
      return iter.currentSegment(coords);
    }
    
    public void next() {
      iter.next();
    }
  }
  
  static
  {
    MIN_DIRECT_BUFFER_SIZE = 2;
    INDEX_TYPE = 5123;
    
























































































































































































































































































































































































































































































































































    SHAPE_TEXT_SUPPORTED = true;
    SEG_MOVETO = 0;
    SEG_LINETO = 1;
    SEG_QUADTO = 2;
    SEG_CUBICTO = 3;
    SEG_CLOSE = 4;
    






































    FALSE = 0;
    TRUE = 1;
    
    INT = 5124;
    BYTE = 5120;
    SHORT = 5122;
    FLOAT = 5126;
    BOOL = 35670;
    UNSIGNED_INT = 5125;
    UNSIGNED_BYTE = 5121;
    UNSIGNED_SHORT = 5123;
    
    RGB = 6407;
    RGBA = 6408;
    ALPHA = 6406;
    LUMINANCE = 6409;
    LUMINANCE_ALPHA = 6410;
    
    UNSIGNED_SHORT_5_6_5 = 33635;
    UNSIGNED_SHORT_4_4_4_4 = 32819;
    UNSIGNED_SHORT_5_5_5_1 = 32820;
    
    RGBA4 = 32854;
    RGB5_A1 = 32855;
    RGB565 = 36194;
    RGB8 = 32849;
    RGBA8 = 32856;
    ALPHA8 = 32828;
    
    READ_ONLY = 35000;
    WRITE_ONLY = 35001;
    READ_WRITE = 35002;
    
    TESS_WINDING_NONZERO = 100131;
    TESS_WINDING_ODD = 100130;
    
    GENERATE_MIPMAP_HINT = 33170;
    FASTEST = 4353;
    NICEST = 4354;
    DONT_CARE = 4352;
    
    VENDOR = 7936;
    RENDERER = 7937;
    VERSION = 7938;
    EXTENSIONS = 7939;
    SHADING_LANGUAGE_VERSION = 35724;
    
    MAX_SAMPLES = 36183;
    SAMPLES = 32937;
    
    ALIASED_LINE_WIDTH_RANGE = 33902;
    ALIASED_POINT_SIZE_RANGE = 33901;
    
    DEPTH_BITS = 3414;
    STENCIL_BITS = 3415;
    
    CCW = 2305;
    CW = 2304;
    
    VIEWPORT = 2978;
    
    ARRAY_BUFFER = 34962;
    ELEMENT_ARRAY_BUFFER = 34963;
    PIXEL_PACK_BUFFER = 35051;
    
    MAX_VERTEX_ATTRIBS = 34921;
    
    STATIC_DRAW = 35044;
    DYNAMIC_DRAW = 35048;
    STREAM_DRAW = 35040;
    STREAM_READ = 35041;
    
    BUFFER_SIZE = 34660;
    BUFFER_USAGE = 34661;
    
    POINTS = 0;
    LINE_STRIP = 3;
    LINE_LOOP = 2;
    LINES = 1;
    TRIANGLE_FAN = 6;
    TRIANGLE_STRIP = 5;
    TRIANGLES = 4;
    
    CULL_FACE = 2884;
    FRONT = 1028;
    BACK = 1029;
    FRONT_AND_BACK = 1032;
    
    POLYGON_OFFSET_FILL = 32823;
    
    UNPACK_ALIGNMENT = 3317;
    PACK_ALIGNMENT = 3333;
    
    TEXTURE_2D = 3553;
    TEXTURE_RECTANGLE = 34037;
    
    TEXTURE_BINDING_2D = 32873;
    TEXTURE_BINDING_RECTANGLE = 34038;
    
    MAX_TEXTURE_SIZE = 3379;
    TEXTURE_MAX_ANISOTROPY = 34046;
    MAX_TEXTURE_MAX_ANISOTROPY = 34047;
    
    MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
    MAX_TEXTURE_IMAGE_UNITS = 34930;
    MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
    
    NUM_COMPRESSED_TEXTURE_FORMATS = 34466;
    COMPRESSED_TEXTURE_FORMATS = 34467;
    
    NEAREST = 9728;
    LINEAR = 9729;
    LINEAR_MIPMAP_NEAREST = 9985;
    LINEAR_MIPMAP_LINEAR = 9987;
    
    CLAMP_TO_EDGE = 33071;
    REPEAT = 10497;
    
    TEXTURE0 = 33984;
    TEXTURE1 = 33985;
    TEXTURE2 = 33986;
    TEXTURE3 = 33987;
    TEXTURE_MIN_FILTER = 10241;
    TEXTURE_MAG_FILTER = 10240;
    TEXTURE_WRAP_S = 10242;
    TEXTURE_WRAP_T = 10243;
    TEXTURE_WRAP_R = 32882;
    
    TEXTURE_CUBE_MAP = 34067;
    TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
    
    VERTEX_SHADER = 35633;
    FRAGMENT_SHADER = 35632;
    INFO_LOG_LENGTH = 35716;
    SHADER_SOURCE_LENGTH = 35720;
    COMPILE_STATUS = 35713;
    LINK_STATUS = 35714;
    VALIDATE_STATUS = 35715;
    SHADER_TYPE = 35663;
    DELETE_STATUS = 35712;
    
    FLOAT_VEC2 = 35664;
    FLOAT_VEC3 = 35665;
    FLOAT_VEC4 = 35666;
    FLOAT_MAT2 = 35674;
    FLOAT_MAT3 = 35675;
    FLOAT_MAT4 = 35676;
    INT_VEC2 = 35667;
    INT_VEC3 = 35668;
    INT_VEC4 = 35669;
    BOOL_VEC2 = 35671;
    BOOL_VEC3 = 35672;
    BOOL_VEC4 = 35673;
    SAMPLER_2D = 35678;
    SAMPLER_CUBE = 35680;
    
    LOW_FLOAT = 36336;
    MEDIUM_FLOAT = 36337;
    HIGH_FLOAT = 36338;
    LOW_INT = 36339;
    MEDIUM_INT = 36340;
    HIGH_INT = 36341;
    
    CURRENT_VERTEX_ATTRIB = 34342;
    
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
    VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
    VERTEX_ATTRIB_ARRAY_SIZE = 34339;
    VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
    VERTEX_ATTRIB_ARRAY_TYPE = 34341;
    VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
    VERTEX_ATTRIB_ARRAY_POINTER = 34373;
    
    BLEND = 3042;
    ONE = 1;
    ZERO = 0;
    SRC_ALPHA = 770;
    DST_ALPHA = 772;
    ONE_MINUS_SRC_ALPHA = 771;
    ONE_MINUS_DST_COLOR = 775;
    ONE_MINUS_SRC_COLOR = 769;
    DST_COLOR = 774;
    SRC_COLOR = 768;
    
    SAMPLE_ALPHA_TO_COVERAGE = 32926;
    SAMPLE_COVERAGE = 32928;
    
    KEEP = 7680;
    REPLACE = 7681;
    INCR = 7682;
    DECR = 7683;
    INVERT = 5386;
    INCR_WRAP = 34055;
    DECR_WRAP = 34056;
    NEVER = 512;
    ALWAYS = 519;
    
    EQUAL = 514;
    LESS = 513;
    LEQUAL = 515;
    GREATER = 516;
    GEQUAL = 518;
    NOTEQUAL = 517;
    
    FUNC_ADD = 32774;
    FUNC_MIN = 32775;
    FUNC_MAX = 32776;
    FUNC_REVERSE_SUBTRACT = 32779;
    FUNC_SUBTRACT = 32778;
    
    DITHER = 3024;
    
    CONSTANT_COLOR = 32769;
    CONSTANT_ALPHA = 32771;
    ONE_MINUS_CONSTANT_COLOR = 32770;
    ONE_MINUS_CONSTANT_ALPHA = 32772;
    SRC_ALPHA_SATURATE = 776;
    
    SCISSOR_TEST = 3089;
    STENCIL_TEST = 2960;
    DEPTH_TEST = 2929;
    DEPTH_WRITEMASK = 2930;
    
    COLOR_BUFFER_BIT = 16384;
    DEPTH_BUFFER_BIT = 256;
    STENCIL_BUFFER_BIT = 1024;
    
    FRAMEBUFFER = 36160;
    COLOR_ATTACHMENT0 = 36064;
    COLOR_ATTACHMENT1 = 36065;
    COLOR_ATTACHMENT2 = 36066;
    COLOR_ATTACHMENT3 = 36067;
    RENDERBUFFER = 36161;
    DEPTH_ATTACHMENT = 36096;
    STENCIL_ATTACHMENT = 36128;
    READ_FRAMEBUFFER = 36008;
    DRAW_FRAMEBUFFER = 36009;
    
    RGBA8 = 32856;
    DEPTH24_STENCIL8 = 35056;
    
    DEPTH_COMPONENT = 6402;
    DEPTH_COMPONENT16 = 33189;
    DEPTH_COMPONENT24 = 33190;
    DEPTH_COMPONENT32 = 33191;
    
    STENCIL_INDEX = 6401;
    STENCIL_INDEX1 = 36166;
    STENCIL_INDEX4 = 36167;
    STENCIL_INDEX8 = 36168;
    
    DEPTH_STENCIL = 34041;
    
    FRAMEBUFFER_COMPLETE = 36053;
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
    FRAMEBUFFER_INCOMPLETE_FORMATS = 36058;
    FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 36059;
    FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 36060;
    FRAMEBUFFER_UNSUPPORTED = 36061;
    
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
    
    RENDERBUFFER_WIDTH = 36162;
    RENDERBUFFER_HEIGHT = 36163;
    RENDERBUFFER_RED_SIZE = 36176;
    RENDERBUFFER_GREEN_SIZE = 36177;
    RENDERBUFFER_BLUE_SIZE = 36178;
    RENDERBUFFER_ALPHA_SIZE = 36179;
    RENDERBUFFER_DEPTH_SIZE = 36180;
    RENDERBUFFER_STENCIL_SIZE = 36181;
    RENDERBUFFER_INTERNAL_FORMAT = 36164;
    
    MULTISAMPLE = 32925;
    LINE_SMOOTH = 2848;
    POLYGON_SMOOTH = 2881;
    
    SYNC_GPU_COMMANDS_COMPLETE = 37143;
    ALREADY_SIGNALED = 37146;
    CONDITION_SATISFIED = 37148;
  }
  




  public void flush()
  {
    gl.glFlush();
  }
  
  public void finish()
  {
    gl.glFinish();
  }
  
  public void hint(int target, int hint)
  {
    gl.glHint(target, hint);
  }
  




  public void enable(int value)
  {
    if (-1 < value) {
      gl.glEnable(value);
    }
  }
  
  public void disable(int value)
  {
    if (-1 < value) {
      gl.glDisable(value);
    }
  }
  
  public void getBooleanv(int value, IntBuffer data)
  {
    if (-1 < value) {
      if (byteBuffer.capacity() < data.capacity()) {
        byteBuffer = allocateDirectByteBuffer(data.capacity());
      }
      gl.glGetBooleanv(value, byteBuffer);
      for (int i = 0; i < data.capacity(); i++) {
        data.put(i, byteBuffer.get(i));
      }
    } else {
      fillIntBuffer(data, 0, data.capacity() - 1, 0);
    }
  }
  
  public void getIntegerv(int value, IntBuffer data)
  {
    if (-1 < value) {
      gl.glGetIntegerv(value, data);
    } else {
      fillIntBuffer(data, 0, data.capacity() - 1, 0);
    }
  }
  
  public void getFloatv(int value, FloatBuffer data)
  {
    if (-1 < value) {
      gl.glGetFloatv(value, data);
    } else {
      fillFloatBuffer(data, 0, data.capacity() - 1, 0.0F);
    }
  }
  
  public boolean isEnabled(int value)
  {
    return gl.glIsEnabled(value);
  }
  
  public String getString(int name)
  {
    return gl.glGetString(name);
  }
  




  public int getError()
  {
    return gl.glGetError();
  }
  
  public String errorString(int err)
  {
    return glu.gluErrorString(err);
  }
  




  public void genBuffers(int n, IntBuffer buffers)
  {
    gl.glGenBuffers(n, buffers);
  }
  
  public void deleteBuffers(int n, IntBuffer buffers)
  {
    gl.glDeleteBuffers(n, buffers);
  }
  
  public void bindBuffer(int target, int buffer)
  {
    gl.glBindBuffer(target, buffer);
  }
  
  public void bufferData(int target, int size, Buffer data, int usage)
  {
    gl.glBufferData(target, size, data, usage);
  }
  
  public void bufferSubData(int target, int offset, int size, Buffer data)
  {
    gl.glBufferSubData(target, offset, size, data);
  }
  
  public void isBuffer(int buffer)
  {
    gl.glIsBuffer(buffer);
  }
  
  public void getBufferParameteriv(int target, int value, IntBuffer data)
  {
    gl.glGetBufferParameteriv(target, value, data);
  }
  
  public ByteBuffer mapBuffer(int target, int access)
  {
    return gl2.glMapBuffer(target, access);
  }
  
  public ByteBuffer mapBufferRange(int target, int offset, int length, int access)
  {
    if (gl2x != null)
      return gl2x.glMapBufferRange(target, offset, length, access);
    if (gl3 != null) {
      return gl3.glMapBufferRange(target, offset, length, access);
    }
    throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glMapBufferRange()" }));
  }
  

  public void unmapBuffer(int target)
  {
    gl2.glUnmapBuffer(target);
  }
  




  public long fenceSync(int condition, int flags)
  {
    if (gl3es3 != null) {
      return gl3es3.glFenceSync(condition, flags);
    }
    throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "fenceSync()" }));
  }
  

  public void deleteSync(long sync)
  {
    if (gl3es3 != null) {
      gl3es3.glDeleteSync(sync);
    } else {
      throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "deleteSync()" }));
    }
  }
  
  public int clientWaitSync(long sync, int flags, long timeout)
  {
    if (gl3es3 != null) {
      return gl3es3.glClientWaitSync(sync, flags, timeout);
    }
    throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "clientWaitSync()" }));
  }
  





  public void depthRangef(float n, float f)
  {
    gl.glDepthRangef(n, f);
  }
  
  public void viewport(int x, int y, int w, int h)
  {
    float scale = getPixelScale();
    viewportImpl((int)scale * x, (int)(scale * y), (int)(scale * w), (int)(scale * h));
  }
  
  protected void viewportImpl(int x, int y, int w, int h)
  {
    gl.glViewport(x, y, w, h);
  }
  




  protected void readPixelsImpl(int x, int y, int width, int height, int format, int type, Buffer buffer)
  {
    gl.glReadPixels(x, y, width, height, format, type, buffer);
  }
  
  protected void readPixelsImpl(int x, int y, int width, int height, int format, int type, long offset)
  {
    gl.glReadPixels(x, y, width, height, format, type, 0L);
  }
  




  public void vertexAttrib1f(int index, float value)
  {
    gl2.glVertexAttrib1f(index, value);
  }
  
  public void vertexAttrib2f(int index, float value0, float value1)
  {
    gl2.glVertexAttrib2f(index, value0, value1);
  }
  
  public void vertexAttrib3f(int index, float value0, float value1, float value2)
  {
    gl2.glVertexAttrib3f(index, value0, value1, value2);
  }
  
  public void vertexAttrib4f(int index, float value0, float value1, float value2, float value3)
  {
    gl2.glVertexAttrib4f(index, value0, value1, value2, value3);
  }
  
  public void vertexAttrib1fv(int index, FloatBuffer values)
  {
    gl2.glVertexAttrib1fv(index, values);
  }
  
  public void vertexAttrib2fv(int index, FloatBuffer values)
  {
    gl2.glVertexAttrib2fv(index, values);
  }
  
  public void vertexAttrib3fv(int index, FloatBuffer values)
  {
    gl2.glVertexAttrib3fv(index, values);
  }
  
  public void vertexAttrib4fv(int index, FloatBuffer values)
  {
    gl2.glVertexAttrib4fv(index, values);
  }
  
  public void vertexAttribPointer(int index, int size, int type, boolean normalized, int stride, int offset)
  {
    gl2.glVertexAttribPointer(index, size, type, normalized, stride, offset);
  }
  
  public void enableVertexAttribArray(int index)
  {
    gl2.glEnableVertexAttribArray(index);
  }
  
  public void disableVertexAttribArray(int index)
  {
    gl2.glDisableVertexAttribArray(index);
  }
  
  public void drawArraysImpl(int mode, int first, int count)
  {
    gl.glDrawArrays(mode, first, count);
  }
  
  public void drawElementsImpl(int mode, int count, int type, int offset)
  {
    gl.glDrawElements(mode, count, type, offset);
  }
  




  public void lineWidth(float width)
  {
    gl.glLineWidth(width);
  }
  
  public void frontFace(int dir)
  {
    gl.glFrontFace(dir);
  }
  
  public void cullFace(int mode)
  {
    gl.glCullFace(mode);
  }
  
  public void polygonOffset(float factor, float units)
  {
    gl.glPolygonOffset(factor, units);
  }
  




  public void pixelStorei(int pname, int param)
  {
    gl.glPixelStorei(pname, param);
  }
  




  public void texImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Buffer data)
  {
    gl.glTexImage2D(target, level, internalFormat, width, height, border, format, type, data);
  }
  
  public void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border)
  {
    gl.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
  }
  
  public void texSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, Buffer data)
  {
    gl.glTexSubImage2D(target, level, xOffset, yOffset, width, height, format, type, data);
  }
  
  public void copyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height)
  {
    gl.glCopyTexSubImage2D(target, level, x, y, xOffset, yOffset, width, height);
  }
  
  public void compressedTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int imageSize, Buffer data)
  {
    gl.glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data);
  }
  
  public void compressedTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int imageSize, Buffer data)
  {
    gl.glCompressedTexSubImage2D(target, level, xOffset, yOffset, width, height, format, imageSize, data);
  }
  
  public void texParameteri(int target, int pname, int param)
  {
    gl.glTexParameteri(target, pname, param);
  }
  
  public void texParameterf(int target, int pname, float param)
  {
    gl.glTexParameterf(target, pname, param);
  }
  
  public void texParameteriv(int target, int pname, IntBuffer params)
  {
    gl.glTexParameteriv(target, pname, params);
  }
  
  public void texParameterfv(int target, int pname, FloatBuffer params)
  {
    gl.glTexParameterfv(target, pname, params);
  }
  
  public void generateMipmap(int target)
  {
    gl.glGenerateMipmap(target);
  }
  
  public void genTextures(int n, IntBuffer textures)
  {
    gl.glGenTextures(n, textures);
  }
  
  public void deleteTextures(int n, IntBuffer textures)
  {
    gl.glDeleteTextures(n, textures);
  }
  
  public void getTexParameteriv(int target, int pname, IntBuffer params)
  {
    gl.glGetTexParameteriv(target, pname, params);
  }
  
  public void getTexParameterfv(int target, int pname, FloatBuffer params)
  {
    gl.glGetTexParameterfv(target, pname, params);
  }
  
  public boolean isTexture(int texture)
  {
    return gl.glIsTexture(texture);
  }
  
  protected void activeTextureImpl(int texture)
  {
    gl.glActiveTexture(texture);
  }
  
  protected void bindTextureImpl(int target, int texture)
  {
    gl.glBindTexture(target, texture);
  }
  




  public int createShader(int type)
  {
    return gl2.glCreateShader(type);
  }
  
  public void shaderSource(int shader, String source)
  {
    gl2.glShaderSource(shader, 1, new String[] { source }, null, 0);
  }
  
  public void compileShader(int shader)
  {
    gl2.glCompileShader(shader);
  }
  
  public void releaseShaderCompiler()
  {
    gl2.glReleaseShaderCompiler();
  }
  
  public void deleteShader(int shader)
  {
    gl2.glDeleteShader(shader);
  }
  
  public void shaderBinary(int count, IntBuffer shaders, int binaryFormat, Buffer binary, int length)
  {
    gl2.glShaderBinary(count, shaders, binaryFormat, binary, length);
  }
  
  public int createProgram()
  {
    return gl2.glCreateProgram();
  }
  
  public void attachShader(int program, int shader)
  {
    gl2.glAttachShader(program, shader);
  }
  
  public void detachShader(int program, int shader)
  {
    gl2.glDetachShader(program, shader);
  }
  
  public void linkProgram(int program)
  {
    gl2.glLinkProgram(program);
  }
  
  public void useProgram(int program)
  {
    gl2.glUseProgram(program);
  }
  
  public void deleteProgram(int program)
  {
    gl2.glDeleteProgram(program);
  }
  
  public String getActiveAttrib(int program, int index, IntBuffer size, IntBuffer type)
  {
    int[] tmp = new int[3];
    byte[] namebuf = new byte['Ѐ'];
    gl2.glGetActiveAttrib(program, index, 1024, tmp, 0, tmp, 1, tmp, 2, namebuf, 0);
    size.put(tmp[1]);
    type.put(tmp[2]);
    String name = new String(namebuf, 0, tmp[0]);
    return name;
  }
  
  public int getAttribLocation(int program, String name)
  {
    return gl2.glGetAttribLocation(program, name);
  }
  
  public void bindAttribLocation(int program, int index, String name)
  {
    gl2.glBindAttribLocation(program, index, name);
  }
  
  public int getUniformLocation(int program, String name)
  {
    return gl2.glGetUniformLocation(program, name);
  }
  
  public String getActiveUniform(int program, int index, IntBuffer size, IntBuffer type)
  {
    int[] tmp = new int[3];
    byte[] namebuf = new byte['Ѐ'];
    gl2.glGetActiveUniform(program, index, 1024, tmp, 0, tmp, 1, tmp, 2, namebuf, 0);
    size.put(tmp[1]);
    type.put(tmp[2]);
    String name = new String(namebuf, 0, tmp[0]);
    return name;
  }
  
  public void uniform1i(int location, int value)
  {
    gl2.glUniform1i(location, value);
  }
  
  public void uniform2i(int location, int value0, int value1)
  {
    gl2.glUniform2i(location, value0, value1);
  }
  
  public void uniform3i(int location, int value0, int value1, int value2)
  {
    gl2.glUniform3i(location, value0, value1, value2);
  }
  
  public void uniform4i(int location, int value0, int value1, int value2, int value3)
  {
    gl2.glUniform4i(location, value0, value1, value2, value3);
  }
  
  public void uniform1f(int location, float value)
  {
    gl2.glUniform1f(location, value);
  }
  
  public void uniform2f(int location, float value0, float value1)
  {
    gl2.glUniform2f(location, value0, value1);
  }
  
  public void uniform3f(int location, float value0, float value1, float value2)
  {
    gl2.glUniform3f(location, value0, value1, value2);
  }
  
  public void uniform4f(int location, float value0, float value1, float value2, float value3)
  {
    gl2.glUniform4f(location, value0, value1, value2, value3);
  }
  
  public void uniform1iv(int location, int count, IntBuffer v)
  {
    gl2.glUniform1iv(location, count, v);
  }
  
  public void uniform2iv(int location, int count, IntBuffer v)
  {
    gl2.glUniform2iv(location, count, v);
  }
  
  public void uniform3iv(int location, int count, IntBuffer v)
  {
    gl2.glUniform3iv(location, count, v);
  }
  
  public void uniform4iv(int location, int count, IntBuffer v)
  {
    gl2.glUniform4iv(location, count, v);
  }
  
  public void uniform1fv(int location, int count, FloatBuffer v)
  {
    gl2.glUniform1fv(location, count, v);
  }
  
  public void uniform2fv(int location, int count, FloatBuffer v)
  {
    gl2.glUniform2fv(location, count, v);
  }
  
  public void uniform3fv(int location, int count, FloatBuffer v)
  {
    gl2.glUniform3fv(location, count, v);
  }
  
  public void uniform4fv(int location, int count, FloatBuffer v)
  {
    gl2.glUniform4fv(location, count, v);
  }
  
  public void uniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer mat)
  {
    gl2.glUniformMatrix2fv(location, count, transpose, mat);
  }
  
  public void uniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer mat)
  {
    gl2.glUniformMatrix3fv(location, count, transpose, mat);
  }
  
  public void uniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer mat)
  {
    gl2.glUniformMatrix4fv(location, count, transpose, mat);
  }
  
  public void validateProgram(int program)
  {
    gl2.glValidateProgram(program);
  }
  
  public boolean isShader(int shader)
  {
    return gl2.glIsShader(shader);
  }
  
  public void getShaderiv(int shader, int pname, IntBuffer params)
  {
    gl2.glGetShaderiv(shader, pname, params);
  }
  
  public void getAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders)
  {
    gl2.glGetAttachedShaders(program, maxCount, count, shaders);
  }
  
  public String getShaderInfoLog(int shader)
  {
    int[] val = new int[1];
    gl2.glGetShaderiv(shader, 35716, val, 0);
    int length = val[0];
    
    byte[] log = new byte[length];
    gl2.glGetShaderInfoLog(shader, length, val, 0, log, 0);
    return new String(log);
  }
  
  public String getShaderSource(int shader)
  {
    int[] len = new int[1];
    byte[] buf = new byte['Ѐ'];
    gl2.glGetShaderSource(shader, 1024, len, 0, buf, 0);
    return new String(buf, 0, len[0]);
  }
  
  public void getShaderPrecisionFormat(int shaderType, int precisionType, IntBuffer range, IntBuffer precision)
  {
    gl2.glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
  }
  
  public void getVertexAttribfv(int index, int pname, FloatBuffer params)
  {
    gl2.glGetVertexAttribfv(index, pname, params);
  }
  
  public void getVertexAttribiv(int index, int pname, IntBuffer params)
  {
    gl2.glGetVertexAttribiv(index, pname, params);
  }
  
  public void getVertexAttribPointerv(int index, int pname, ByteBuffer data)
  {
    throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glGetVertexAttribPointerv()" }));
  }
  
  public void getUniformfv(int program, int location, FloatBuffer params)
  {
    gl2.glGetUniformfv(program, location, params);
  }
  
  public void getUniformiv(int program, int location, IntBuffer params)
  {
    gl2.glGetUniformiv(program, location, params);
  }
  
  public boolean isProgram(int program)
  {
    return gl2.glIsProgram(program);
  }
  
  public void getProgramiv(int program, int pname, IntBuffer params)
  {
    gl2.glGetProgramiv(program, pname, params);
  }
  
  public String getProgramInfoLog(int program)
  {
    int[] val = new int[1];
    gl2.glGetShaderiv(program, 35716, val, 0);
    int length = val[0];
    
    if (length > 0) {
      byte[] log = new byte[length];
      gl2.glGetProgramInfoLog(program, length, val, 0, log, 0);
      return new String(log);
    }
    return "Unknown error";
  }
  





  public void scissor(int x, int y, int w, int h)
  {
    float scale = getPixelScale();
    gl.glScissor((int)scale * x, (int)(scale * y), (int)(scale * w), (int)(scale * h));
  }
  

  public void sampleCoverage(float value, boolean invert)
  {
    gl2.glSampleCoverage(value, invert);
  }
  
  public void stencilFunc(int func, int ref, int mask)
  {
    gl2.glStencilFunc(func, ref, mask);
  }
  
  public void stencilFuncSeparate(int face, int func, int ref, int mask)
  {
    gl2.glStencilFuncSeparate(face, func, ref, mask);
  }
  
  public void stencilOp(int sfail, int dpfail, int dppass)
  {
    gl2.glStencilOp(sfail, dpfail, dppass);
  }
  
  public void stencilOpSeparate(int face, int sfail, int dpfail, int dppass)
  {
    gl2.glStencilOpSeparate(face, sfail, dpfail, dppass);
  }
  
  public void depthFunc(int func)
  {
    gl.glDepthFunc(func);
  }
  
  public void blendEquation(int mode)
  {
    gl.glBlendEquation(mode);
  }
  
  public void blendEquationSeparate(int modeRGB, int modeAlpha)
  {
    gl.glBlendEquationSeparate(modeRGB, modeAlpha);
  }
  
  public void blendFunc(int src, int dst)
  {
    gl.glBlendFunc(src, dst);
  }
  
  public void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)
  {
    gl.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  
  public void blendColor(float red, float green, float blue, float alpha)
  {
    gl2.glBlendColor(red, green, blue, alpha);
  }
  




  public void colorMask(boolean r, boolean g, boolean b, boolean a)
  {
    gl.glColorMask(r, g, b, a);
  }
  
  public void depthMask(boolean mask)
  {
    gl.glDepthMask(mask);
  }
  
  public void stencilMask(int mask)
  {
    gl.glStencilMask(mask);
  }
  
  public void stencilMaskSeparate(int face, int mask)
  {
    gl2.glStencilMaskSeparate(face, mask);
  }
  
  public void clearColor(float r, float g, float b, float a)
  {
    gl.glClearColor(r, g, b, a);
  }
  
  public void clearDepth(float d)
  {
    gl.glClearDepth(d);
  }
  
  public void clearStencil(int s)
  {
    gl.glClearStencil(s);
  }
  
  public void clear(int buf)
  {
    gl.glClear(buf);
  }
  




  protected void bindFramebufferImpl(int target, int framebuffer)
  {
    gl.glBindFramebuffer(target, framebuffer);
  }
  
  public void deleteFramebuffers(int n, IntBuffer framebuffers)
  {
    gl.glDeleteFramebuffers(n, framebuffers);
  }
  
  public void genFramebuffers(int n, IntBuffer framebuffers)
  {
    gl.glGenFramebuffers(n, framebuffers);
  }
  
  public void bindRenderbuffer(int target, int renderbuffer)
  {
    gl.glBindRenderbuffer(target, renderbuffer);
  }
  
  public void deleteRenderbuffers(int n, IntBuffer renderbuffers)
  {
    gl.glDeleteRenderbuffers(n, renderbuffers);
  }
  
  public void genRenderbuffers(int n, IntBuffer renderbuffers)
  {
    gl.glGenRenderbuffers(n, renderbuffers);
  }
  
  public void renderbufferStorage(int target, int internalFormat, int width, int height)
  {
    gl.glRenderbufferStorage(target, internalFormat, width, height);
  }
  
  public void framebufferRenderbuffer(int target, int attachment, int rendbuferfTarget, int renderbuffer)
  {
    gl.glFramebufferRenderbuffer(target, attachment, rendbuferfTarget, renderbuffer);
  }
  
  public void framebufferTexture2D(int target, int attachment, int texTarget, int texture, int level)
  {
    gl.glFramebufferTexture2D(target, attachment, texTarget, texture, level);
  }
  
  public int checkFramebufferStatus(int target)
  {
    return gl.glCheckFramebufferStatus(target);
  }
  
  public boolean isFramebuffer(int framebuffer)
  {
    return gl2.glIsFramebuffer(framebuffer);
  }
  
  public void getFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)
  {
    gl2.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
  }
  
  public boolean isRenderbuffer(int renderbuffer)
  {
    return gl2.glIsRenderbuffer(renderbuffer);
  }
  
  public void getRenderbufferParameteriv(int target, int pname, IntBuffer params)
  {
    gl2.glGetRenderbufferParameteriv(target, pname, params);
  }
  
  public void blitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)
  {
    if (gl2x != null) {
      gl2x.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    } else if (gl3 != null) {
      gl3.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    } else {
      throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glBlitFramebuffer()" }));
    }
  }
  
  public void renderbufferStorageMultisample(int target, int samples, int format, int width, int height)
  {
    if (gl2x != null) {
      gl2x.glRenderbufferStorageMultisample(target, samples, format, width, height);
    } else if (gl3 != null) {
      gl3.glRenderbufferStorageMultisample(target, samples, format, width, height);
    } else {
      throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glRenderbufferStorageMultisample()" }));
    }
  }
  
  public void readBuffer(int buf)
  {
    if (gl2x != null) {
      gl2x.glReadBuffer(buf);
    } else if (gl3 != null) {
      gl3.glReadBuffer(buf);
    } else {
      throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glReadBuffer()" }));
    }
  }
  
  public void drawBuffer(int buf)
  {
    if (gl2x != null) {
      gl2x.glDrawBuffer(buf);
    } else if (gl3 != null) {
      gl3.glDrawBuffer(buf);
    } else {
      throw new RuntimeException(String.format("GL function %1$s is not available on this hardware (or driver) Read http://wiki.processing.org/w/OpenGL_Issues for help.", new Object[] { "glDrawBuffer()" }));
    }
  }
  
  protected void setFrameRate(float fps) {}
  
  protected void initSurface(int antialias) {}
  
  protected void reinitSurface() {}
  
  protected void registerListeners() {}
  
  protected void requestFocus() {}
  
  protected void requestDraw() {}
}
