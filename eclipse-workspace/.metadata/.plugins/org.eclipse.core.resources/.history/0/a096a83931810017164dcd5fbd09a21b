package processing.core;

import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Float;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import processing.data.IntDict;
import processing.data.StringDict;
import processing.data.XML;























































































public class PShapeSVG
  extends PShape
{
  XML element;
  protected float opacity;
  float strokeOpacity;
  float fillOpacity;
  protected float svgWidth;
  protected float svgHeight;
  protected float svgSizeXY;
  protected Gradient strokeGradient;
  String strokeName;
  protected Gradient fillGradient;
  String fillName;
  
  public PShapeSVG(XML svg)
  {
    this(null, svg, true);
    
    if (!svg.getName().equals("svg")) {
      if (svg.getName().toLowerCase().equals("html"))
      {
        throw new RuntimeException("This appears to be a web page, not an SVG file.");
      }
      throw new RuntimeException("The root node is not <svg>, it's <" + svg.getName() + ">");
    }
  }
  

  protected PShapeSVG(PShapeSVG parent, XML properties, boolean parseKids)
  {
    setParent(parent);
    

    if (properties.getName().equals("svg")) {
      String unitWidth = properties.getString("width");
      String unitHeight = properties.getString("height");
      



      if (unitWidth != null) width = parseUnitSize(unitWidth, 100.0F);
      if (unitHeight != null) { height = parseUnitSize(unitHeight, 100.0F);
      }
      String viewBoxStr = properties.getString("viewBox");
      if (viewBoxStr != null) {
        float[] viewBox = PApplet.parseFloat(PApplet.splitTokens(viewBoxStr));
        if ((unitWidth == null) || (unitHeight == null))
        {

          width = viewBox[2];
          height = viewBox[3];
        }
        else
        {
          if (matrix == null) matrix = new PMatrix2D();
          matrix.scale(width / viewBox[2], height / viewBox[3]);
          matrix.translate(-viewBox[0], -viewBox[1]);
        }
      }
      

      if ((width < 0.0F) || (height < 0.0F)) {
        throw new RuntimeException("<svg>: width (" + width + 
          ") and height (" + height + ") must not be negative.");
      }
      

      if (((unitWidth == null) || (unitHeight == null)) && (viewBoxStr == null))
      {
        PGraphics.showWarning("The width and/or height is not readable in the <svg> tag of this file.");
        



        width = 1.0F;
        height = 1.0F;
      }
      
      svgWidth = width;
      svgHeight = height;
      svgSizeXY = PApplet.sqrt((svgWidth * svgWidth + svgHeight * svgHeight) / 2.0F);
    }
    
    element = properties;
    name = properties.getString("id");
    
    if (name != null) {
      for (;;) {
        String[] m = PApplet.match(name, "_x([A-Za-z0-9]{2})_");
        if (m == null) break;
        char repair = (char)PApplet.unhex(m[1]);
        name = name.replace(m[0], repair);
      }
    }
    
    String displayStr = properties.getString("display", "inline");
    visible = (!displayStr.equals("none"));
    
    String transformStr = properties.getString("transform");
    if (transformStr != null) {
      if (matrix == null) {
        matrix = parseTransform(transformStr);
      } else {
        matrix.preApply(parseTransform(transformStr));
      }
    }
    
    if (parseKids) {
      parseColors(properties);
      parseChildren(properties);
    }
  }
  




  protected void setParent(PShapeSVG parent)
  {
    this.parent = parent;
    
    if (parent == null)
    {
      stroke = false;
      strokeColor = -16777216;
      strokeWeight = 1.0F;
      strokeCap = 1;
      strokeJoin = 8;
      strokeGradient = null;
      
      strokeName = null;
      
      fill = true;
      fillColor = -16777216;
      fillGradient = null;
      
      fillName = null;
      





      strokeOpacity = 1.0F;
      fillOpacity = 1.0F;
      opacity = 1.0F;
    }
    else {
      stroke = stroke;
      strokeColor = strokeColor;
      strokeWeight = strokeWeight;
      strokeCap = strokeCap;
      strokeJoin = strokeJoin;
      strokeGradient = strokeGradient;
      
      strokeName = strokeName;
      
      fill = fill;
      fillColor = fillColor;
      fillGradient = fillGradient;
      
      fillName = fillName;
      
      svgWidth = svgWidth;
      svgHeight = svgHeight;
      svgSizeXY = svgSizeXY;
      
      opacity = opacity;
    }
    


    rectMode = 0;
    ellipseMode = 0;
  }
  

  protected PShapeSVG createShape(PShapeSVG parent, XML properties, boolean parseKids)
  {
    return new PShapeSVG(parent, properties, parseKids);
  }
  
  protected void parseChildren(XML graphics)
  {
    XML[] elements = graphics.getChildren();
    children = new PShape[elements.length];
    childCount = 0;
    
    for (XML elem : elements) {
      PShape kid = parseChild(elem);
      if (kid != null) addChild(kid);
    }
    children = ((PShape[])PApplet.subset(children, 0, childCount));
  }
  





  protected PShape parseChild(XML elem)
  {
    String name = elem.getName();
    PShapeSVG shape = null;
    

    if (name != null)
    {

      if (name.equals("g")) {
        shape = createShape(this, elem, true);
      }
      else if (name.equals("defs"))
      {

        shape = createShape(this, elem, true);
      }
      else if (name.equals("line")) {
        shape = createShape(this, elem, true);
        shape.parseLine();
      }
      else if (name.equals("circle")) {
        shape = createShape(this, elem, true);
        shape.parseEllipse(true);
      }
      else if (name.equals("ellipse")) {
        shape = createShape(this, elem, true);
        shape.parseEllipse(false);
      }
      else if (name.equals("rect")) {
        shape = createShape(this, elem, true);
        shape.parseRect();
      }
      else if (name.equals("polygon")) {
        shape = createShape(this, elem, true);
        shape.parsePoly(true);
      }
      else if (name.equals("polyline")) {
        shape = createShape(this, elem, true);
        shape.parsePoly(false);
      }
      else if (name.equals("path")) {
        shape = createShape(this, elem, true);
        shape.parsePath();
      } else {
        if (name.equals("radialGradient")) {
          return new RadialGradient(this, elem);
        }
        if (name.equals("linearGradient")) {
          return new LinearGradient(this, elem);
        }
        if (name.equals("font")) {
          return new Font(this, elem);
        }
        





        if (name.equals("text")) {
          PGraphics.showWarning("Text and fonts in SVG files are not currently supported, convert text to outlines instead.");

        }
        else if (name.equals("filter")) {
          PGraphics.showWarning("Filters are not supported.");
        }
        else if (name.equals("mask")) {
          PGraphics.showWarning("Masks are not supported.");
        }
        else if (name.equals("pattern")) {
          PGraphics.showWarning("Patterns are not supported.");
        }
        else if (!name.equals("stop"))
        {

          if (!name.equals("sodipodi:namedview"))
          {

            if ((name.equals("metadata")) || 
              (name.equals("title")) || (name.equals("desc")))
            {

              return null;
            }
            if (!name.startsWith("#"))
              PGraphics.showWarning("Ignoring <" + name + "> tag.");
          } }
      } }
    return shape;
  }
  
  protected void parseLine()
  {
    kind = 4;
    family = 101;
    params = new float[] {
      getFloatWithUnit(element, "x1", svgWidth), 
      getFloatWithUnit(element, "y1", svgHeight), 
      getFloatWithUnit(element, "x2", svgWidth), 
      getFloatWithUnit(element, "y2", svgHeight) };
  }
  





  protected void parseEllipse(boolean circle)
  {
    kind = 31;
    family = 101;
    params = new float[4];
    
    params[0] = getFloatWithUnit(element, "cx", svgWidth);
    params[1] = getFloatWithUnit(element, "cy", svgHeight);
    float rx;
    float rx;
    float ry; if (circle) { float ry;
      rx = ry = getFloatWithUnit(element, "r", svgSizeXY);
    } else {
      rx = getFloatWithUnit(element, "rx", svgWidth);
      ry = getFloatWithUnit(element, "ry", svgHeight);
    }
    params[0] -= rx;
    params[1] -= ry;
    
    params[2] = (rx * 2.0F);
    params[3] = (ry * 2.0F);
  }
  
  protected void parseRect()
  {
    kind = 30;
    family = 101;
    params = new float[] {
      getFloatWithUnit(element, "x", svgWidth), 
      getFloatWithUnit(element, "y", svgHeight), 
      getFloatWithUnit(element, "width", svgWidth), 
      getFloatWithUnit(element, "height", svgHeight) };
  }
  






  protected void parsePoly(boolean close)
  {
    family = 102;
    this.close = close;
    
    String pointsAttr = element.getString("points");
    if (pointsAttr != null) {
      String[] pointsBuffer = PApplet.splitTokens(pointsAttr);
      vertexCount = pointsBuffer.length;
      vertices = new float[vertexCount][2];
      for (int i = 0; i < vertexCount; i++) {
        String[] pb = PApplet.splitTokens(pointsBuffer[i], ", \t\r\n");
        vertices[i][0] = Float.parseFloat(pb[0]);
        vertices[i][1] = Float.parseFloat(pb[1]);
      }
    }
  }
  
  protected void parsePath()
  {
    family = 102;
    kind = 0;
    
    String pathData = element.getString("d");
    if ((pathData == null) || (PApplet.trim(pathData).length() == 0)) {
      return;
    }
    char[] pathDataChars = pathData.toCharArray();
    
    StringBuilder pathBuffer = new StringBuilder();
    boolean lastSeparate = false;
    
    for (int i = 0; i < pathDataChars.length; i++) {
      char c = pathDataChars[i];
      boolean separate = false;
      
      if ((c == 'M') || (c == 'm') || 
        (c == 'L') || (c == 'l') || 
        (c == 'H') || (c == 'h') || 
        (c == 'V') || (c == 'v') || 
        (c == 'C') || (c == 'c') || 
        (c == 'S') || (c == 's') || 
        (c == 'Q') || (c == 'q') || 
        (c == 'T') || (c == 't') || 
        (c == 'A') || (c == 'a') || 
        (c == 'Z') || (c == 'z') || 
        (c == ',')) {
        separate = true;
        if (i != 0) {
          pathBuffer.append("|");
        }
      }
      if ((c == 'Z') || (c == 'z')) {
        separate = false;
      }
      if ((c == '-') && (!lastSeparate))
      {

        if ((i == 0) || (pathDataChars[(i - 1)] != 'e')) {
          pathBuffer.append("|");
        }
      }
      if (c != ',') {
        pathBuffer.append(c);
      }
      if ((separate) && (c != ',') && (c != '-')) {
        pathBuffer.append("|");
      }
      lastSeparate = separate;
    }
    

    String[] pathTokens = 
      PApplet.splitTokens(pathBuffer.toString(), "| \t\n\r\f ");
    vertices = new float[pathTokens.length][2];
    vertexCodes = new int[pathTokens.length];
    
    float cx = 0.0F;
    float cy = 0.0F;
    int i = 0;
    
    char implicitCommand = '\000';
    
    boolean prevCurve = false;
    

    float movetoX = 0.0F;
    float movetoY = 0.0F;
    
    while (i < pathTokens.length) {
      char c = pathTokens[i].charAt(0);
      if (((c >= '0') && (c <= '9')) || ((c == '-') && (implicitCommand != 0))) {
        c = implicitCommand;
        i--;
      } else {
        implicitCommand = c;
      }
      switch (c)
      {
      case 'M': 
        cx = PApplet.parseFloat(pathTokens[(i + 1)]);
        cy = PApplet.parseFloat(pathTokens[(i + 2)]);
        movetoX = cx;
        movetoY = cy;
        parsePathMoveto(cx, cy);
        implicitCommand = 'L';
        i += 3;
        break;
      
      case 'm': 
        cx += PApplet.parseFloat(pathTokens[(i + 1)]);
        cy += PApplet.parseFloat(pathTokens[(i + 2)]);
        movetoX = cx;
        movetoY = cy;
        parsePathMoveto(cx, cy);
        implicitCommand = 'l';
        i += 3;
        break;
      
      case 'L': 
        cx = PApplet.parseFloat(pathTokens[(i + 1)]);
        cy = PApplet.parseFloat(pathTokens[(i + 2)]);
        parsePathLineto(cx, cy);
        i += 3;
        break;
      
      case 'l': 
        cx += PApplet.parseFloat(pathTokens[(i + 1)]);
        cy += PApplet.parseFloat(pathTokens[(i + 2)]);
        parsePathLineto(cx, cy);
        i += 3;
        break;
      

      case 'H': 
        cx = PApplet.parseFloat(pathTokens[(i + 1)]);
        parsePathLineto(cx, cy);
        i += 2;
        break;
      

      case 'h': 
        cx += PApplet.parseFloat(pathTokens[(i + 1)]);
        parsePathLineto(cx, cy);
        i += 2;
        break;
      
      case 'V': 
        cy = PApplet.parseFloat(pathTokens[(i + 1)]);
        parsePathLineto(cx, cy);
        i += 2;
        break;
      
      case 'v': 
        cy += PApplet.parseFloat(pathTokens[(i + 1)]);
        parsePathLineto(cx, cy);
        i += 2;
        break;
      

      case 'C': 
        float ctrlX1 = PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY1 = PApplet.parseFloat(pathTokens[(i + 2)]);
        float ctrlX2 = PApplet.parseFloat(pathTokens[(i + 3)]);
        float ctrlY2 = PApplet.parseFloat(pathTokens[(i + 4)]);
        float endX = PApplet.parseFloat(pathTokens[(i + 5)]);
        float endY = PApplet.parseFloat(pathTokens[(i + 6)]);
        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);
        cx = endX;
        cy = endY;
        i += 7;
        prevCurve = true;
        
        break;
      

      case 'c': 
        float ctrlX1 = cx + PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY1 = cy + PApplet.parseFloat(pathTokens[(i + 2)]);
        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[(i + 3)]);
        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[(i + 4)]);
        float endX = cx + PApplet.parseFloat(pathTokens[(i + 5)]);
        float endY = cy + PApplet.parseFloat(pathTokens[(i + 6)]);
        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);
        cx = endX;
        cy = endY;
        i += 7;
        prevCurve = true;
        
        break;
      case 'S': 
        float ctrlY;
        



        float ctrlX;
        



        float ctrlY;
        


        if (!prevCurve) {
          float ctrlX = cx;
          ctrlY = cy;
        } else {
          float ppx = vertices[(vertexCount - 2)][0];
          float ppy = vertices[(vertexCount - 2)][1];
          float px = vertices[(vertexCount - 1)][0];
          float py = vertices[(vertexCount - 1)][1];
          ctrlX = px + (px - ppx);
          ctrlY = py + (py - ppy);
        }
        float ctrlX2 = PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY2 = PApplet.parseFloat(pathTokens[(i + 2)]);
        float endX = PApplet.parseFloat(pathTokens[(i + 3)]);
        float endY = PApplet.parseFloat(pathTokens[(i + 4)]);
        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);
        cx = endX;
        cy = endY;
        i += 5;
        prevCurve = true;
        
        break;
      case 's':  float ctrlY;
        float ctrlX;
        float ctrlY;
        if (!prevCurve) {
          float ctrlX = cx;
          ctrlY = cy;
        } else {
          float ppx = vertices[(vertexCount - 2)][0];
          float ppy = vertices[(vertexCount - 2)][1];
          float px = vertices[(vertexCount - 1)][0];
          float py = vertices[(vertexCount - 1)][1];
          ctrlX = px + (px - ppx);
          ctrlY = py + (py - ppy);
        }
        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[(i + 2)]);
        float endX = cx + PApplet.parseFloat(pathTokens[(i + 3)]);
        float endY = cy + PApplet.parseFloat(pathTokens[(i + 4)]);
        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);
        cx = endX;
        cy = endY;
        i += 5;
        prevCurve = true;
        
        break;
      







      case 'Q': 
        float ctrlX = PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY = PApplet.parseFloat(pathTokens[(i + 2)]);
        float endX = PApplet.parseFloat(pathTokens[(i + 3)]);
        float endY = PApplet.parseFloat(pathTokens[(i + 4)]);
        
        parsePathQuadto(ctrlX, ctrlY, endX, endY);
        cx = endX;
        cy = endY;
        i += 5;
        prevCurve = true;
        
        break;
      

      case 'q': 
        float ctrlX = cx + PApplet.parseFloat(pathTokens[(i + 1)]);
        float ctrlY = cy + PApplet.parseFloat(pathTokens[(i + 2)]);
        float endX = cx + PApplet.parseFloat(pathTokens[(i + 3)]);
        float endY = cy + PApplet.parseFloat(pathTokens[(i + 4)]);
        
        parsePathQuadto(ctrlX, ctrlY, endX, endY);
        cx = endX;
        cy = endY;
        i += 5;
        prevCurve = true;
        
        break;
      case 'T': 
        float ctrlY;
        

        float ctrlX;
        
        float ctrlY;
        
        if (!prevCurve) {
          float ctrlX = cx;
          ctrlY = cy;
        } else {
          float ppx = vertices[(vertexCount - 2)][0];
          float ppy = vertices[(vertexCount - 2)][1];
          float px = vertices[(vertexCount - 1)][0];
          float py = vertices[(vertexCount - 1)][1];
          ctrlX = px + (px - ppx);
          ctrlY = py + (py - ppy);
        }
        float endX = PApplet.parseFloat(pathTokens[(i + 1)]);
        float endY = PApplet.parseFloat(pathTokens[(i + 2)]);
        
        parsePathQuadto(ctrlX, ctrlY, endX, endY);
        cx = endX;
        cy = endY;
        i += 3;
        prevCurve = true;
        
        break;
      case 't':  float ctrlY;
        float ctrlX;
        float ctrlY;
        if (!prevCurve) {
          float ctrlX = cx;
          ctrlY = cy;
        } else {
          float ppx = vertices[(vertexCount - 2)][0];
          float ppy = vertices[(vertexCount - 2)][1];
          float px = vertices[(vertexCount - 1)][0];
          float py = vertices[(vertexCount - 1)][1];
          ctrlX = px + (px - ppx);
          ctrlY = py + (py - ppy);
        }
        float endX = cx + PApplet.parseFloat(pathTokens[(i + 1)]);
        float endY = cy + PApplet.parseFloat(pathTokens[(i + 2)]);
        
        parsePathQuadto(ctrlX, ctrlY, endX, endY);
        cx = endX;
        cy = endY;
        i += 3;
        prevCurve = true;
        
        break;
      

      case 'A': 
        float rx = PApplet.parseFloat(pathTokens[(i + 1)]);
        float ry = PApplet.parseFloat(pathTokens[(i + 2)]);
        float angle = PApplet.parseFloat(pathTokens[(i + 3)]);
        boolean fa = PApplet.parseFloat(pathTokens[(i + 4)]) != 0.0F;
        boolean fs = PApplet.parseFloat(pathTokens[(i + 5)]) != 0.0F;
        float endX = PApplet.parseFloat(pathTokens[(i + 6)]);
        float endY = PApplet.parseFloat(pathTokens[(i + 7)]);
        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);
        cx = endX;
        cy = endY;
        i += 8;
        prevCurve = true;
        
        break;
      

      case 'a': 
        float rx = PApplet.parseFloat(pathTokens[(i + 1)]);
        float ry = PApplet.parseFloat(pathTokens[(i + 2)]);
        float angle = PApplet.parseFloat(pathTokens[(i + 3)]);
        boolean fa = PApplet.parseFloat(pathTokens[(i + 4)]) != 0.0F;
        boolean fs = PApplet.parseFloat(pathTokens[(i + 5)]) != 0.0F;
        float endX = cx + PApplet.parseFloat(pathTokens[(i + 6)]);
        float endY = cy + PApplet.parseFloat(pathTokens[(i + 7)]);
        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);
        cx = endX;
        cy = endY;
        i += 8;
        prevCurve = true;
        
        break;
      



      case 'Z': 
      case 'z': 
        cx = movetoX;
        cy = movetoY;
        close = true;
        i++;
        break;
      
      default: 
        String parsed = 
          PApplet.join(PApplet.subset(pathTokens, 0, i), ",");
        String unparsed = 
          PApplet.join(PApplet.subset(pathTokens, i), ",");
        System.err.println("parsed: " + parsed);
        System.err.println("unparsed: " + unparsed);
        throw new RuntimeException("shape command not handled: " + pathTokens[i]);
      }
      
    }
  }
  









  private void parsePathVertex(float x, float y)
  {
    if (vertexCount == vertices.length)
    {
      float[][] temp = new float[vertexCount << 1][2];
      System.arraycopy(vertices, 0, temp, 0, vertexCount);
      vertices = temp;
    }
    vertices[vertexCount][0] = x;
    vertices[vertexCount][1] = y;
    vertexCount += 1;
  }
  
  private void parsePathCode(int what)
  {
    if (vertexCodeCount == vertexCodes.length) {
      vertexCodes = PApplet.expand(vertexCodes);
    }
    vertexCodes[(vertexCodeCount++)] = what;
  }
  
  private void parsePathMoveto(float px, float py)
  {
    if (vertexCount > 0) {
      parsePathCode(4);
    }
    parsePathCode(0);
    parsePathVertex(px, py);
  }
  
  private void parsePathLineto(float px, float py)
  {
    parsePathCode(0);
    parsePathVertex(px, py);
  }
  


  private void parsePathCurveto(float x1, float y1, float x2, float y2, float x3, float y3)
  {
    parsePathCode(1);
    parsePathVertex(x1, y1);
    parsePathVertex(x2, y2);
    parsePathVertex(x3, y3);
  }
  















  private void parsePathQuadto(float cx, float cy, float x2, float y2)
  {
    parsePathCode(2);
    
    parsePathVertex(cx, cy);
    parsePathVertex(x2, y2);
  }
  










  private void parsePathArcto(float x1, float y1, float rx, float ry, float angle, boolean fa, boolean fs, float x2, float y2)
  {
    if ((x1 == x2) && (y1 == y2)) return;
    if ((rx == 0.0F) || (ry == 0.0F)) { parsePathLineto(x2, y2);return;
    }
    rx = PApplet.abs(rx);ry = PApplet.abs(ry);
    
    float phi = PApplet.radians((angle % 360.0F + 360.0F) % 360.0F);
    float cosPhi = PApplet.cos(phi);float sinPhi = PApplet.sin(phi);
    
    float x1r = (cosPhi * (x1 - x2) + sinPhi * (y1 - y2)) / 2.0F;
    float y1r = (-sinPhi * (x1 - x2) + cosPhi * (y1 - y2)) / 2.0F;
    


    float A = x1r * x1r / (rx * rx) + y1r * y1r / (ry * ry);
    float cyr; float cxr; float cyr; if (A > 1.0F)
    {
      float sqrtA = PApplet.sqrt(A);
      rx *= sqrtA;float cxr = 0.0F;
      ry *= sqrtA;cyr = 0.0F;
    } else {
      float k = (fa == fs ? -1.0F : 1.0F) * 
        PApplet.sqrt(rx * rx * ry * ry / (rx * rx * y1r * y1r + ry * ry * x1r * x1r) - 1.0F);
      cxr = k * rx * y1r / ry;
      cyr = -k * ry * x1r / rx;
    }
    

    float cx = cosPhi * cxr - sinPhi * cyr + (x1 + x2) / 2.0F;
    float cy = sinPhi * cxr + cosPhi * cyr + (y1 + y2) / 2.0F;
    


    float sx = (x1r - cxr) / rx;float sy = (y1r - cyr) / ry;
    float tx = (-x1r - cxr) / rx;float ty = (-y1r - cyr) / ry;
    float phi1 = PApplet.atan2(sy, sx);
    float phiDelta = ((PApplet.atan2(ty, tx) - phi1) % 6.2831855F + 6.2831855F) % 6.2831855F;
    if (!fs) { phiDelta -= 6.2831855F;
    }
    


    int segmentCount = PApplet.ceil(PApplet.abs(phiDelta) / 6.2831855F * 4.0F);
    
    float inc = phiDelta / segmentCount;
    float a = PApplet.sin(inc) * (
      PApplet.sqrt(4.0F + 3.0F * PApplet.sq(PApplet.tan(inc / 2.0F))) - 1.0F) / 3.0F;
    
    float sinPhi1 = PApplet.sin(phi1);float cosPhi1 = PApplet.cos(phi1);
    
    float p1x = x1;
    float p1y = y1;
    float relq1x = a * (-rx * cosPhi * sinPhi1 - ry * sinPhi * cosPhi1);
    float relq1y = a * (-rx * sinPhi * sinPhi1 + ry * cosPhi * cosPhi1);
    
    for (int i = 0; i < segmentCount; i++) {
      float eta = phi1 + (i + 1) * inc;
      float sinEta = PApplet.sin(eta);float cosEta = PApplet.cos(eta);
      
      float p2x = cx + rx * cosPhi * cosEta - ry * sinPhi * sinEta;
      float p2y = cy + rx * sinPhi * cosEta + ry * cosPhi * sinEta;
      float relq2x = a * (-rx * cosPhi * sinEta - ry * sinPhi * cosEta);
      float relq2y = a * (-rx * sinPhi * sinEta + ry * cosPhi * cosEta);
      
      if (i == segmentCount - 1) { p2x = x2;p2y = y2;
      }
      parsePathCode(1);
      parsePathVertex(p1x + relq1x, p1y + relq1y);
      parsePathVertex(p2x - relq2x, p2y - relq2y);
      parsePathVertex(p2x, p2y);
      
      p1x = p2x;relq1x = relq2x;
      p1y = p2y;relq1y = relq2y;
    }
  }
  









  protected static PMatrix2D parseTransform(String matrixStr)
  {
    matrixStr = matrixStr.trim();
    PMatrix2D outgoing = null;
    int start = 0;
    int stop = -1;
    while ((stop = matrixStr.indexOf(')', start)) != -1) {
      PMatrix2D m = parseSingleTransform(matrixStr.substring(start, stop + 1));
      if (outgoing == null) {
        outgoing = m;
      } else {
        outgoing.apply(m);
      }
      start = stop + 1;
    }
    return outgoing;
  }
  

  protected static PMatrix2D parseSingleTransform(String matrixStr)
  {
    String[] pieces = PApplet.match(matrixStr, "[,\\s]*(\\w+)\\((.*)\\)");
    if (pieces == null) {
      System.err.println("Could not parse transform " + matrixStr);
      return null;
    }
    float[] m = PApplet.parseFloat(PApplet.splitTokens(pieces[2], ", "));
    if (pieces[1].equals("matrix")) {
      return new PMatrix2D(m[0], m[2], m[4], m[1], m[3], m[5]);
    }
    if (pieces[1].equals("translate")) {
      float tx = m[0];
      float ty = m.length == 2 ? m[1] : m[0];
      return new PMatrix2D(1.0F, 0.0F, tx, 0.0F, 1.0F, ty);
    }
    if (pieces[1].equals("scale")) {
      float sx = m[0];
      float sy = m.length == 2 ? m[1] : m[0];
      return new PMatrix2D(sx, 0.0F, 0.0F, 0.0F, sy, 0.0F);
    }
    if (pieces[1].equals("rotate")) {
      float angle = m[0];
      
      if (m.length == 1) {
        float c = PApplet.cos(angle);
        float s = PApplet.sin(angle);
        
        return new PMatrix2D(c, -s, 0.0F, s, c, 0.0F);
      }
      if (m.length == 3) {
        PMatrix2D mat = new PMatrix2D(0.0F, 1.0F, m[1], 1.0F, 0.0F, m[2]);
        mat.rotate(m[0]);
        mat.translate(-m[1], -m[2]);
        return mat;
      }
    } else {
      if (pieces[1].equals("skewX")) {
        return new PMatrix2D(1.0F, 0.0F, 1.0F, PApplet.tan(m[0]), 0.0F, 0.0F);
      }
      if (pieces[1].equals("skewY"))
        return new PMatrix2D(1.0F, 0.0F, 1.0F, 0.0F, PApplet.tan(m[0]), 0.0F);
    }
    return null;
  }
  
  protected void parseColors(XML properties)
  {
    if (properties.hasAttribute("opacity")) {
      String opacityText = properties.getString("opacity");
      setOpacity(opacityText);
    }
    
    if (properties.hasAttribute("stroke")) {
      String strokeText = properties.getString("stroke");
      setColor(strokeText, false);
    }
    
    if (properties.hasAttribute("stroke-opacity")) {
      String strokeOpacityText = properties.getString("stroke-opacity");
      setStrokeOpacity(strokeOpacityText);
    }
    
    if (properties.hasAttribute("stroke-width"))
    {
      String lineweight = properties.getString("stroke-width");
      setStrokeWeight(lineweight);
    }
    
    if (properties.hasAttribute("stroke-linejoin")) {
      String linejoin = properties.getString("stroke-linejoin");
      setStrokeJoin(linejoin);
    }
    
    if (properties.hasAttribute("stroke-linecap")) {
      String linecap = properties.getString("stroke-linecap");
      setStrokeCap(linecap);
    }
    


    if (properties.hasAttribute("fill")) {
      String fillText = properties.getString("fill");
      setColor(fillText, true);
    }
    
    if (properties.hasAttribute("fill-opacity")) {
      String fillOpacityText = properties.getString("fill-opacity");
      setFillOpacity(fillOpacityText);
    }
    
    if (properties.hasAttribute("style")) {
      String styleText = properties.getString("style");
      String[] styleTokens = PApplet.splitTokens(styleText, ";");
      

      for (int i = 0; i < styleTokens.length; i++) {
        String[] tokens = PApplet.splitTokens(styleTokens[i], ":");
        

        tokens[0] = PApplet.trim(tokens[0]);
        
        if (tokens[0].equals("fill")) {
          setColor(tokens[1], true);
        }
        else if (tokens[0].equals("fill-opacity")) {
          setFillOpacity(tokens[1]);
        }
        else if (tokens[0].equals("stroke")) {
          setColor(tokens[1], false);
        }
        else if (tokens[0].equals("stroke-width")) {
          setStrokeWeight(tokens[1]);
        }
        else if (tokens[0].equals("stroke-linecap")) {
          setStrokeCap(tokens[1]);
        }
        else if (tokens[0].equals("stroke-linejoin")) {
          setStrokeJoin(tokens[1]);
        }
        else if (tokens[0].equals("stroke-opacity")) {
          setStrokeOpacity(tokens[1]);
        }
        else if (tokens[0].equals("opacity")) {
          setOpacity(tokens[1]);
        }
      }
    }
  }
  



  void setOpacity(String opacityText)
  {
    opacity = PApplet.parseFloat(opacityText);
    strokeColor = ((int)(opacity * 255.0F) << 24 | strokeColor & 0xFFFFFF);
    fillColor = ((int)(opacity * 255.0F) << 24 | fillColor & 0xFFFFFF);
  }
  
  void setStrokeWeight(String lineweight)
  {
    strokeWeight = parseUnitSize(lineweight, svgSizeXY);
  }
  
  void setStrokeOpacity(String opacityText)
  {
    strokeOpacity = PApplet.parseFloat(opacityText);
    strokeColor = ((int)(strokeOpacity * 255.0F) << 24 | strokeColor & 0xFFFFFF);
  }
  
  void setStrokeJoin(String linejoin)
  {
    if (!linejoin.equals("inherit"))
    {

      if (linejoin.equals("miter")) {
        strokeJoin = 8;
      }
      else if (linejoin.equals("round")) {
        strokeJoin = 2;
      }
      else if (linejoin.equals("bevel")) {
        strokeJoin = 32;
      }
    }
  }
  
  void setStrokeCap(String linecap) {
    if (!linecap.equals("inherit"))
    {

      if (linecap.equals("butt")) {
        strokeCap = 1;
      }
      else if (linecap.equals("round")) {
        strokeCap = 2;
      }
      else if (linecap.equals("square")) {
        strokeCap = 4;
      }
    }
  }
  
  void setFillOpacity(String opacityText) {
    fillOpacity = PApplet.parseFloat(opacityText);
    fillColor = ((int)(fillOpacity * 255.0F) << 24 | fillColor & 0xFFFFFF);
  }
  
  void setColor(String colorText, boolean isFill)
  {
    colorText = colorText.trim();
    int opacityMask = fillColor & 0xFF000000;
    boolean visible = true;
    int color = 0;
    String name = "";
    
    Gradient gradient = null;
    
    if (colorText.equals("none")) {
      visible = false;
    } else if (colorText.startsWith("url(#")) {
      name = colorText.substring(5, colorText.length() - 1);
      Object object = findChild(name);
      if ((object instanceof Gradient)) {
        gradient = (Gradient)object;

      }
      else
      {
        System.err.println("url " + name + " refers to unexpected data: " + object);
      }
    }
    else {
      color = opacityMask | parseSimpleColor(colorText);
    }
    if (isFill) {
      fill = visible;
      fillColor = color;
      fillName = name;
      fillGradient = gradient;
    }
    else {
      stroke = visible;
      strokeColor = color;
      strokeName = name;
      strokeGradient = gradient;
    }
  }
  






  protected static int parseSimpleColor(String colorText)
  {
    colorText = colorText.toLowerCase().trim();
    
    if (colorNames.hasKey(colorText))
      return colorNames.get(colorText);
    if (colorText.startsWith("#")) {
      if (colorText.length() == 4)
      {
        colorText = colorText.replaceAll("^#(.)(.)(.)$", "#$1$1$2$2$3$3");
      }
      return Integer.parseInt(colorText.substring(1), 16) & 0xFFFFFF;
    }
    if (colorText.startsWith("rgb")) {
      return parseRGB(colorText);
    }
    System.err.println("Cannot parse \"" + colorText + "\".");
    return 0;
  }
  






  protected static IntDict colorNames = new IntDict(new Object[][] {
    { "aqua", Integer.valueOf(65535) }, 
    { "black", Integer.valueOf(0) }, 
    { "blue", Integer.valueOf(255) }, 
    { "fuchsia", Integer.valueOf(16711935) }, 
    { "gray", Integer.valueOf(8421504) }, 
    { "grey", Integer.valueOf(8421504) }, 
    { "green", Integer.valueOf(32768) }, 
    { "lime", Integer.valueOf(65280) }, 
    { "maroon", Integer.valueOf(8388608) }, 
    { "navy", Integer.valueOf(128) }, 
    { "olive", Integer.valueOf(8421376) }, 
    { "purple", Integer.valueOf(8388736) }, 
    { "red", Integer.valueOf(16711680) }, 
    { "silver", Integer.valueOf(12632256) }, 
    { "teal", Integer.valueOf(32896) }, 
    { "white", Integer.valueOf(16777215) }, 
    { "yellow", Integer.valueOf(16776960) } });
  
























  protected static int parseRGB(String what)
  {
    int leftParen = what.indexOf('(') + 1;
    int rightParen = what.indexOf(')');
    String sub = what.substring(leftParen, rightParen);
    String[] values = PApplet.splitTokens(sub, ", ");
    int rgbValue = 0;
    if (values.length == 3)
    {
      for (int i = 0; i < 3; i++) {
        rgbValue <<= 8;
        if (values[i].endsWith("%")) {
          rgbValue |= (int)PApplet.constrain(255.0F * parseFloatOrPercent(values[i]), 0.0F, 255.0F);
        } else
          rgbValue |= PApplet.constrain(PApplet.parseInt(values[i]), 0, 255);
      }
    } else {
      System.err.println("Could not read color \"" + what + "\".");
    }
    return rgbValue;
  }
  


  protected static StringDict parseStyleAttributes(String style)
  {
    StringDict table = new StringDict();
    
    if (style != null) {
      String[] pieces = style.split(";");
      for (int i = 0; i < pieces.length; i++) {
        String[] parts = pieces[i].split(":");
        
        table.set(parts[0], parts[1]);
      }
    }
    return table;
  }
  










  protected static float getFloatWithUnit(XML element, String attribute, float relativeTo)
  {
    String val = element.getString(attribute);
    return val == null ? 0.0F : parseUnitSize(val, relativeTo);
  }
  















  protected static float parseUnitSize(String text, float relativeTo)
  {
    int len = text.length() - 2;
    
    if (text.endsWith("pt"))
      return PApplet.parseFloat(text.substring(0, len)) * 1.25F;
    if (text.endsWith("pc"))
      return PApplet.parseFloat(text.substring(0, len)) * 15.0F;
    if (text.endsWith("mm"))
      return PApplet.parseFloat(text.substring(0, len)) * 3.543307F;
    if (text.endsWith("cm"))
      return PApplet.parseFloat(text.substring(0, len)) * 35.43307F;
    if (text.endsWith("in"))
      return PApplet.parseFloat(text.substring(0, len)) * 90.0F;
    if (text.endsWith("px"))
      return PApplet.parseFloat(text.substring(0, len));
    if (text.endsWith("%")) {
      return relativeTo * parseFloatOrPercent(text);
    }
    return PApplet.parseFloat(text);
  }
  

  protected static float parseFloatOrPercent(String text)
  {
    text = text.trim();
    if (text.endsWith("%")) {
      return Float.parseFloat(text.substring(0, text.length() - 1)) / 100.0F;
    }
    return Float.parseFloat(text);
  }
  

  public static class Gradient
    extends PShapeSVG
  {
    AffineTransform transform;
    
    public float[] offset;
    
    public int[] color;
    public int count;
    
    public Gradient(PShapeSVG parent, XML properties)
    {
      super(properties, true);
      
      XML[] elements = properties.getChildren();
      offset = new float[elements.length];
      color = new int[elements.length];
      

      for (int i = 0; i < elements.length; i++) {
        XML elem = elements[i];
        String name = elem.getName();
        if (name.equals("stop")) {
          String offsetAttr = elem.getString("offset");
          offset[count] = parseFloatOrPercent(offsetAttr);
          
          String style = elem.getString("style");
          
          StringDict styles = parseStyleAttributes(style);
          
          String colorStr = styles.get("stop-color");
          if (colorStr == null) {
            colorStr = elem.getString("stop-color");
            if (colorStr == null) colorStr = "#000000";
          }
          String opacityStr = styles.get("stop-opacity");
          if (opacityStr == null) {
            opacityStr = elem.getString("stop-opacity");
            if (opacityStr == null) opacityStr = "1";
          }
          int tupacity = PApplet.constrain(
            (int)(PApplet.parseFloat(opacityStr) * 255.0F), 0, 255);
          color[count] = (tupacity << 24 | parseSimpleColor(colorStr));
          count += 1;
        }
      }
      offset = PApplet.subset(offset, 0, count);
      color = PApplet.subset(color, 0, count);
    }
  }
  
  public class LinearGradient extends PShapeSVG.Gradient { public float x1;
    public float y1;
    public float x2;
    public float y2;
    
    public LinearGradient(PShapeSVG parent, XML properties) { super(properties);
      
      x1 = getFloatWithUnit(properties, "x1", svgWidth);
      y1 = getFloatWithUnit(properties, "y1", svgHeight);
      x2 = getFloatWithUnit(properties, "x2", svgWidth);
      y2 = getFloatWithUnit(properties, "y2", svgHeight);
      
      String transformStr = 
        properties.getString("gradientTransform");
      
      if (transformStr != null) {
        float[] t = parseTransform(transformStr).get(null);
        transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);
        
        Point2D t1 = transform.transform(new Point2D.Float(x1, y1), null);
        Point2D t2 = transform.transform(new Point2D.Float(x2, y2), null);
        
        x1 = ((float)t1.getX());
        y1 = ((float)t1.getY());
        x2 = ((float)t2.getX());
        y2 = ((float)t2.getY());
      }
    }
  }
  
  public class RadialGradient extends PShapeSVG.Gradient {
    public float cx;
    public float cy;
    public float r;
    
    public RadialGradient(PShapeSVG parent, XML properties) { super(properties);
      
      cx = getFloatWithUnit(properties, "cx", svgWidth);
      cy = getFloatWithUnit(properties, "cy", svgHeight);
      r = getFloatWithUnit(properties, "r", svgSizeXY);
      
      String transformStr = 
        properties.getString("gradientTransform");
      
      if (transformStr != null) {
        float[] t = parseTransform(transformStr).get(null);
        transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);
        
        Point2D t1 = transform.transform(new Point2D.Float(cx, cy), null);
        Point2D t2 = transform.transform(new Point2D.Float(cx + r, cy), null);
        
        cx = ((float)t1.getX());
        cy = ((float)t1.getY());
        r = ((float)(t2.getX() - t1.getX()));
      }
    }
  }
  

  public static class Font
    extends PShapeSVG
  {
    public PShapeSVG.FontFace face;
    
    public Map<String, PShapeSVG.FontGlyph> namedGlyphs;
    
    public Map<Character, PShapeSVG.FontGlyph> unicodeGlyphs;
    
    public int glyphCount;
    
    public PShapeSVG.FontGlyph[] glyphs;
    public PShapeSVG.FontGlyph missingGlyph;
    int horizAdvX;
    
    public Font(PShapeSVG parent, XML properties)
    {
      super(properties, false);
      

      XML[] elements = properties.getChildren();
      
      horizAdvX = properties.getInt("horiz-adv-x", 0);
      
      namedGlyphs = new HashMap();
      unicodeGlyphs = new HashMap();
      glyphCount = 0;
      glyphs = new PShapeSVG.FontGlyph[elements.length];
      
      for (int i = 0; i < elements.length; i++) {
        String name = elements[i].getName();
        XML elem = elements[i];
        if (name != null)
        {
          if (name.equals("glyph")) {
            PShapeSVG.FontGlyph fg = new PShapeSVG.FontGlyph(this, elem, this);
            if (fg.isLegit()) {
              if (name != null) {
                namedGlyphs.put(name, fg);
              }
              if (unicode != 0) {
                unicodeGlyphs.put(Character.valueOf(unicode), fg);
              }
            }
            glyphs[(glyphCount++)] = fg;
          }
          else if (name.equals("missing-glyph"))
          {
            missingGlyph = new PShapeSVG.FontGlyph(this, elem, this);
          } else if (name.equals("font-face")) {
            face = new PShapeSVG.FontFace(this, elem);
          } else {
            System.err.println("Ignoring " + name + " inside <font>");
          }
        }
      }
    }
    


    protected void drawShape() {}
    


    public void drawString(PGraphics g, String str, float x, float y, float size)
    {
      g.pushMatrix();
      float s = size / face.unitsPerEm;
      

      g.translate(x, y);
      g.scale(s, -s);
      char[] c = str.toCharArray();
      for (int i = 0; i < c.length; i++)
      {
        PShapeSVG.FontGlyph fg = (PShapeSVG.FontGlyph)unicodeGlyphs.get(Character.valueOf(c[i]));
        if (fg != null) {
          fg.draw(g);
          
          g.translate(horizAdvX, 0.0F);
        } else {
          System.err.println("'" + c[i] + "' not available.");
        }
      }
      g.popMatrix();
    }
    
    public void drawChar(PGraphics g, char c, float x, float y, float size)
    {
      g.pushMatrix();
      float s = size / face.unitsPerEm;
      g.translate(x, y);
      g.scale(s, -s);
      PShapeSVG.FontGlyph fg = (PShapeSVG.FontGlyph)unicodeGlyphs.get(Character.valueOf(c));
      if (fg != null) g.shape(fg);
      g.popMatrix();
    }
    
    public float textWidth(String str, float size)
    {
      float w = 0.0F;
      char[] c = str.toCharArray();
      for (int i = 0; i < c.length; i++)
      {
        PShapeSVG.FontGlyph fg = (PShapeSVG.FontGlyph)unicodeGlyphs.get(Character.valueOf(c[i]));
        if (fg != null) {
          w += horizAdvX / face.unitsPerEm;
        }
      }
      return w * size;
    }
  }
  

  static class FontFace
    extends PShapeSVG
  {
    int horizOriginX;
    
    int horizOriginY;
    
    int vertOriginX;
    
    int vertOriginY;
    
    int vertAdvY;
    String fontFamily;
    int fontWeight;
    String fontStretch;
    int unitsPerEm;
    int[] panose1;
    int ascent;
    int descent;
    int[] bbox;
    int underlineThickness;
    int underlinePosition;
    
    public FontFace(PShapeSVG parent, XML properties)
    {
      super(properties, true);
      
      unitsPerEm = properties.getInt("units-per-em", 1000);
    }
    

    protected void drawShape() {}
  }
  

  public static class FontGlyph
    extends PShapeSVG
  {
    public String name;
    
    char unicode;
    
    int horizAdvX;
    
    public FontGlyph(PShapeSVG parent, XML properties, PShapeSVG.Font font)
    {
      super(properties, true);
      super.parsePath();
      
      name = properties.getString("glyph-name");
      String u = properties.getString("unicode");
      unicode = '\000';
      if (u != null) {
        if (u.length() == 1) {
          unicode = u.charAt(0);
        }
        else {
          System.err.println("unicode for " + name + 
            " is more than one char: " + u);
        }
      }
      if (properties.hasAttribute("horiz-adv-x")) {
        horizAdvX = properties.getInt("horiz-adv-x");
      } else {
        horizAdvX = horizAdvX;
      }
    }
    
    protected boolean isLegit()
    {
      return vertexCount != 0;
    }
  }
  















  public PShape getChild(String name)
  {
    PShape found = super.getChild(name);
    if (found == null)
    {

      found = super.getChild(name.replace(' ', '_'));
    }
    
    if (found != null)
    {

      width = width;
      height = height;
    }
    return found;
  }
  



  public void print()
  {
    PApplet.println(element.toString());
  }
}
