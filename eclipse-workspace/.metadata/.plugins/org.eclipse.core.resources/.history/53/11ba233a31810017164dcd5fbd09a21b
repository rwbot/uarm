package jogamp.opengl.es3;

import com.jogamp.common.nio.Buffers;
import com.jogamp.common.nio.PointerBuffer;
import com.jogamp.opengl.GLArrayData;
import com.jogamp.opengl.GLBufferStorage;
import com.jogamp.opengl.GLException;
import com.jogamp.opengl.GLUniformData;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import jogamp.opengl.GLBufferObjectTracker;
import jogamp.opengl.GLBufferStateTracker;
import jogamp.opengl.GLContextImpl;

public class GLES3Impl implements com.jogamp.opengl.GLBase, com.jogamp.opengl.GL, com.jogamp.opengl.GL2ES2, com.jogamp.opengl.GLES2, com.jogamp.opengl.GL2ES3, com.jogamp.opengl.GL3ES3, com.jogamp.opengl.GL4ES3, com.jogamp.opengl.GLES3
{
  private static final int params_offset = 0;
  private static final int data_offset = 0;
  private final com.jogamp.opengl.GLProfile glProfile;
  private final GLContextImpl _context;
  private final jogamp.opengl.GLStateTracker glStateTracker;
  private final GLBufferObjectTracker bufferObjectTracker;
  private final GLBufferStateTracker bufferStateTracker;
  
  public void glActiveTexture(int paramInt)
  {
    long l = _pat._addressof_glActiveTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glActiveTexture" }));
    }
    dispatch_glActiveTexture1(paramInt, l);
  }
  

  private native void dispatch_glActiveTexture1(int paramInt, long paramLong);
  

  public void glAttachShader(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glAttachShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glAttachShader" }));
    }
    dispatch_glAttachShader1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glAttachShader1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindAttribLocation(int paramInt1, int paramInt2, String paramString)
  {
    long l = _pat._addressof_glBindAttribLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindAttribLocation" }));
    }
    dispatch_glBindAttribLocation1(paramInt1, paramInt2, paramString, l);
  }
  

  private native void dispatch_glBindAttribLocation1(int paramInt1, int paramInt2, String paramString, long paramLong);
  

  public void glBindBuffer(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindBuffer" }));
    }
    dispatch_glBindBuffer1(paramInt1, paramInt2, l);
    bufferStateTracker.setBoundBufferObject(paramInt1, paramInt2);
  }
  

  private native void dispatch_glBindBuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindFramebuffer(int paramInt1, int paramInt2)
  {
    if (0 == paramInt2) {
      if ((36160 == paramInt1) || (36009 == paramInt1)) {
        paramInt2 = _context.getDefaultDrawFramebuffer();
      } else if (36008 == paramInt1) {
        paramInt2 = _context.getDefaultReadFramebuffer();
      }
    }
    long l = _pat._addressof_glBindFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFramebuffer" }));
    }
    dispatch_glBindFramebuffer1(paramInt1, paramInt2, l);
    _context.setBoundFramebuffer(paramInt1, paramInt2);
  }
  

  private native void dispatch_glBindFramebuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindRenderbuffer(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindRenderbuffer" }));
    }
    dispatch_glBindRenderbuffer1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBindRenderbuffer1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindTexture(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindTexture" }));
    }
    dispatch_glBindTexture1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBindTexture1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendColor(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glBlendColor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendColor" }));
    }
    dispatch_glBlendColor1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glBlendColor1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glBlendEquation(int paramInt)
  {
    long l = _pat._addressof_glBlendEquation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquation" }));
    }
    dispatch_glBlendEquation1(paramInt, l);
  }
  

  private native void dispatch_glBlendEquation1(int paramInt, long paramLong);
  

  public void glBlendEquationSeparate(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendEquationSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationSeparate" }));
    }
    dispatch_glBlendEquationSeparate1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendEquationSeparate1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendFunc(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFunc" }));
    }
    dispatch_glBlendFunc1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendFunc1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendFuncSeparate(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glBlendFuncSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFuncSeparate" }));
    }
    dispatch_glBlendFuncSeparate1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  






  private native void dispatch_glBlendFuncSeparate1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  






  private void glBufferDataDelegate(int paramInt1, long paramLong, Buffer paramBuffer, int paramInt2)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glBufferData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBufferData" }));
    }
    dispatch_glBufferDataDelegate1(paramInt1, paramLong, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt2, l);
  }
  







  private native void dispatch_glBufferDataDelegate1(int paramInt1, long paramLong1, Object paramObject, int paramInt2, boolean paramBoolean, int paramInt3, long paramLong2);
  






  public void glBufferSubData(int paramInt, long paramLong1, long paramLong2, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glBufferSubData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBufferSubData" }));
    }
    dispatch_glBufferSubData1(paramInt, paramLong1, paramLong2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glBufferSubData1(int paramInt1, long paramLong1, long paramLong2, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong3);
  

  public int glCheckFramebufferStatus(int paramInt)
  {
    long l = _pat._addressof_glCheckFramebufferStatus;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCheckFramebufferStatus" }));
    }
    return dispatch_glCheckFramebufferStatus1(paramInt, l);
  }
  

  private native int dispatch_glCheckFramebufferStatus1(int paramInt, long paramLong);
  

  public void glClear(int paramInt)
  {
    long l = _pat._addressof_glClear;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClear" }));
    }
    dispatch_glClear1(paramInt, l);
  }
  

  private native void dispatch_glClear1(int paramInt, long paramLong);
  

  public void glClearColor(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glClearColor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearColor" }));
    }
    dispatch_glClearColor1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  

  private native void dispatch_glClearColor1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glClearDepthf(float paramFloat)
  {
    long l = _pat._addressof_glClearDepthf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearDepthf" }));
    }
    dispatch_glClearDepthf1(paramFloat, l);
  }
  

  private native void dispatch_glClearDepthf1(float paramFloat, long paramLong);
  

  public void glClearStencil(int paramInt)
  {
    long l = _pat._addressof_glClearStencil;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearStencil" }));
    }
    dispatch_glClearStencil1(paramInt, l);
  }
  

  private native void dispatch_glClearStencil1(int paramInt, long paramLong);
  

  public void glColorMask(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4)
  {
    long l = _pat._addressof_glColorMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorMask" }));
    }
    dispatch_glColorMask1(paramBoolean1, paramBoolean2, paramBoolean3, paramBoolean4, l);
  }
  

  private native void dispatch_glColorMask1(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4, long paramLong);
  

  public void glCompileShader(int paramInt)
  {
    long l = _pat._addressof_glCompileShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompileShader" }));
    }
    dispatch_glCompileShader1(paramInt, l);
  }
  


  private native void dispatch_glCompileShader1(int paramInt, long paramLong);
  

  public void glCompressedTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage2D" }));
    }
    dispatch_glCompressedTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Object paramObject, int paramInt8, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage2D" }));
    }
    dispatch_glCompressedTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramLong, l);
  }
  


  private native void dispatch_glCompressedTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong1, long paramLong2);
  

  public void glCompressedTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage2D" }));
    }
    dispatch_glCompressedTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage2D" }));
    }
    dispatch_glCompressedTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glCompressedTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glCopyTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    long l = _pat._addressof_glCopyTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTexImage2D" }));
    }
    dispatch_glCopyTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, l);
  }
  

  private native void dispatch_glCopyTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong);
  

  public void glCopyTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    long l = _pat._addressof_glCopyTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTexSubImage2D" }));
    }
    dispatch_glCopyTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, l);
  }
  

  private native void dispatch_glCopyTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong);
  

  public int glCreateProgram()
  {
    long l = _pat._addressof_glCreateProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCreateProgram" }));
    }
    return dispatch_glCreateProgram1(l);
  }
  

  private native int dispatch_glCreateProgram1(long paramLong);
  

  public int glCreateShader(int paramInt)
  {
    long l = _pat._addressof_glCreateShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCreateShader" }));
    }
    return dispatch_glCreateShader1(paramInt, l);
  }
  

  private native int dispatch_glCreateShader1(int paramInt, long paramLong);
  

  public void glCullFace(int paramInt)
  {
    long l = _pat._addressof_glCullFace;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCullFace" }));
    }
    dispatch_glCullFace1(paramInt, l);
  }
  


  private native void dispatch_glCullFace1(int paramInt, long paramLong);
  

  public void glDeleteBuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    bufferObjectTracker.notifyBuffersDeleted(paramInt, paramIntBuffer);
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteBuffers" }));
    }
    dispatch_glDeleteBuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteBuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteBuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    bufferObjectTracker.notifyBuffersDeleted(paramInt1, paramArrayOfInt, paramInt2);
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteBuffers" }));
    }
    dispatch_glDeleteBuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glDeleteFramebuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteFramebuffers" }));
    }
    dispatch_glDeleteFramebuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteFramebuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteFramebuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteFramebuffers" }));
    }
    dispatch_glDeleteFramebuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glDeleteProgram(int paramInt)
  {
    long l = _pat._addressof_glDeleteProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteProgram" }));
    }
    dispatch_glDeleteProgram1(paramInt, l);
  }
  


  private native void dispatch_glDeleteProgram1(int paramInt, long paramLong);
  

  public void glDeleteRenderbuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteRenderbuffers" }));
    }
    dispatch_glDeleteRenderbuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteRenderbuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteRenderbuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteRenderbuffers" }));
    }
    dispatch_glDeleteRenderbuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glDeleteShader(int paramInt)
  {
    long l = _pat._addressof_glDeleteShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteShader" }));
    }
    dispatch_glDeleteShader1(paramInt, l);
  }
  


  private native void dispatch_glDeleteShader1(int paramInt, long paramLong);
  

  public void glDeleteTextures(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTextures" }));
    }
    dispatch_glDeleteTextures1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteTextures1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteTextures(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTextures" }));
    }
    dispatch_glDeleteTextures1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glDepthFunc(int paramInt)
  {
    long l = _pat._addressof_glDepthFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthFunc" }));
    }
    dispatch_glDepthFunc1(paramInt, l);
  }
  

  private native void dispatch_glDepthFunc1(int paramInt, long paramLong);
  

  public void glDepthMask(boolean paramBoolean)
  {
    long l = _pat._addressof_glDepthMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthMask" }));
    }
    dispatch_glDepthMask1(paramBoolean, l);
  }
  

  private native void dispatch_glDepthMask1(boolean paramBoolean, long paramLong);
  

  public void glDepthRangef(float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glDepthRangef;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangef" }));
    }
    dispatch_glDepthRangef1(paramFloat1, paramFloat2, l);
  }
  

  private native void dispatch_glDepthRangef1(float paramFloat1, float paramFloat2, long paramLong);
  

  public void glDetachShader(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDetachShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDetachShader" }));
    }
    dispatch_glDetachShader1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDetachShader1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisable(int paramInt)
  {
    long l = _pat._addressof_glDisable;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisable" }));
    }
    dispatch_glDisable1(paramInt, l);
  }
  

  private native void dispatch_glDisable1(int paramInt, long paramLong);
  

  public void glDisableVertexAttribArray(int paramInt)
  {
    long l = _pat._addressof_glDisableVertexAttribArray;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableVertexAttribArray" }));
    }
    dispatch_glDisableVertexAttribArray1(paramInt, l);
  }
  

  private native void dispatch_glDisableVertexAttribArray1(int paramInt, long paramLong);
  

  public void glDrawArrays(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glDrawArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArrays" }));
    }
    dispatch_glDrawArrays1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glDrawArrays1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glDrawElements(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElements" }));
    }
    dispatch_glDrawElements1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glDrawElements1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glDrawElements(int paramInt1, int paramInt2, int paramInt3, long paramLong)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElements" }));
    }
    dispatch_glDrawElements1(paramInt1, paramInt2, paramInt3, paramLong, l);
  }
  

  private native void dispatch_glDrawElements1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2);
  

  public void glEnable(int paramInt)
  {
    long l = _pat._addressof_glEnable;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnable" }));
    }
    dispatch_glEnable1(paramInt, l);
  }
  

  private native void dispatch_glEnable1(int paramInt, long paramLong);
  

  public void glEnableVertexAttribArray(int paramInt)
  {
    long l = _pat._addressof_glEnableVertexAttribArray;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableVertexAttribArray" }));
    }
    dispatch_glEnableVertexAttribArray1(paramInt, l);
  }
  

  private native void dispatch_glEnableVertexAttribArray1(int paramInt, long paramLong);
  

  public void glFinish()
  {
    long l = _pat._addressof_glFinish;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFinish" }));
    }
    dispatch_glFinish1(l);
  }
  

  private native void dispatch_glFinish1(long paramLong);
  

  public void glFlush()
  {
    long l = _pat._addressof_glFlush;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFlush" }));
    }
    dispatch_glFlush1(l);
  }
  

  private native void dispatch_glFlush1(long paramLong);
  

  public void glFramebufferRenderbuffer(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glFramebufferRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferRenderbuffer" }));
    }
    dispatch_glFramebufferRenderbuffer1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glFramebufferRenderbuffer1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glFramebufferTexture2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glFramebufferTexture2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2D" }));
    }
    dispatch_glFramebufferTexture2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glFramebufferTexture2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFrontFace(int paramInt)
  {
    long l = _pat._addressof_glFrontFace;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFrontFace" }));
    }
    dispatch_glFrontFace1(paramInt, l);
  }
  


  private native void dispatch_glFrontFace1(int paramInt, long paramLong);
  

  public void glGenBuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenBuffers" }));
    }
    dispatch_glGenBuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenBuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenBuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenBuffers" }));
    }
    dispatch_glGenBuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public void glGenerateMipmap(int paramInt)
  {
    long l = _pat._addressof_glGenerateMipmap;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenerateMipmap" }));
    }
    dispatch_glGenerateMipmap1(paramInt, l);
  }
  


  private native void dispatch_glGenerateMipmap1(int paramInt, long paramLong);
  

  public void glGenFramebuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenFramebuffers" }));
    }
    dispatch_glGenFramebuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenFramebuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenFramebuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenFramebuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenFramebuffers" }));
    }
    dispatch_glGenFramebuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenRenderbuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenRenderbuffers" }));
    }
    dispatch_glGenRenderbuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenRenderbuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenRenderbuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenRenderbuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenRenderbuffers" }));
    }
    dispatch_glGenRenderbuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenTextures(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTextures" }));
    }
    dispatch_glGenTextures1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenTextures1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenTextures(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenTextures;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTextures" }));
    }
    dispatch_glGenTextures1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  





  public void glGetActiveAttrib(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2, IntBuffer paramIntBuffer3, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramIntBuffer3);
    boolean bool4 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetActiveAttrib;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveAttrib" }));
    }
    dispatch_glGetActiveAttrib1(paramInt1, paramInt2, paramInt3, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramIntBuffer3 : Buffers.getArray(paramIntBuffer3), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer3) : Buffers.getIndirectBufferByteOffset(paramIntBuffer3), bool3, bool4 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool4 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool4, l);
  }
  



  private native void dispatch_glGetActiveAttrib1(int paramInt1, int paramInt2, int paramInt3, Object paramObject1, int paramInt4, boolean paramBoolean1, Object paramObject2, int paramInt5, boolean paramBoolean2, Object paramObject3, int paramInt6, boolean paramBoolean3, Object paramObject4, int paramInt7, boolean paramBoolean4, long paramLong);
  



  public void glGetActiveAttrib(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt1, int paramInt4, int[] paramArrayOfInt2, int paramInt5, int[] paramArrayOfInt3, int paramInt6, byte[] paramArrayOfByte, int paramInt7)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"size_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    if ((paramArrayOfInt3 != null) && (paramArrayOfInt3.length <= paramInt6))
      throw new GLException("array offset argument \"type_offset\" (" + paramInt6 + ") equals or exceeds array length (" + paramArrayOfInt3.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt7))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt7 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetActiveAttrib;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveAttrib" }));
    }
    dispatch_glGetActiveAttrib1(paramInt1, paramInt2, paramInt3, paramArrayOfInt1, 4 * paramInt4, false, paramArrayOfInt2, 4 * paramInt5, false, paramArrayOfInt3, 4 * paramInt6, false, paramArrayOfByte, paramInt7, false, l);
  }
  





  public void glGetActiveUniform(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2, IntBuffer paramIntBuffer3, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramIntBuffer3);
    boolean bool4 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetActiveUniform;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniform" }));
    }
    dispatch_glGetActiveUniform1(paramInt1, paramInt2, paramInt3, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramIntBuffer3 : Buffers.getArray(paramIntBuffer3), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer3) : Buffers.getIndirectBufferByteOffset(paramIntBuffer3), bool3, bool4 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool4 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool4, l);
  }
  



  private native void dispatch_glGetActiveUniform1(int paramInt1, int paramInt2, int paramInt3, Object paramObject1, int paramInt4, boolean paramBoolean1, Object paramObject2, int paramInt5, boolean paramBoolean2, Object paramObject3, int paramInt6, boolean paramBoolean3, Object paramObject4, int paramInt7, boolean paramBoolean4, long paramLong);
  



  public void glGetActiveUniform(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt1, int paramInt4, int[] paramArrayOfInt2, int paramInt5, int[] paramArrayOfInt3, int paramInt6, byte[] paramArrayOfByte, int paramInt7)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"size_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    if ((paramArrayOfInt3 != null) && (paramArrayOfInt3.length <= paramInt6))
      throw new GLException("array offset argument \"type_offset\" (" + paramInt6 + ") equals or exceeds array length (" + paramArrayOfInt3.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt7))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt7 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetActiveUniform;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniform" }));
    }
    dispatch_glGetActiveUniform1(paramInt1, paramInt2, paramInt3, paramArrayOfInt1, 4 * paramInt4, false, paramArrayOfInt2, 4 * paramInt5, false, paramArrayOfInt3, 4 * paramInt6, false, paramArrayOfByte, paramInt7, false, l);
  }
  



  public void glGetAttachedShaders(int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetAttachedShaders;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetAttachedShaders" }));
    }
    dispatch_glGetAttachedShaders1(paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetAttachedShaders1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetAttachedShaders(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int[] paramArrayOfInt2, int paramInt4)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"count_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt4))
      throw new GLException("array offset argument \"shaders_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetAttachedShaders;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetAttachedShaders" }));
    }
    dispatch_glGetAttachedShaders1(paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramArrayOfInt2, 4 * paramInt4, false, l);
  }
  

  public int glGetAttribLocation(int paramInt, String paramString)
  {
    long l = _pat._addressof_glGetAttribLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetAttribLocation" }));
    }
    return dispatch_glGetAttribLocation1(paramInt, paramString, l);
  }
  


  private native int dispatch_glGetAttribLocation1(int paramInt, String paramString, long paramLong);
  

  public void glGetBooleanv(int paramInt, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetBooleanv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleanv" }));
    }
    dispatch_glGetBooleanv1(paramInt, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glGetBooleanv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetBooleanv(int paramInt1, byte[] paramArrayOfByte, int paramInt2)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt2))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetBooleanv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleanv" }));
    }
    dispatch_glGetBooleanv1(paramInt1, paramArrayOfByte, paramInt2, false, l);
  }
  


  public void glGetBufferParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetBufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteriv" }));
    }
    dispatch_glGetBufferParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetBufferParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetBufferParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetBufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteriv" }));
    }
    dispatch_glGetBufferParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public int glGetError()
  {
    long l = _pat._addressof_glGetError;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetError" }));
    }
    return dispatch_glGetError1(l);
  }
  


  private native int dispatch_glGetError1(long paramLong);
  

  public void glGetFloatv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetFloatv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloatv" }));
    }
    dispatch_glGetFloatv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetFloatv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetFloatv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetFloatv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloatv" }));
    }
    dispatch_glGetFloatv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glGetFramebufferAttachmentParameteriv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferAttachmentParameteriv" }));
    }
    dispatch_glGetFramebufferAttachmentParameteriv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetFramebufferAttachmentParameteriv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferAttachmentParameteriv" }));
    }
    dispatch_glGetFramebufferAttachmentParameteriv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glGetIntegerv(int paramInt, IntBuffer paramIntBuffer)
  {
    if (glStateTracker.getInt(paramInt, paramIntBuffer, 0)) return;
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetIntegerv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegerv" }));
    }
    dispatch_glGetIntegerv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetIntegerv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetIntegerv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if (glStateTracker.getInt(paramInt1, paramArrayOfInt, paramInt2)) return;
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetIntegerv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegerv" }));
    }
    dispatch_glGetIntegerv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGetProgramiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetProgramiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramiv" }));
    }
    dispatch_glGetProgramiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetProgramiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetProgramiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetProgramiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramiv" }));
    }
    dispatch_glGetProgramiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  



  public void glGetProgramInfoLog(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramInfoLog" }));
    }
    dispatch_glGetProgramInfoLog1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetProgramInfoLog1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetProgramInfoLog(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"infoLog_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramInfoLog" }));
    }
    dispatch_glGetProgramInfoLog1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  


  public void glGetRenderbufferParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetRenderbufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetRenderbufferParameteriv" }));
    }
    dispatch_glGetRenderbufferParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetRenderbufferParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetRenderbufferParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetRenderbufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetRenderbufferParameteriv" }));
    }
    dispatch_glGetRenderbufferParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetShaderiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetShaderiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderiv" }));
    }
    dispatch_glGetShaderiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetShaderiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetShaderiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetShaderiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderiv" }));
    }
    dispatch_glGetShaderiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  



  public void glGetShaderInfoLog(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetShaderInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderInfoLog" }));
    }
    dispatch_glGetShaderInfoLog1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetShaderInfoLog1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetShaderInfoLog(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"infoLog_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetShaderInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderInfoLog" }));
    }
    dispatch_glGetShaderInfoLog1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  



  public void glGetShaderPrecisionFormat(int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2)
  {
    if (!_context.isGLES2Compatible()) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetShaderPrecisionFormat;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderPrecisionFormat" }));
    }
    dispatch_glGetShaderPrecisionFormat1(paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetShaderPrecisionFormat1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetShaderPrecisionFormat(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int[] paramArrayOfInt2, int paramInt4)
  {
    if (!_context.isGLES2Compatible()) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"range_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt4))
      throw new GLException("array offset argument \"precision_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetShaderPrecisionFormat;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderPrecisionFormat" }));
    }
    dispatch_glGetShaderPrecisionFormat1(paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramArrayOfInt2, 4 * paramInt4, false, l);
  }
  



  public void glGetShaderSource(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetShaderSource;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderSource" }));
    }
    dispatch_glGetShaderSource1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetShaderSource1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetShaderSource(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"source_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetShaderSource;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetShaderSource" }));
    }
    dispatch_glGetShaderSource1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  

  public String glGetString(int paramInt)
  {
    if ((_context.isExtensionCacheInitialized()) && 
      (7939 == paramInt)) {
      return _context.getGLExtensionsString();
    }
    


    long l = _pat._addressof_glGetString;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetString" }));
    }
    return dispatch_glGetString1(paramInt, l);
  }
  


  private native String dispatch_glGetString1(int paramInt, long paramLong);
  

  public void glGetTexParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterfv" }));
    }
    dispatch_glGetTexParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterfv" }));
    }
    dispatch_glGetTexParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameteriv" }));
    }
    dispatch_glGetTexParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameteriv" }));
    }
    dispatch_glGetTexParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetUniformfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformfv" }));
    }
    dispatch_glGetUniformfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetUniformfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetUniformfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformfv" }));
    }
    dispatch_glGetUniformfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetUniformiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformiv" }));
    }
    dispatch_glGetUniformiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetUniformiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetUniformiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformiv" }));
    }
    dispatch_glGetUniformiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public int glGetUniformLocation(int paramInt, String paramString)
  {
    long l = _pat._addressof_glGetUniformLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformLocation" }));
    }
    return dispatch_glGetUniformLocation1(paramInt, paramString, l);
  }
  


  private native int dispatch_glGetUniformLocation1(int paramInt, String paramString, long paramLong);
  

  public void glGetVertexAttribfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetVertexAttribfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribfv" }));
    }
    dispatch_glGetVertexAttribfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetVertexAttribfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetVertexAttribfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetVertexAttribfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribfv" }));
    }
    dispatch_glGetVertexAttribfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetVertexAttribiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetVertexAttribiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribiv" }));
    }
    dispatch_glGetVertexAttribiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetVertexAttribiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetVertexAttribiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetVertexAttribiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribiv" }));
    }
    dispatch_glGetVertexAttribiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glHint(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glHint;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glHint" }));
    }
    dispatch_glHint1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glHint1(int paramInt1, int paramInt2, long paramLong);
  

  public boolean glIsBuffer(int paramInt)
  {
    long l = _pat._addressof_glIsBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsBuffer" }));
    }
    return dispatch_glIsBuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsBuffer1(int paramInt, long paramLong);
  

  public boolean glIsEnabled(int paramInt)
  {
    long l = _pat._addressof_glIsEnabled;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnabled" }));
    }
    return dispatch_glIsEnabled1(paramInt, l);
  }
  

  private native boolean dispatch_glIsEnabled1(int paramInt, long paramLong);
  

  public boolean glIsFramebuffer(int paramInt)
  {
    long l = _pat._addressof_glIsFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsFramebuffer" }));
    }
    return dispatch_glIsFramebuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsFramebuffer1(int paramInt, long paramLong);
  

  public boolean glIsProgram(int paramInt)
  {
    long l = _pat._addressof_glIsProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsProgram" }));
    }
    return dispatch_glIsProgram1(paramInt, l);
  }
  

  private native boolean dispatch_glIsProgram1(int paramInt, long paramLong);
  

  public boolean glIsRenderbuffer(int paramInt)
  {
    long l = _pat._addressof_glIsRenderbuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsRenderbuffer" }));
    }
    return dispatch_glIsRenderbuffer1(paramInt, l);
  }
  

  private native boolean dispatch_glIsRenderbuffer1(int paramInt, long paramLong);
  

  public boolean glIsShader(int paramInt)
  {
    long l = _pat._addressof_glIsShader;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsShader" }));
    }
    return dispatch_glIsShader1(paramInt, l);
  }
  

  private native boolean dispatch_glIsShader1(int paramInt, long paramLong);
  

  public boolean glIsTexture(int paramInt)
  {
    long l = _pat._addressof_glIsTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsTexture" }));
    }
    return dispatch_glIsTexture1(paramInt, l);
  }
  

  private native boolean dispatch_glIsTexture1(int paramInt, long paramLong);
  

  public void glLineWidth(float paramFloat)
  {
    long l = _pat._addressof_glLineWidth;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLineWidth" }));
    }
    dispatch_glLineWidth1(paramFloat, l);
  }
  

  private native void dispatch_glLineWidth1(float paramFloat, long paramLong);
  

  public void glLinkProgram(int paramInt)
  {
    long l = _pat._addressof_glLinkProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glLinkProgram" }));
    }
    dispatch_glLinkProgram1(paramInt, l);
  }
  

  private native void dispatch_glLinkProgram1(int paramInt, long paramLong);
  

  public void glPixelStorei(int paramInt1, int paramInt2)
  {
    glStateTracker.setInt(paramInt1, paramInt2);
    long l = _pat._addressof_glPixelStorei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPixelStorei" }));
    }
    dispatch_glPixelStorei1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPixelStorei1(int paramInt1, int paramInt2, long paramLong);
  

  public void glPolygonOffset(float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glPolygonOffset;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPolygonOffset" }));
    }
    dispatch_glPolygonOffset1(paramFloat1, paramFloat2, l);
  }
  


  private native void dispatch_glPolygonOffset1(float paramFloat1, float paramFloat2, long paramLong);
  

  public void glReadPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, Buffer paramBuffer)
  {
    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt5, paramInt6, paramInt3, paramInt4, 1, true));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glReadPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadPixels" }));
    }
    dispatch_glReadPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glReadPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, Object paramObject, int paramInt7, boolean paramBoolean, long paramLong);
  

  public void glReadPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong)
  {
    checkPackPBOBound(true);
    long l = _pat._addressof_glReadPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadPixels" }));
    }
    dispatch_glReadPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramLong, l);
  }
  

  private native void dispatch_glReadPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong1, long paramLong2);
  

  public void glReleaseShaderCompiler()
  {
    if (!_context.isGLES2Compatible()) {
      return;
    }
    long l = _pat._addressof_glReleaseShaderCompiler;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReleaseShaderCompiler" }));
    }
    dispatch_glReleaseShaderCompiler1(l);
  }
  

  private native void dispatch_glReleaseShaderCompiler1(long paramLong);
  

  public void glRenderbufferStorage(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glRenderbufferStorage;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorage" }));
    }
    dispatch_glRenderbufferStorage1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glRenderbufferStorage1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glSampleCoverage(float paramFloat, boolean paramBoolean)
  {
    long l = _pat._addressof_glSampleCoverage;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSampleCoverage" }));
    }
    dispatch_glSampleCoverage1(paramFloat, paramBoolean, l);
  }
  

  private native void dispatch_glSampleCoverage1(float paramFloat, boolean paramBoolean, long paramLong);
  

  public void glScissor(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glScissor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissor" }));
    }
    dispatch_glScissor1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glScissor1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  


  public void glShaderBinary(int paramInt1, IntBuffer paramIntBuffer, int paramInt2, Buffer paramBuffer, int paramInt3)
  {
    if (!_context.isGLES2Compatible()) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glShaderBinary;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glShaderBinary" }));
    }
    dispatch_glShaderBinary1(paramInt1, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, paramInt2, bool2 ? paramBuffer : Buffers.getArray(paramBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool2, paramInt3, l);
  }
  



  private native void dispatch_glShaderBinary1(int paramInt1, Object paramObject1, int paramInt2, boolean paramBoolean1, int paramInt3, Object paramObject2, int paramInt4, boolean paramBoolean2, int paramInt5, long paramLong);
  


  public void glShaderBinary(int paramInt1, int[] paramArrayOfInt, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    if (!_context.isGLES2Compatible()) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"shaders_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glShaderBinary;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glShaderBinary" }));
    }
    dispatch_glShaderBinary1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  public void glShaderSource(int paramInt1, int paramInt2, String[] paramArrayOfString, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glShaderSource;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glShaderSource" }));
    }
    dispatch_glShaderSource1(paramInt1, paramInt2, paramArrayOfString, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glShaderSource1(int paramInt1, int paramInt2, String[] paramArrayOfString, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glShaderSource(int paramInt1, int paramInt2, String[] paramArrayOfString, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glShaderSource;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glShaderSource" }));
    }
    dispatch_glShaderSource1(paramInt1, paramInt2, paramArrayOfString, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glStencilFunc(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glStencilFunc;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilFunc" }));
    }
    dispatch_glStencilFunc1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glStencilFunc1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glStencilFuncSeparate(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glStencilFuncSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilFuncSeparate" }));
    }
    dispatch_glStencilFuncSeparate1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glStencilFuncSeparate1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glStencilMask(int paramInt)
  {
    long l = _pat._addressof_glStencilMask;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilMask" }));
    }
    dispatch_glStencilMask1(paramInt, l);
  }
  

  private native void dispatch_glStencilMask1(int paramInt, long paramLong);
  

  public void glStencilMaskSeparate(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glStencilMaskSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilMaskSeparate" }));
    }
    dispatch_glStencilMaskSeparate1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glStencilMaskSeparate1(int paramInt1, int paramInt2, long paramLong);
  

  public void glStencilOp(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glStencilOp;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilOp" }));
    }
    dispatch_glStencilOp1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glStencilOp1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glStencilOpSeparate(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glStencilOpSeparate;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStencilOpSeparate" }));
    }
    dispatch_glStencilOpSeparate1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glStencilOpSeparate1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt7, paramInt8, paramInt4, paramInt5, 1, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage2D" }));
    }
    dispatch_glTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glTexImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage2D" }));
    }
    dispatch_glTexImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glTexImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glTexParameterf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glTexParameterf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterf" }));
    }
    dispatch_glTexParameterf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glTexParameterf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glTexParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterfv" }));
    }
    dispatch_glTexParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glTexParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterfv" }));
    }
    dispatch_glTexParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glTexParameteri(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteri" }));
    }
    dispatch_glTexParameteri1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glTexParameteri1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteriv" }));
    }
    dispatch_glTexParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameteriv" }));
    }
    dispatch_glTexParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt7, paramInt8, paramInt5, paramInt6, 1, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage2D" }));
    }
    dispatch_glTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glTexSubImage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexSubImage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage2D" }));
    }
    dispatch_glTexSubImage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  

  private native void dispatch_glTexSubImage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glUniform1f(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glUniform1f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1f" }));
    }
    dispatch_glUniform1f1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glUniform1f1(int paramInt, float paramFloat, long paramLong);
  

  public void glUniform1fv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniform1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1fv" }));
    }
    dispatch_glUniform1fv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniform1fv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform1fv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniform1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1fv" }));
    }
    dispatch_glUniform1fv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glUniform1i(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glUniform1i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1i" }));
    }
    dispatch_glUniform1i1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glUniform1i1(int paramInt1, int paramInt2, long paramLong);
  

  public void glUniform1iv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform1iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1iv" }));
    }
    dispatch_glUniform1iv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform1iv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform1iv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform1iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1iv" }));
    }
    dispatch_glUniform1iv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glUniform2f(int paramInt, float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glUniform2f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2f" }));
    }
    dispatch_glUniform2f1(paramInt, paramFloat1, paramFloat2, l);
  }
  


  private native void dispatch_glUniform2f1(int paramInt, float paramFloat1, float paramFloat2, long paramLong);
  

  public void glUniform2fv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniform2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2fv" }));
    }
    dispatch_glUniform2fv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniform2fv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform2fv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniform2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2fv" }));
    }
    dispatch_glUniform2fv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glUniform2i(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glUniform2i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2i" }));
    }
    dispatch_glUniform2i1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glUniform2i1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glUniform2iv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform2iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2iv" }));
    }
    dispatch_glUniform2iv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform2iv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform2iv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform2iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2iv" }));
    }
    dispatch_glUniform2iv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glUniform3f(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glUniform3f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3f" }));
    }
    dispatch_glUniform3f1(paramInt, paramFloat1, paramFloat2, paramFloat3, l);
  }
  


  private native void dispatch_glUniform3f1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glUniform3fv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniform3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3fv" }));
    }
    dispatch_glUniform3fv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniform3fv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform3fv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniform3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3fv" }));
    }
    dispatch_glUniform3fv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glUniform3i(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glUniform3i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3i" }));
    }
    dispatch_glUniform3i1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glUniform3i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glUniform3iv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform3iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3iv" }));
    }
    dispatch_glUniform3iv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform3iv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform3iv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform3iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3iv" }));
    }
    dispatch_glUniform3iv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glUniform4f(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glUniform4f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4f" }));
    }
    dispatch_glUniform4f1(paramInt, paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  


  private native void dispatch_glUniform4f1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glUniform4fv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniform4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4fv" }));
    }
    dispatch_glUniform4fv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniform4fv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform4fv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniform4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4fv" }));
    }
    dispatch_glUniform4fv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glUniform4i(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glUniform4i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4i" }));
    }
    dispatch_glUniform4i1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glUniform4i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glUniform4iv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4iv" }));
    }
    dispatch_glUniform4iv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform4iv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform4iv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4iv" }));
    }
    dispatch_glUniform4iv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix2fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2fv" }));
    }
    dispatch_glUniformMatrix2fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix2fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix2fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2fv" }));
    }
    dispatch_glUniformMatrix2fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix3fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3fv" }));
    }
    dispatch_glUniformMatrix3fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix3fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix3fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3fv" }));
    }
    dispatch_glUniformMatrix3fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix4fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4fv" }));
    }
    dispatch_glUniformMatrix4fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix4fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix4fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4fv" }));
    }
    dispatch_glUniformMatrix4fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glUseProgram(int paramInt)
  {
    long l = _pat._addressof_glUseProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUseProgram" }));
    }
    dispatch_glUseProgram1(paramInt, l);
  }
  

  private native void dispatch_glUseProgram1(int paramInt, long paramLong);
  

  public void glValidateProgram(int paramInt)
  {
    long l = _pat._addressof_glValidateProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glValidateProgram" }));
    }
    dispatch_glValidateProgram1(paramInt, l);
  }
  

  private native void dispatch_glValidateProgram1(int paramInt, long paramLong);
  

  public void glVertexAttrib1f(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glVertexAttrib1f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib1f" }));
    }
    dispatch_glVertexAttrib1f1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glVertexAttrib1f1(int paramInt, float paramFloat, long paramLong);
  

  public void glVertexAttrib1fv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glVertexAttrib1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib1fv" }));
    }
    dispatch_glVertexAttrib1fv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttrib1fv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttrib1fv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glVertexAttrib1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib1fv" }));
    }
    dispatch_glVertexAttrib1fv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glVertexAttrib2f(int paramInt, float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glVertexAttrib2f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib2f" }));
    }
    dispatch_glVertexAttrib2f1(paramInt, paramFloat1, paramFloat2, l);
  }
  


  private native void dispatch_glVertexAttrib2f1(int paramInt, float paramFloat1, float paramFloat2, long paramLong);
  

  public void glVertexAttrib2fv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glVertexAttrib2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib2fv" }));
    }
    dispatch_glVertexAttrib2fv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttrib2fv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttrib2fv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glVertexAttrib2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib2fv" }));
    }
    dispatch_glVertexAttrib2fv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glVertexAttrib3f(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glVertexAttrib3f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib3f" }));
    }
    dispatch_glVertexAttrib3f1(paramInt, paramFloat1, paramFloat2, paramFloat3, l);
  }
  


  private native void dispatch_glVertexAttrib3f1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glVertexAttrib3fv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glVertexAttrib3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib3fv" }));
    }
    dispatch_glVertexAttrib3fv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttrib3fv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttrib3fv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glVertexAttrib3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib3fv" }));
    }
    dispatch_glVertexAttrib3fv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glVertexAttrib4f(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glVertexAttrib4f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib4f" }));
    }
    dispatch_glVertexAttrib4f1(paramInt, paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  


  private native void dispatch_glVertexAttrib4f1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glVertexAttrib4fv(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glVertexAttrib4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib4fv" }));
    }
    dispatch_glVertexAttrib4fv1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttrib4fv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttrib4fv(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glVertexAttrib4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttrib4fv" }));
    }
    dispatch_glVertexAttrib4fv1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glVertexAttribPointer(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glVertexAttribPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribPointer" }));
    }
    dispatch_glVertexAttribPointer0(paramInt1, paramInt2, paramInt3, paramBoolean, paramInt4, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glVertexAttribPointer0(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, Object paramObject, int paramInt5, long paramLong);
  

  public void glVertexAttribPointer(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glVertexAttribPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribPointer" }));
    }
    dispatch_glVertexAttribPointer0(paramInt1, paramInt2, paramInt3, paramBoolean, paramInt4, paramLong, l);
  }
  

  private native void dispatch_glVertexAttribPointer0(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, long paramLong1, long paramLong2);
  

  public void glViewport(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glViewport;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewport" }));
    }
    dispatch_glViewport1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glViewport1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glReadBuffer(int paramInt)
  {
    long l = _pat._addressof_glReadBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadBuffer" }));
    }
    dispatch_glReadBuffer1(paramInt, l);
  }
  


  private native void dispatch_glReadBuffer1(int paramInt, long paramLong);
  

  public void glDrawRangeElements(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Buffer paramBuffer)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt4);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawRangeElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElements" }));
    }
    dispatch_glDrawRangeElements1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glDrawRangeElements1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Object paramObject, int paramInt6, boolean paramBoolean, long paramLong);
  

  public void glDrawRangeElements(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawRangeElements;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElements" }));
    }
    dispatch_glDrawRangeElements1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramLong, l);
  }
  


  private native void dispatch_glDrawRangeElements1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong1, long paramLong2);
  

  public void glTexImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt8, paramInt9, paramInt4, paramInt5, paramInt6, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage3D" }));
    }
    dispatch_glTexImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, Object paramObject, int paramInt10, boolean paramBoolean, long paramLong);
  

  public void glTexImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage3D" }));
    }
    dispatch_glTexImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramLong, l);
  }
  


  private native void dispatch_glTexImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, long paramLong1, long paramLong2);
  

  public void glTexSubImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(paramBuffer, imageSizeInBytes(paramInt9, paramInt10, paramInt6, paramInt7, paramInt8, false));
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glTexSubImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage3D" }));
    }
    dispatch_glTexSubImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glTexSubImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Object paramObject, int paramInt11, boolean paramBoolean, long paramLong);
  

  public void glTexSubImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glTexSubImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexSubImage3D" }));
    }
    dispatch_glTexSubImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, paramLong, l);
  }
  

  private native void dispatch_glTexSubImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong1, long paramLong2);
  

  public void glCopyTexSubImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9)
  {
    long l = _pat._addressof_glCopyTexSubImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTexSubImage3D" }));
    }
    dispatch_glCopyTexSubImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, l);
  }
  


  private native void dispatch_glCopyTexSubImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, long paramLong);
  

  public void glCompressedTexImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage3D" }));
    }
    dispatch_glCompressedTexImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, Object paramObject, int paramInt9, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexImage3D" }));
    }
    dispatch_glCompressedTexImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramLong, l);
  }
  


  private native void dispatch_glCompressedTexImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong1, long paramLong2);
  

  public void glCompressedTexSubImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Buffer paramBuffer)
  {
    checkUnpackPBOUnbound(true);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glCompressedTexSubImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage3D" }));
    }
    dispatch_glCompressedTexSubImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glCompressedTexSubImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Object paramObject, int paramInt11, boolean paramBoolean, long paramLong);
  

  public void glCompressedTexSubImage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong)
  {
    checkUnpackPBOBound(true);
    long l = _pat._addressof_glCompressedTexSubImage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCompressedTexSubImage3D" }));
    }
    dispatch_glCompressedTexSubImage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, paramLong, l);
  }
  


  private native void dispatch_glCompressedTexSubImage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong1, long paramLong2);
  

  public void glGenQueries(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenQueries;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenQueries" }));
    }
    dispatch_glGenQueries1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenQueries1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenQueries(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenQueries;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenQueries" }));
    }
    dispatch_glGenQueries1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glDeleteQueries(int paramInt, IntBuffer paramIntBuffer)
  {
    Buffers.rangeCheck(paramIntBuffer, paramInt);
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteQueries;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteQueries" }));
    }
    dispatch_glDeleteQueries1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteQueries1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteQueries(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    Buffers.rangeCheck(paramArrayOfInt, paramInt2, paramInt1);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteQueries;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteQueries" }));
    }
    dispatch_glDeleteQueries1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsQuery(int paramInt)
  {
    long l = _pat._addressof_glIsQuery;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsQuery" }));
    }
    return dispatch_glIsQuery1(paramInt, l);
  }
  

  private native boolean dispatch_glIsQuery1(int paramInt, long paramLong);
  

  public void glBeginQuery(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBeginQuery;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBeginQuery" }));
    }
    dispatch_glBeginQuery1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBeginQuery1(int paramInt1, int paramInt2, long paramLong);
  

  public void glEndQuery(int paramInt)
  {
    long l = _pat._addressof_glEndQuery;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEndQuery" }));
    }
    dispatch_glEndQuery1(paramInt, l);
  }
  


  private native void dispatch_glEndQuery1(int paramInt, long paramLong);
  

  public void glGetQueryiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetQueryiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryiv" }));
    }
    dispatch_glGetQueryiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetQueryiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetQueryiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetQueryiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryiv" }));
    }
    dispatch_glGetQueryiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetQueryObjectuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetQueryObjectuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectuiv" }));
    }
    dispatch_glGetQueryObjectuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetQueryObjectuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetQueryObjectuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetQueryObjectuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectuiv" }));
    }
    dispatch_glGetQueryObjectuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  private boolean glUnmapBufferDelegate(int paramInt)
  {
    long l = _pat._addressof_glUnmapBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUnmapBuffer" }));
    }
    return dispatch_glUnmapBufferDelegate1(paramInt, l);
  }
  


  private native boolean dispatch_glUnmapBufferDelegate1(int paramInt, long paramLong);
  

  public void glDrawBuffers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDrawBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawBuffers" }));
    }
    dispatch_glDrawBuffers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDrawBuffers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDrawBuffers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"bufs_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDrawBuffers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawBuffers" }));
    }
    dispatch_glDrawBuffers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glUniformMatrix2x3fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix2x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x3fv" }));
    }
    dispatch_glUniformMatrix2x3fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix2x3fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix2x3fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix2x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x3fv" }));
    }
    dispatch_glUniformMatrix2x3fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix3x2fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix3x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x2fv" }));
    }
    dispatch_glUniformMatrix3x2fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix3x2fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix3x2fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix3x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x2fv" }));
    }
    dispatch_glUniformMatrix3x2fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix2x4fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix2x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x4fv" }));
    }
    dispatch_glUniformMatrix2x4fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix2x4fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix2x4fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix2x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x4fv" }));
    }
    dispatch_glUniformMatrix2x4fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix4x2fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix4x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x2fv" }));
    }
    dispatch_glUniformMatrix4x2fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix4x2fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix4x2fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix4x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x2fv" }));
    }
    dispatch_glUniformMatrix4x2fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix3x4fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix3x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x4fv" }));
    }
    dispatch_glUniformMatrix3x4fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix3x4fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix3x4fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix3x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x4fv" }));
    }
    dispatch_glUniformMatrix3x4fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix4x3fv(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix4x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x3fv" }));
    }
    dispatch_glUniformMatrix4x3fv1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix4x3fv1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix4x3fv(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix4x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x3fv" }));
    }
    dispatch_glUniformMatrix4x3fv1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glBlitFramebuffer(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10)
  {
    long l = _pat._addressof_glBlitFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlitFramebuffer" }));
    }
    dispatch_glBlitFramebuffer1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, l);
  }
  

  private native void dispatch_glBlitFramebuffer1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong);
  

  public void glRenderbufferStorageMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisample" }));
    }
    dispatch_glRenderbufferStorageMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFramebufferTextureLayer(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glFramebufferTextureLayer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTextureLayer" }));
    }
    dispatch_glFramebufferTextureLayer1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  








  private native void dispatch_glFramebufferTextureLayer1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  








  private long glMapBufferRangeDelegate(int paramInt1, long paramLong1, long paramLong2, int paramInt2)
  {
    long l = _pat._addressof_glMapBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMapBufferRange" }));
    }
    return dispatch_glMapBufferRangeDelegate1(paramInt1, paramLong1, paramLong2, paramInt2, l);
  }
  








  private native long dispatch_glMapBufferRangeDelegate1(int paramInt1, long paramLong1, long paramLong2, int paramInt2, long paramLong3);
  








  public void glFlushMappedBufferRange(int paramInt, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glFlushMappedBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFlushMappedBufferRange" }));
    }
    dispatch_glFlushMappedBufferRange1(paramInt, paramLong1, paramLong2, l);
  }
  

  private native void dispatch_glFlushMappedBufferRange1(int paramInt, long paramLong1, long paramLong2, long paramLong3);
  

  public void glBindVertexArray(int paramInt)
  {
    long l = _pat._addressof_glBindVertexArray;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindVertexArray" }));
    }
    dispatch_glBindVertexArray1(paramInt, l);
    bufferStateTracker.setBoundBufferObject(34229, paramInt);
  }
  


  private native void dispatch_glBindVertexArray1(int paramInt, long paramLong);
  

  public void glDeleteVertexArrays(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteVertexArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArrays" }));
    }
    dispatch_glDeleteVertexArrays1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteVertexArrays1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteVertexArrays(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteVertexArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArrays" }));
    }
    dispatch_glDeleteVertexArrays1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenVertexArrays(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenVertexArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArrays" }));
    }
    dispatch_glGenVertexArrays1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenVertexArrays1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenVertexArrays(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenVertexArrays;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArrays" }));
    }
    dispatch_glGenVertexArrays1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsVertexArray(int paramInt)
  {
    long l = _pat._addressof_glIsVertexArray;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsVertexArray" }));
    }
    return dispatch_glIsVertexArray1(paramInt, l);
  }
  


  private native boolean dispatch_glIsVertexArray1(int paramInt, long paramLong);
  

  public void glGetIntegeri_v(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetIntegeri_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegeri_v" }));
    }
    dispatch_glGetIntegeri_v1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetIntegeri_v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetIntegeri_v(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetIntegeri_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegeri_v" }));
    }
    dispatch_glGetIntegeri_v1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glBeginTransformFeedback(int paramInt)
  {
    long l = _pat._addressof_glBeginTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBeginTransformFeedback" }));
    }
    dispatch_glBeginTransformFeedback1(paramInt, l);
  }
  

  private native void dispatch_glBeginTransformFeedback1(int paramInt, long paramLong);
  

  public void glEndTransformFeedback()
  {
    long l = _pat._addressof_glEndTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEndTransformFeedback" }));
    }
    dispatch_glEndTransformFeedback1(l);
  }
  

  private native void dispatch_glEndTransformFeedback1(long paramLong);
  

  public void glBindBufferRange(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glBindBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindBufferRange" }));
    }
    dispatch_glBindBufferRange1(paramInt1, paramInt2, paramInt3, paramLong1, paramLong2, l);
    bufferStateTracker.setBoundBufferObject(paramInt1, paramInt3);
  }
  

  private native void dispatch_glBindBufferRange1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2, long paramLong3);
  

  public void glBindBufferBase(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBindBufferBase;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindBufferBase" }));
    }
    dispatch_glBindBufferBase1(paramInt1, paramInt2, paramInt3, l);
    bufferStateTracker.setBoundBufferObject(paramInt1, paramInt3);
  }
  

  private native void dispatch_glBindBufferBase1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTransformFeedbackVaryings(int paramInt1, int paramInt2, String[] paramArrayOfString, int paramInt3)
  {
    long l = _pat._addressof_glTransformFeedbackVaryings;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTransformFeedbackVaryings" }));
    }
    dispatch_glTransformFeedbackVaryings1(paramInt1, paramInt2, paramArrayOfString, paramInt3, l);
  }
  



  private native void dispatch_glTransformFeedbackVaryings1(int paramInt1, int paramInt2, String[] paramArrayOfString, int paramInt3, long paramLong);
  



  public void glGetTransformFeedbackVarying(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2, IntBuffer paramIntBuffer3, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramIntBuffer3);
    boolean bool4 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetTransformFeedbackVarying;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTransformFeedbackVarying" }));
    }
    dispatch_glGetTransformFeedbackVarying1(paramInt1, paramInt2, paramInt3, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramIntBuffer3 : Buffers.getArray(paramIntBuffer3), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer3) : Buffers.getIndirectBufferByteOffset(paramIntBuffer3), bool3, bool4 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool4 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool4, l);
  }
  



  private native void dispatch_glGetTransformFeedbackVarying1(int paramInt1, int paramInt2, int paramInt3, Object paramObject1, int paramInt4, boolean paramBoolean1, Object paramObject2, int paramInt5, boolean paramBoolean2, Object paramObject3, int paramInt6, boolean paramBoolean3, Object paramObject4, int paramInt7, boolean paramBoolean4, long paramLong);
  



  public void glGetTransformFeedbackVarying(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt1, int paramInt4, int[] paramArrayOfInt2, int paramInt5, int[] paramArrayOfInt3, int paramInt6, byte[] paramArrayOfByte, int paramInt7)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"size_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    if ((paramArrayOfInt3 != null) && (paramArrayOfInt3.length <= paramInt6))
      throw new GLException("array offset argument \"type_offset\" (" + paramInt6 + ") equals or exceeds array length (" + paramArrayOfInt3.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt7))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt7 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetTransformFeedbackVarying;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTransformFeedbackVarying" }));
    }
    dispatch_glGetTransformFeedbackVarying1(paramInt1, paramInt2, paramInt3, paramArrayOfInt1, 4 * paramInt4, false, paramArrayOfInt2, 4 * paramInt5, false, paramArrayOfInt3, 4 * paramInt6, false, paramArrayOfByte, paramInt7, false, l);
  }
  


  public void glVertexAttribIPointer(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Buffer paramBuffer)
  {
    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    if (!Buffers.isDirect(paramBuffer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    long l = _pat._addressof_glVertexAttribIPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribIPointer" }));
    }
    dispatch_glVertexAttribIPointer0(paramInt1, paramInt2, paramInt3, paramInt4, paramBuffer, Buffers.getDirectBufferByteOffset(paramBuffer), l);
  }
  


  private native void dispatch_glVertexAttribIPointer0(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject, int paramInt5, long paramLong);
  

  public void glVertexAttribIPointer(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong)
  {
    checkArrayVBOBound(true);
    long l = _pat._addressof_glVertexAttribIPointer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribIPointer" }));
    }
    dispatch_glVertexAttribIPointer0(paramInt1, paramInt2, paramInt3, paramInt4, paramLong, l);
  }
  


  private native void dispatch_glVertexAttribIPointer0(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong1, long paramLong2);
  

  public void glGetVertexAttribIiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetVertexAttribIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribIiv" }));
    }
    dispatch_glGetVertexAttribIiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetVertexAttribIiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetVertexAttribIiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetVertexAttribIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribIiv" }));
    }
    dispatch_glGetVertexAttribIiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetVertexAttribIuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetVertexAttribIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribIuiv" }));
    }
    dispatch_glGetVertexAttribIuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetVertexAttribIuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetVertexAttribIuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetVertexAttribIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetVertexAttribIuiv" }));
    }
    dispatch_glGetVertexAttribIuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glVertexAttribI4i(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glVertexAttribI4i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4i" }));
    }
    dispatch_glVertexAttribI4i1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glVertexAttribI4i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glVertexAttribI4ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glVertexAttribI4ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4ui" }));
    }
    dispatch_glVertexAttribI4ui1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glVertexAttribI4ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glVertexAttribI4iv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glVertexAttribI4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4iv" }));
    }
    dispatch_glVertexAttribI4iv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttribI4iv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttribI4iv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glVertexAttribI4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4iv" }));
    }
    dispatch_glVertexAttribI4iv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glVertexAttribI4uiv(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glVertexAttribI4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4uiv" }));
    }
    dispatch_glVertexAttribI4uiv1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glVertexAttribI4uiv1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glVertexAttribI4uiv(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glVertexAttribI4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribI4uiv" }));
    }
    dispatch_glVertexAttribI4uiv1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGetUniformuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetUniformuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformuiv" }));
    }
    dispatch_glGetUniformuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetUniformuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetUniformuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetUniformuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformuiv" }));
    }
    dispatch_glGetUniformuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public int glGetFragDataLocation(int paramInt, String paramString)
  {
    long l = _pat._addressof_glGetFragDataLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFragDataLocation" }));
    }
    return dispatch_glGetFragDataLocation1(paramInt, paramString, l);
  }
  

  private native int dispatch_glGetFragDataLocation1(int paramInt, String paramString, long paramLong);
  

  public void glUniform1ui(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glUniform1ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1ui" }));
    }
    dispatch_glUniform1ui1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glUniform1ui1(int paramInt1, int paramInt2, long paramLong);
  

  public void glUniform2ui(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glUniform2ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2ui" }));
    }
    dispatch_glUniform2ui1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glUniform2ui1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glUniform3ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glUniform3ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3ui" }));
    }
    dispatch_glUniform3ui1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glUniform3ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glUniform4ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glUniform4ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4ui" }));
    }
    dispatch_glUniform4ui1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glUniform4ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glUniform1uiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform1uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1uiv" }));
    }
    dispatch_glUniform1uiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform1uiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform1uiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform1uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform1uiv" }));
    }
    dispatch_glUniform1uiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glUniform2uiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform2uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2uiv" }));
    }
    dispatch_glUniform2uiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform2uiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform2uiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform2uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform2uiv" }));
    }
    dispatch_glUniform2uiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glUniform3uiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform3uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3uiv" }));
    }
    dispatch_glUniform3uiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform3uiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform3uiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform3uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform3uiv" }));
    }
    dispatch_glUniform3uiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glUniform4uiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glUniform4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4uiv" }));
    }
    dispatch_glUniform4uiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glUniform4uiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glUniform4uiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glUniform4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniform4uiv" }));
    }
    dispatch_glUniform4uiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glClearBufferiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glClearBufferiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferiv" }));
    }
    dispatch_glClearBufferiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glClearBufferiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glClearBufferiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glClearBufferiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferiv" }));
    }
    dispatch_glClearBufferiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glClearBufferuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glClearBufferuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferuiv" }));
    }
    dispatch_glClearBufferuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glClearBufferuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glClearBufferuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glClearBufferuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferuiv" }));
    }
    dispatch_glClearBufferuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glClearBufferfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glClearBufferfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferfv" }));
    }
    dispatch_glClearBufferfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glClearBufferfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glClearBufferfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glClearBufferfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferfv" }));
    }
    dispatch_glClearBufferfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glClearBufferfi(int paramInt1, int paramInt2, float paramFloat, int paramInt3)
  {
    long l = _pat._addressof_glClearBufferfi;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClearBufferfi" }));
    }
    dispatch_glClearBufferfi1(paramInt1, paramInt2, paramFloat, paramInt3, l);
  }
  

  private native void dispatch_glClearBufferfi1(int paramInt1, int paramInt2, float paramFloat, int paramInt3, long paramLong);
  

  public String glGetStringi(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glGetStringi;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetStringi" }));
    }
    return dispatch_glGetStringi1(paramInt1, paramInt2, l);
  }
  

  private native String dispatch_glGetStringi1(int paramInt1, int paramInt2, long paramLong);
  

  public void glCopyBufferSubData(int paramInt1, int paramInt2, long paramLong1, long paramLong2, long paramLong3)
  {
    long l = _pat._addressof_glCopyBufferSubData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyBufferSubData" }));
    }
    dispatch_glCopyBufferSubData1(paramInt1, paramInt2, paramLong1, paramLong2, paramLong3, l);
  }
  


  private native void dispatch_glCopyBufferSubData1(int paramInt1, int paramInt2, long paramLong1, long paramLong2, long paramLong3, long paramLong4);
  

  public void glGetUniformIndices(int paramInt1, int paramInt2, String[] paramArrayOfString, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetUniformIndices;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformIndices" }));
    }
    dispatch_glGetUniformIndices1(paramInt1, paramInt2, paramArrayOfString, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetUniformIndices1(int paramInt1, int paramInt2, String[] paramArrayOfString, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetUniformIndices(int paramInt1, int paramInt2, String[] paramArrayOfString, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetUniformIndices;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformIndices" }));
    }
    dispatch_glGetUniformIndices1(paramInt1, paramInt2, paramArrayOfString, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  



  public void glGetActiveUniformsiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, int paramInt3, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetActiveUniformsiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformsiv" }));
    }
    dispatch_glGetActiveUniformsiv1(paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt3, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetActiveUniformsiv1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, int paramInt4, Object paramObject2, int paramInt5, boolean paramBoolean2, long paramLong);
  


  public void glGetActiveUniformsiv(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int paramInt4, int[] paramArrayOfInt2, int paramInt5)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetActiveUniformsiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformsiv" }));
    }
    dispatch_glGetActiveUniformsiv1(paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramInt4, paramArrayOfInt2, 4 * paramInt5, false, l);
  }
  

  public int glGetUniformBlockIndex(int paramInt, String paramString)
  {
    long l = _pat._addressof_glGetUniformBlockIndex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetUniformBlockIndex" }));
    }
    return dispatch_glGetUniformBlockIndex1(paramInt, paramString, l);
  }
  


  private native int dispatch_glGetUniformBlockIndex1(int paramInt, String paramString, long paramLong);
  

  public void glGetActiveUniformBlockiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetActiveUniformBlockiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformBlockiv" }));
    }
    dispatch_glGetActiveUniformBlockiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetActiveUniformBlockiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetActiveUniformBlockiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetActiveUniformBlockiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformBlockiv" }));
    }
    dispatch_glGetActiveUniformBlockiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  



  public void glGetActiveUniformBlockName(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetActiveUniformBlockName;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformBlockName" }));
    }
    dispatch_glGetActiveUniformBlockName1(paramInt1, paramInt2, paramInt3, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetActiveUniformBlockName1(int paramInt1, int paramInt2, int paramInt3, Object paramObject1, int paramInt4, boolean paramBoolean1, Object paramObject2, int paramInt5, boolean paramBoolean2, long paramLong);
  


  public void glGetActiveUniformBlockName(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4, byte[] paramArrayOfByte, int paramInt5)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt5))
      throw new GLException("array offset argument \"uniformBlockName_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetActiveUniformBlockName;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetActiveUniformBlockName" }));
    }
    dispatch_glGetActiveUniformBlockName1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, paramArrayOfByte, paramInt5, false, l);
  }
  

  public void glUniformBlockBinding(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glUniformBlockBinding;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformBlockBinding" }));
    }
    dispatch_glUniformBlockBinding1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glUniformBlockBinding1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glDrawArraysInstanced(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glDrawArraysInstanced;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysInstanced" }));
    }
    dispatch_glDrawArraysInstanced1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glDrawArraysInstanced1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glDrawElementsInstanced(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstanced;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstanced" }));
    }
    dispatch_glDrawElementsInstanced1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsInstanced1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  

  public void glDrawElementsInstanced(int paramInt1, int paramInt2, int paramInt3, long paramLong, int paramInt4)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElementsInstanced;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstanced" }));
    }
    dispatch_glDrawElementsInstanced1(paramInt1, paramInt2, paramInt3, paramLong, paramInt4, l);
  }
  

  private native void dispatch_glDrawElementsInstanced1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, int paramInt4, long paramLong2);
  

  public long glFenceSync(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glFenceSync;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFenceSync" }));
    }
    return dispatch_glFenceSync1(paramInt1, paramInt2, l);
  }
  

  private native long dispatch_glFenceSync1(int paramInt1, int paramInt2, long paramLong);
  

  public boolean glIsSync(long paramLong)
  {
    long l = _pat._addressof_glIsSync;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsSync" }));
    }
    return dispatch_glIsSync1(paramLong, l);
  }
  

  private native boolean dispatch_glIsSync1(long paramLong1, long paramLong2);
  

  public void glDeleteSync(long paramLong)
  {
    long l = _pat._addressof_glDeleteSync;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteSync" }));
    }
    dispatch_glDeleteSync1(paramLong, l);
  }
  

  private native void dispatch_glDeleteSync1(long paramLong1, long paramLong2);
  

  public int glClientWaitSync(long paramLong1, int paramInt, long paramLong2)
  {
    long l = _pat._addressof_glClientWaitSync;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glClientWaitSync" }));
    }
    return dispatch_glClientWaitSync1(paramLong1, paramInt, paramLong2, l);
  }
  

  private native int dispatch_glClientWaitSync1(long paramLong1, int paramInt, long paramLong2, long paramLong3);
  

  public void glWaitSync(long paramLong1, int paramInt, long paramLong2)
  {
    long l = _pat._addressof_glWaitSync;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glWaitSync" }));
    }
    dispatch_glWaitSync1(paramLong1, paramInt, paramLong2, l);
  }
  


  private native void dispatch_glWaitSync1(long paramLong1, int paramInt, long paramLong2, long paramLong3);
  

  public void glGetInteger64v(int paramInt, LongBuffer paramLongBuffer)
  {
    boolean bool = Buffers.isDirect(paramLongBuffer);
    long l = _pat._addressof_glGetInteger64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInteger64v" }));
    }
    dispatch_glGetInteger64v1(paramInt, bool ? paramLongBuffer : Buffers.getArray(paramLongBuffer), bool ? Buffers.getDirectBufferByteOffset(paramLongBuffer) : Buffers.getIndirectBufferByteOffset(paramLongBuffer), bool, l);
  }
  


  private native void dispatch_glGetInteger64v1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetInteger64v(int paramInt1, long[] paramArrayOfLong, int paramInt2)
  {
    if ((paramArrayOfLong != null) && (paramArrayOfLong.length <= paramInt2))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfLong.length + ")");
    long l = _pat._addressof_glGetInteger64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInteger64v" }));
    }
    dispatch_glGetInteger64v1(paramInt1, paramArrayOfLong, 8 * paramInt2, false, l);
  }
  



  public void glGetSynciv(long paramLong, int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetSynciv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSynciv" }));
    }
    dispatch_glGetSynciv1(paramLong, paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetSynciv1(long paramLong1, int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong2);
  


  public void glGetSynciv(long paramLong, int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int[] paramArrayOfInt2, int paramInt4)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt4))
      throw new GLException("array offset argument \"values_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetSynciv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSynciv" }));
    }
    dispatch_glGetSynciv1(paramLong, paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramArrayOfInt2, 4 * paramInt4, false, l);
  }
  


  public void glGetInteger64i_v(int paramInt1, int paramInt2, LongBuffer paramLongBuffer)
  {
    boolean bool = Buffers.isDirect(paramLongBuffer);
    long l = _pat._addressof_glGetInteger64i_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInteger64i_v" }));
    }
    dispatch_glGetInteger64i_v1(paramInt1, paramInt2, bool ? paramLongBuffer : Buffers.getArray(paramLongBuffer), bool ? Buffers.getDirectBufferByteOffset(paramLongBuffer) : Buffers.getIndirectBufferByteOffset(paramLongBuffer), bool, l);
  }
  


  private native void dispatch_glGetInteger64i_v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetInteger64i_v(int paramInt1, int paramInt2, long[] paramArrayOfLong, int paramInt3)
  {
    if ((paramArrayOfLong != null) && (paramArrayOfLong.length <= paramInt3))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfLong.length + ")");
    long l = _pat._addressof_glGetInteger64i_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInteger64i_v" }));
    }
    dispatch_glGetInteger64i_v1(paramInt1, paramInt2, paramArrayOfLong, 8 * paramInt3, false, l);
  }
  


  public void glGetBufferParameteri64v(int paramInt1, int paramInt2, LongBuffer paramLongBuffer)
  {
    boolean bool = Buffers.isDirect(paramLongBuffer);
    long l = _pat._addressof_glGetBufferParameteri64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteri64v" }));
    }
    dispatch_glGetBufferParameteri64v1(paramInt1, paramInt2, bool ? paramLongBuffer : Buffers.getArray(paramLongBuffer), bool ? Buffers.getDirectBufferByteOffset(paramLongBuffer) : Buffers.getIndirectBufferByteOffset(paramLongBuffer), bool, l);
  }
  


  private native void dispatch_glGetBufferParameteri64v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetBufferParameteri64v(int paramInt1, int paramInt2, long[] paramArrayOfLong, int paramInt3)
  {
    if ((paramArrayOfLong != null) && (paramArrayOfLong.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfLong.length + ")");
    long l = _pat._addressof_glGetBufferParameteri64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBufferParameteri64v" }));
    }
    dispatch_glGetBufferParameteri64v1(paramInt1, paramInt2, paramArrayOfLong, 8 * paramInt3, false, l);
  }
  


  public void glGenSamplers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenSamplers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenSamplers" }));
    }
    dispatch_glGenSamplers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenSamplers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenSamplers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"samplers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenSamplers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenSamplers" }));
    }
    dispatch_glGenSamplers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glDeleteSamplers(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteSamplers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteSamplers" }));
    }
    dispatch_glDeleteSamplers1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteSamplers1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteSamplers(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"samplers_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteSamplers;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteSamplers" }));
    }
    dispatch_glDeleteSamplers1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsSampler(int paramInt)
  {
    long l = _pat._addressof_glIsSampler;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsSampler" }));
    }
    return dispatch_glIsSampler1(paramInt, l);
  }
  

  private native boolean dispatch_glIsSampler1(int paramInt, long paramLong);
  

  public void glBindSampler(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindSampler;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindSampler" }));
    }
    dispatch_glBindSampler1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBindSampler1(int paramInt1, int paramInt2, long paramLong);
  

  public void glSamplerParameteri(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glSamplerParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameteri" }));
    }
    dispatch_glSamplerParameteri1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glSamplerParameteri1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glSamplerParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glSamplerParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameteriv" }));
    }
    dispatch_glSamplerParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glSamplerParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glSamplerParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"param_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glSamplerParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameteriv" }));
    }
    dispatch_glSamplerParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glSamplerParameterf(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glSamplerParameterf;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterf" }));
    }
    dispatch_glSamplerParameterf1(paramInt1, paramInt2, paramFloat, l);
  }
  


  private native void dispatch_glSamplerParameterf1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glSamplerParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glSamplerParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterfv" }));
    }
    dispatch_glSamplerParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glSamplerParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glSamplerParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"param_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glSamplerParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterfv" }));
    }
    dispatch_glSamplerParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glGetSamplerParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetSamplerParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameteriv" }));
    }
    dispatch_glGetSamplerParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetSamplerParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetSamplerParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetSamplerParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameteriv" }));
    }
    dispatch_glGetSamplerParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetSamplerParameterfv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetSamplerParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterfv" }));
    }
    dispatch_glGetSamplerParameterfv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetSamplerParameterfv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetSamplerParameterfv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetSamplerParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterfv" }));
    }
    dispatch_glGetSamplerParameterfv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glVertexAttribDivisor(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glVertexAttribDivisor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribDivisor" }));
    }
    dispatch_glVertexAttribDivisor1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glVertexAttribDivisor1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBindTransformFeedback(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBindTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindTransformFeedback" }));
    }
    dispatch_glBindTransformFeedback1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glBindTransformFeedback1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDeleteTransformFeedbacks(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteTransformFeedbacks;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTransformFeedbacks" }));
    }
    dispatch_glDeleteTransformFeedbacks1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteTransformFeedbacks1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteTransformFeedbacks(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteTransformFeedbacks;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteTransformFeedbacks" }));
    }
    dispatch_glDeleteTransformFeedbacks1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenTransformFeedbacks(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenTransformFeedbacks;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTransformFeedbacks" }));
    }
    dispatch_glGenTransformFeedbacks1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenTransformFeedbacks1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenTransformFeedbacks(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenTransformFeedbacks;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenTransformFeedbacks" }));
    }
    dispatch_glGenTransformFeedbacks1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsTransformFeedback(int paramInt)
  {
    long l = _pat._addressof_glIsTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsTransformFeedback" }));
    }
    return dispatch_glIsTransformFeedback1(paramInt, l);
  }
  

  private native boolean dispatch_glIsTransformFeedback1(int paramInt, long paramLong);
  

  public void glPauseTransformFeedback()
  {
    long l = _pat._addressof_glPauseTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPauseTransformFeedback" }));
    }
    dispatch_glPauseTransformFeedback1(l);
  }
  

  private native void dispatch_glPauseTransformFeedback1(long paramLong);
  

  public void glResumeTransformFeedback()
  {
    long l = _pat._addressof_glResumeTransformFeedback;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glResumeTransformFeedback" }));
    }
    dispatch_glResumeTransformFeedback1(l);
  }
  



  private native void dispatch_glResumeTransformFeedback1(long paramLong);
  


  public void glGetProgramBinary(int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2, Buffer paramBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glGetProgramBinary;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramBinary" }));
    }
    dispatch_glGetProgramBinary1(paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramBuffer : Buffers.getArray(paramBuffer), bool3 ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool3, l);
  }
  



  private native void dispatch_glGetProgramBinary1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, Object paramObject3, int paramInt5, boolean paramBoolean3, long paramLong);
  



  public void glGetProgramBinary(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int[] paramArrayOfInt2, int paramInt4, Buffer paramBuffer)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt4))
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glGetProgramBinary;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramBinary" }));
    }
    dispatch_glGetProgramBinary1(paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramArrayOfInt2, 4 * paramInt4, false, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  public void glProgramBinary(int paramInt1, int paramInt2, Buffer paramBuffer, int paramInt3)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glProgramBinary;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramBinary" }));
    }
    dispatch_glProgramBinary1(paramInt1, paramInt2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt3, l);
  }
  


  private native void dispatch_glProgramBinary1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, int paramInt4, long paramLong);
  

  public void glProgramParameteri(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glProgramParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramParameteri" }));
    }
    dispatch_glProgramParameteri1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glProgramParameteri1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glInvalidateFramebuffer(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glInvalidateFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glInvalidateFramebuffer" }));
    }
    dispatch_glInvalidateFramebuffer1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glInvalidateFramebuffer1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glInvalidateFramebuffer(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"attachments_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glInvalidateFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glInvalidateFramebuffer" }));
    }
    dispatch_glInvalidateFramebuffer1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glInvalidateSubFramebuffer(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glInvalidateSubFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glInvalidateSubFramebuffer" }));
    }
    dispatch_glInvalidateSubFramebuffer1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glInvalidateSubFramebuffer1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong);
  

  public void glInvalidateSubFramebuffer(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"attachments_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glInvalidateSubFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glInvalidateSubFramebuffer" }));
    }
    dispatch_glInvalidateSubFramebuffer1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramInt4, paramInt5, paramInt6, paramInt7, l);
  }
  

  public void glTexStorage2D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glTexStorage2D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage2D" }));
    }
    dispatch_glTexStorage2D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glTexStorage2D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glTexStorage3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glTexStorage3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage3D" }));
    }
    dispatch_glTexStorage3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glTexStorage3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glGetInternalformativ(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetInternalformativ;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInternalformativ" }));
    }
    dispatch_glGetInternalformativ1(paramInt1, paramInt2, paramInt3, paramInt4, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetInternalformativ1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject, int paramInt5, boolean paramBoolean, long paramLong);
  

  public void glGetInternalformativ(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt5))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetInternalformativ;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetInternalformativ" }));
    }
    dispatch_glGetInternalformativ1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, 4 * paramInt5, false, l);
  }
  

  public void glDispatchCompute(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glDispatchCompute;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDispatchCompute" }));
    }
    dispatch_glDispatchCompute1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glDispatchCompute1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glDispatchComputeIndirect(long paramLong)
  {
    long l = _pat._addressof_glDispatchComputeIndirect;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDispatchComputeIndirect" }));
    }
    dispatch_glDispatchComputeIndirect1(paramLong, l);
  }
  


  private native void dispatch_glDispatchComputeIndirect1(long paramLong1, long paramLong2);
  

  public void glDrawArraysIndirect(int paramInt, Buffer paramBuffer)
  {
    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawArraysIndirect;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysIndirect" }));
    }
    dispatch_glDrawArraysIndirect1(paramInt, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glDrawArraysIndirect1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDrawArraysIndirect(int paramInt, long paramLong)
  {
    checkIndirectVBOBound(true);
    long l = _pat._addressof_glDrawArraysIndirect;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysIndirect" }));
    }
    dispatch_glDrawArraysIndirect1(paramInt, paramLong, l);
  }
  


  private native void dispatch_glDrawArraysIndirect1(int paramInt, long paramLong1, long paramLong2);
  

  public void glDrawElementsIndirect(int paramInt1, int paramInt2, Buffer paramBuffer)
  {
    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, 1);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsIndirect;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsIndirect" }));
    }
    dispatch_glDrawElementsIndirect1(paramInt1, paramInt2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glDrawElementsIndirect1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glDrawElementsIndirect(int paramInt1, int paramInt2, long paramLong)
  {
    checkIndirectVBOBound(true);
    long l = _pat._addressof_glDrawElementsIndirect;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsIndirect" }));
    }
    dispatch_glDrawElementsIndirect1(paramInt1, paramInt2, paramLong, l);
  }
  

  private native void dispatch_glDrawElementsIndirect1(int paramInt1, int paramInt2, long paramLong1, long paramLong2);
  

  public void glFramebufferParameteri(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glFramebufferParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferParameteri" }));
    }
    dispatch_glFramebufferParameteri1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glFramebufferParameteri1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glGetFramebufferParameteriv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetFramebufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferParameteriv" }));
    }
    dispatch_glGetFramebufferParameteriv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetFramebufferParameteriv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetFramebufferParameteriv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetFramebufferParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFramebufferParameteriv" }));
    }
    dispatch_glGetFramebufferParameteriv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetProgramInterfaceiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetProgramInterfaceiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramInterfaceiv" }));
    }
    dispatch_glGetProgramInterfaceiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetProgramInterfaceiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetProgramInterfaceiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetProgramInterfaceiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramInterfaceiv" }));
    }
    dispatch_glGetProgramInterfaceiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public int glGetProgramResourceIndex(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramResourceIndex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceIndex" }));
    }
    return dispatch_glGetProgramResourceIndex1(paramInt1, paramInt2, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native int dispatch_glGetProgramResourceIndex1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public int glGetProgramResourceIndex(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramResourceIndex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceIndex" }));
    }
    return dispatch_glGetProgramResourceIndex1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, l);
  }
  



  public void glGetProgramResourceName(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramResourceName;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceName" }));
    }
    dispatch_glGetProgramResourceName1(paramInt1, paramInt2, paramInt3, paramInt4, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetProgramResourceName1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject1, int paramInt5, boolean paramBoolean1, Object paramObject2, int paramInt6, boolean paramBoolean2, long paramLong);
  


  public void glGetProgramResourceName(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5, byte[] paramArrayOfByte, int paramInt6)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt5))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt6))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt6 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramResourceName;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceName" }));
    }
    dispatch_glGetProgramResourceName1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, 4 * paramInt5, false, paramArrayOfByte, paramInt6, false, l);
  }
  




  public void glGetProgramResourceiv(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer1, int paramInt5, IntBuffer paramIntBuffer2, IntBuffer paramIntBuffer3)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramIntBuffer3);
    long l = _pat._addressof_glGetProgramResourceiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceiv" }));
    }
    dispatch_glGetProgramResourceiv1(paramInt1, paramInt2, paramInt3, paramInt4, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt5, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramIntBuffer3 : Buffers.getArray(paramIntBuffer3), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer3) : Buffers.getIndirectBufferByteOffset(paramIntBuffer3), bool3, l);
  }
  



  private native void dispatch_glGetProgramResourceiv1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject1, int paramInt5, boolean paramBoolean1, int paramInt6, Object paramObject2, int paramInt7, boolean paramBoolean2, Object paramObject3, int paramInt8, boolean paramBoolean3, long paramLong);
  


  public void glGetProgramResourceiv(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt1, int paramInt5, int paramInt6, int[] paramArrayOfInt2, int paramInt7, int[] paramArrayOfInt3, int paramInt8)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt5))
      throw new GLException("array offset argument \"props_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt7))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt7 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    if ((paramArrayOfInt3 != null) && (paramArrayOfInt3.length <= paramInt8))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt8 + ") equals or exceeds array length (" + paramArrayOfInt3.length + ")");
    long l = _pat._addressof_glGetProgramResourceiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceiv" }));
    }
    dispatch_glGetProgramResourceiv1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt1, 4 * paramInt5, false, paramInt6, paramArrayOfInt2, 4 * paramInt7, false, paramArrayOfInt3, 4 * paramInt8, false, l);
  }
  


  public int glGetProgramResourceLocation(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramResourceLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceLocation" }));
    }
    return dispatch_glGetProgramResourceLocation1(paramInt1, paramInt2, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native int dispatch_glGetProgramResourceLocation1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public int glGetProgramResourceLocation(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramResourceLocation;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceLocation" }));
    }
    return dispatch_glGetProgramResourceLocation1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, l);
  }
  

  public void glUseProgramStages(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glUseProgramStages;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUseProgramStages" }));
    }
    dispatch_glUseProgramStages1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glUseProgramStages1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glActiveShaderProgram(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glActiveShaderProgram;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glActiveShaderProgram" }));
    }
    dispatch_glActiveShaderProgram1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glActiveShaderProgram1(int paramInt1, int paramInt2, long paramLong);
  

  public int glCreateShaderProgramv(int paramInt1, int paramInt2, String[] paramArrayOfString)
  {
    long l = _pat._addressof_glCreateShaderProgramv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCreateShaderProgramv" }));
    }
    return dispatch_glCreateShaderProgramv1(paramInt1, paramInt2, paramArrayOfString, l);
  }
  

  private native int dispatch_glCreateShaderProgramv1(int paramInt1, int paramInt2, String[] paramArrayOfString, long paramLong);
  

  public void glBindProgramPipeline(int paramInt)
  {
    long l = _pat._addressof_glBindProgramPipeline;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindProgramPipeline" }));
    }
    dispatch_glBindProgramPipeline1(paramInt, l);
  }
  


  private native void dispatch_glBindProgramPipeline1(int paramInt, long paramLong);
  

  public void glDeleteProgramPipelines(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteProgramPipelines;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteProgramPipelines" }));
    }
    dispatch_glDeleteProgramPipelines1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteProgramPipelines1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteProgramPipelines(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"pipelines_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteProgramPipelines;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteProgramPipelines" }));
    }
    dispatch_glDeleteProgramPipelines1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenProgramPipelines(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenProgramPipelines;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenProgramPipelines" }));
    }
    dispatch_glGenProgramPipelines1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenProgramPipelines1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenProgramPipelines(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"pipelines_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenProgramPipelines;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenProgramPipelines" }));
    }
    dispatch_glGenProgramPipelines1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsProgramPipeline(int paramInt)
  {
    long l = _pat._addressof_glIsProgramPipeline;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsProgramPipeline" }));
    }
    return dispatch_glIsProgramPipeline1(paramInt, l);
  }
  


  private native boolean dispatch_glIsProgramPipeline1(int paramInt, long paramLong);
  

  public void glGetProgramPipelineiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetProgramPipelineiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramPipelineiv" }));
    }
    dispatch_glGetProgramPipelineiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetProgramPipelineiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetProgramPipelineiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetProgramPipelineiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramPipelineiv" }));
    }
    dispatch_glGetProgramPipelineiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glProgramUniform1i(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glProgramUniform1i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1i" }));
    }
    dispatch_glProgramUniform1i1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glProgramUniform1i1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glProgramUniform2i(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glProgramUniform2i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2i" }));
    }
    dispatch_glProgramUniform2i1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glProgramUniform2i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glProgramUniform3i(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glProgramUniform3i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3i" }));
    }
    dispatch_glProgramUniform3i1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glProgramUniform3i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glProgramUniform4i(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glProgramUniform4i;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4i" }));
    }
    dispatch_glProgramUniform4i1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glProgramUniform4i1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glProgramUniform1ui(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glProgramUniform1ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1ui" }));
    }
    dispatch_glProgramUniform1ui1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glProgramUniform1ui1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glProgramUniform2ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glProgramUniform2ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2ui" }));
    }
    dispatch_glProgramUniform2ui1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glProgramUniform2ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glProgramUniform3ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glProgramUniform3ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3ui" }));
    }
    dispatch_glProgramUniform3ui1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glProgramUniform3ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glProgramUniform4ui(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glProgramUniform4ui;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4ui" }));
    }
    dispatch_glProgramUniform4ui1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glProgramUniform4ui1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glProgramUniform1f(int paramInt1, int paramInt2, float paramFloat)
  {
    long l = _pat._addressof_glProgramUniform1f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1f" }));
    }
    dispatch_glProgramUniform1f1(paramInt1, paramInt2, paramFloat, l);
  }
  

  private native void dispatch_glProgramUniform1f1(int paramInt1, int paramInt2, float paramFloat, long paramLong);
  

  public void glProgramUniform2f(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glProgramUniform2f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2f" }));
    }
    dispatch_glProgramUniform2f1(paramInt1, paramInt2, paramFloat1, paramFloat2, l);
  }
  

  private native void dispatch_glProgramUniform2f1(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2, long paramLong);
  

  public void glProgramUniform3f(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2, float paramFloat3)
  {
    long l = _pat._addressof_glProgramUniform3f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3f" }));
    }
    dispatch_glProgramUniform3f1(paramInt1, paramInt2, paramFloat1, paramFloat2, paramFloat3, l);
  }
  

  private native void dispatch_glProgramUniform3f1(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2, float paramFloat3, long paramLong);
  

  public void glProgramUniform4f(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glProgramUniform4f;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4f" }));
    }
    dispatch_glProgramUniform4f1(paramInt1, paramInt2, paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  


  private native void dispatch_glProgramUniform4f1(int paramInt1, int paramInt2, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glProgramUniform1iv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform1iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1iv" }));
    }
    dispatch_glProgramUniform1iv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform1iv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform1iv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform1iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1iv" }));
    }
    dispatch_glProgramUniform1iv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform2iv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform2iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2iv" }));
    }
    dispatch_glProgramUniform2iv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform2iv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform2iv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform2iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2iv" }));
    }
    dispatch_glProgramUniform2iv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform3iv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform3iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3iv" }));
    }
    dispatch_glProgramUniform3iv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform3iv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform3iv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform3iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3iv" }));
    }
    dispatch_glProgramUniform3iv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform4iv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4iv" }));
    }
    dispatch_glProgramUniform4iv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform4iv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform4iv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform4iv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4iv" }));
    }
    dispatch_glProgramUniform4iv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform1uiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform1uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1uiv" }));
    }
    dispatch_glProgramUniform1uiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform1uiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform1uiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform1uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1uiv" }));
    }
    dispatch_glProgramUniform1uiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform2uiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform2uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2uiv" }));
    }
    dispatch_glProgramUniform2uiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform2uiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform2uiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform2uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2uiv" }));
    }
    dispatch_glProgramUniform2uiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform3uiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform3uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3uiv" }));
    }
    dispatch_glProgramUniform3uiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform3uiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform3uiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform3uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3uiv" }));
    }
    dispatch_glProgramUniform3uiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform4uiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glProgramUniform4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4uiv" }));
    }
    dispatch_glProgramUniform4uiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform4uiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform4uiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glProgramUniform4uiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4uiv" }));
    }
    dispatch_glProgramUniform4uiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform1fv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniform1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1fv" }));
    }
    dispatch_glProgramUniform1fv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform1fv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform1fv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniform1fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform1fv" }));
    }
    dispatch_glProgramUniform1fv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform2fv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniform2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2fv" }));
    }
    dispatch_glProgramUniform2fv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform2fv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform2fv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniform2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform2fv" }));
    }
    dispatch_glProgramUniform2fv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform3fv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniform3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3fv" }));
    }
    dispatch_glProgramUniform3fv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform3fv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform3fv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniform3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform3fv" }));
    }
    dispatch_glProgramUniform3fv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniform4fv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniform4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4fv" }));
    }
    dispatch_glProgramUniform4fv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniform4fv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glProgramUniform4fv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniform4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniform4fv" }));
    }
    dispatch_glProgramUniform4fv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2fv" }));
    }
    dispatch_glProgramUniformMatrix2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix2fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2fv" }));
    }
    dispatch_glProgramUniformMatrix2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3fv" }));
    }
    dispatch_glProgramUniformMatrix3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix3fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3fv" }));
    }
    dispatch_glProgramUniformMatrix3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4fv" }));
    }
    dispatch_glProgramUniformMatrix4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix4fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4fv" }));
    }
    dispatch_glProgramUniformMatrix4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix2x3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2x3fv" }));
    }
    dispatch_glProgramUniformMatrix2x3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix2x3fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix2x3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2x3fv" }));
    }
    dispatch_glProgramUniformMatrix2x3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix3x2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3x2fv" }));
    }
    dispatch_glProgramUniformMatrix3x2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix3x2fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix3x2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3x2fv" }));
    }
    dispatch_glProgramUniformMatrix3x2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix2x4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2x4fv" }));
    }
    dispatch_glProgramUniformMatrix2x4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix2x4fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix2x4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix2x4fv" }));
    }
    dispatch_glProgramUniformMatrix2x4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix4x2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4x2fv" }));
    }
    dispatch_glProgramUniformMatrix4x2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix4x2fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix4x2fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4x2fv" }));
    }
    dispatch_glProgramUniformMatrix4x2fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix3x4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3x4fv" }));
    }
    dispatch_glProgramUniformMatrix3x4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix3x4fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix3x4fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix3x4fv" }));
    }
    dispatch_glProgramUniformMatrix3x4fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glProgramUniformMatrix4x3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4x3fv" }));
    }
    dispatch_glProgramUniformMatrix4x3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glProgramUniformMatrix4x3fv1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean1, Object paramObject, int paramInt4, boolean paramBoolean2, long paramLong);
  

  public void glProgramUniformMatrix4x3fv(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glProgramUniformMatrix4x3fv" }));
    }
    dispatch_glProgramUniformMatrix4x3fv1(paramInt1, paramInt2, paramInt3, paramBoolean, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  

  public void glValidateProgramPipeline(int paramInt)
  {
    long l = _pat._addressof_glValidateProgramPipeline;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glValidateProgramPipeline" }));
    }
    dispatch_glValidateProgramPipeline1(paramInt, l);
  }
  


  private native void dispatch_glValidateProgramPipeline1(int paramInt, long paramLong);
  


  public void glGetProgramPipelineInfoLog(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramPipelineInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramPipelineInfoLog" }));
    }
    dispatch_glGetProgramPipelineInfoLog1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetProgramPipelineInfoLog1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetProgramPipelineInfoLog(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"infoLog_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramPipelineInfoLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramPipelineInfoLog" }));
    }
    dispatch_glGetProgramPipelineInfoLog1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  

  public void glBindImageTexture(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glBindImageTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindImageTexture" }));
    }
    dispatch_glBindImageTexture1(paramInt1, paramInt2, paramInt3, paramBoolean, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glBindImageTexture1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glGetBooleani_v(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetBooleani_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleani_v" }));
    }
    dispatch_glGetBooleani_v1(paramInt1, paramInt2, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glGetBooleani_v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetBooleani_v(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetBooleani_v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetBooleani_v" }));
    }
    dispatch_glGetBooleani_v1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, l);
  }
  

  public void glMemoryBarrier(int paramInt)
  {
    long l = _pat._addressof_glMemoryBarrier;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMemoryBarrier" }));
    }
    dispatch_glMemoryBarrier1(paramInt, l);
  }
  

  private native void dispatch_glMemoryBarrier1(int paramInt, long paramLong);
  

  public void glMemoryBarrierByRegion(int paramInt)
  {
    long l = _pat._addressof_glMemoryBarrierByRegion;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMemoryBarrierByRegion" }));
    }
    dispatch_glMemoryBarrierByRegion1(paramInt, l);
  }
  

  private native void dispatch_glMemoryBarrierByRegion1(int paramInt, long paramLong);
  

  public void glTexStorage2DMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexStorage2DMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage2DMultisample" }));
    }
    dispatch_glTexStorage2DMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramBoolean, l);
  }
  


  private native void dispatch_glTexStorage2DMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean, long paramLong);
  

  public void glGetMultisamplefv(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetMultisamplefv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMultisamplefv" }));
    }
    dispatch_glGetMultisamplefv1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetMultisamplefv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetMultisamplefv(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"val_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetMultisamplefv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetMultisamplefv" }));
    }
    dispatch_glGetMultisamplefv1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glSampleMaski(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glSampleMaski;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSampleMaski" }));
    }
    dispatch_glSampleMaski1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glSampleMaski1(int paramInt1, int paramInt2, long paramLong);
  

  public void glGetTexLevelParameteriv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexLevelParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexLevelParameteriv" }));
    }
    dispatch_glGetTexLevelParameteriv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexLevelParameteriv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetTexLevelParameteriv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexLevelParameteriv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexLevelParameteriv" }));
    }
    dispatch_glGetTexLevelParameteriv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glGetTexLevelParameterfv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetTexLevelParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexLevelParameterfv" }));
    }
    dispatch_glGetTexLevelParameterfv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexLevelParameterfv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetTexLevelParameterfv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetTexLevelParameterfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexLevelParameterfv" }));
    }
    dispatch_glGetTexLevelParameterfv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  

  public void glBindVertexBuffer(int paramInt1, int paramInt2, long paramLong, int paramInt3)
  {
    long l = _pat._addressof_glBindVertexBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindVertexBuffer" }));
    }
    dispatch_glBindVertexBuffer1(paramInt1, paramInt2, paramLong, paramInt3, l);
  }
  

  private native void dispatch_glBindVertexBuffer1(int paramInt1, int paramInt2, long paramLong1, int paramInt3, long paramLong2);
  

  public void glVertexAttribFormat(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4)
  {
    long l = _pat._addressof_glVertexAttribFormat;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribFormat" }));
    }
    dispatch_glVertexAttribFormat1(paramInt1, paramInt2, paramInt3, paramBoolean, paramInt4, l);
  }
  

  private native void dispatch_glVertexAttribFormat1(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, int paramInt4, long paramLong);
  

  public void glVertexAttribIFormat(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glVertexAttribIFormat;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribIFormat" }));
    }
    dispatch_glVertexAttribIFormat1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glVertexAttribIFormat1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glVertexAttribBinding(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glVertexAttribBinding;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribBinding" }));
    }
    dispatch_glVertexAttribBinding1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glVertexAttribBinding1(int paramInt1, int paramInt2, long paramLong);
  

  public void glVertexBindingDivisor(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glVertexBindingDivisor;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexBindingDivisor" }));
    }
    dispatch_glVertexBindingDivisor1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glVertexBindingDivisor1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendBarrier()
  {
    long l = _pat._addressof_glBlendBarrier;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendBarrier" }));
    }
    dispatch_glBlendBarrier1(l);
  }
  

  private native void dispatch_glBlendBarrier1(long paramLong);
  

  public void glCopyImageSubData(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, int paramInt11, int paramInt12, int paramInt13, int paramInt14, int paramInt15)
  {
    long l = _pat._addressof_glCopyImageSubData;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyImageSubData" }));
    }
    dispatch_glCopyImageSubData1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, paramInt11, paramInt12, paramInt13, paramInt14, paramInt15, l);
  }
  


  private native void dispatch_glCopyImageSubData1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, int paramInt11, int paramInt12, int paramInt13, int paramInt14, int paramInt15, long paramLong);
  

  public void glDebugMessageControl(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer, boolean paramBoolean)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDebugMessageControl;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDebugMessageControl" }));
    }
    dispatch_glDebugMessageControl1(paramInt1, paramInt2, paramInt3, paramInt4, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, paramBoolean, l);
  }
  


  private native void dispatch_glDebugMessageControl1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject, int paramInt5, boolean paramBoolean1, boolean paramBoolean2, long paramLong);
  

  public void glDebugMessageControl(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5, boolean paramBoolean)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt5))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDebugMessageControl;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDebugMessageControl" }));
    }
    dispatch_glDebugMessageControl1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, 4 * paramInt5, false, paramBoolean, l);
  }
  

  public void glDebugMessageInsert(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, String paramString)
  {
    long l = _pat._addressof_glDebugMessageInsert;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDebugMessageInsert" }));
    }
    dispatch_glDebugMessageInsert1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramString, l);
  }
  




  private native void dispatch_glDebugMessageInsert1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, String paramString, long paramLong);
  




  public int glGetDebugMessageLog(int paramInt1, int paramInt2, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2, IntBuffer paramIntBuffer3, IntBuffer paramIntBuffer4, IntBuffer paramIntBuffer5, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    boolean bool3 = Buffers.isDirect(paramIntBuffer3);
    boolean bool4 = Buffers.isDirect(paramIntBuffer4);
    boolean bool5 = Buffers.isDirect(paramIntBuffer5);
    boolean bool6 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetDebugMessageLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDebugMessageLog" }));
    }
    return dispatch_glGetDebugMessageLog1(paramInt1, paramInt2, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, bool3 ? paramIntBuffer3 : Buffers.getArray(paramIntBuffer3), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer3) : Buffers.getIndirectBufferByteOffset(paramIntBuffer3), bool3, bool4 ? paramIntBuffer4 : Buffers.getArray(paramIntBuffer4), bool4 ? Buffers.getDirectBufferByteOffset(paramIntBuffer4) : Buffers.getIndirectBufferByteOffset(paramIntBuffer4), bool4, bool5 ? paramIntBuffer5 : Buffers.getArray(paramIntBuffer5), bool5 ? Buffers.getDirectBufferByteOffset(paramIntBuffer5) : Buffers.getIndirectBufferByteOffset(paramIntBuffer5), bool5, bool6 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool6 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool6, l);
  }
  




  private native int dispatch_glGetDebugMessageLog1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, Object paramObject3, int paramInt5, boolean paramBoolean3, Object paramObject4, int paramInt6, boolean paramBoolean4, Object paramObject5, int paramInt7, boolean paramBoolean5, Object paramObject6, int paramInt8, boolean paramBoolean6, long paramLong);
  




  public int glGetDebugMessageLog(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int paramInt3, int[] paramArrayOfInt2, int paramInt4, int[] paramArrayOfInt3, int paramInt5, int[] paramArrayOfInt4, int paramInt6, int[] paramArrayOfInt5, int paramInt7, byte[] paramArrayOfByte, int paramInt8)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt3))
      throw new GLException("array offset argument \"sources_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt4))
      throw new GLException("array offset argument \"types_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    if ((paramArrayOfInt3 != null) && (paramArrayOfInt3.length <= paramInt5))
      throw new GLException("array offset argument \"ids_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt3.length + ")");
    if ((paramArrayOfInt4 != null) && (paramArrayOfInt4.length <= paramInt6))
      throw new GLException("array offset argument \"severities_offset\" (" + paramInt6 + ") equals or exceeds array length (" + paramArrayOfInt4.length + ")");
    if ((paramArrayOfInt5 != null) && (paramArrayOfInt5.length <= paramInt7))
      throw new GLException("array offset argument \"lengths_offset\" (" + paramInt7 + ") equals or exceeds array length (" + paramArrayOfInt5.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt8))
      throw new GLException("array offset argument \"messageLog_offset\" (" + paramInt8 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetDebugMessageLog;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDebugMessageLog" }));
    }
    return dispatch_glGetDebugMessageLog1(paramInt1, paramInt2, paramArrayOfInt1, 4 * paramInt3, false, paramArrayOfInt2, 4 * paramInt4, false, paramArrayOfInt3, 4 * paramInt5, false, paramArrayOfInt4, 4 * paramInt6, false, paramArrayOfInt5, 4 * paramInt7, false, paramArrayOfByte, paramInt8, false, l);
  }
  


  public void glPushDebugGroup(int paramInt1, int paramInt2, int paramInt3, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glPushDebugGroup;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPushDebugGroup" }));
    }
    dispatch_glPushDebugGroup1(paramInt1, paramInt2, paramInt3, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glPushDebugGroup1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glPushDebugGroup(int paramInt1, int paramInt2, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"message_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glPushDebugGroup;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPushDebugGroup" }));
    }
    dispatch_glPushDebugGroup1(paramInt1, paramInt2, paramInt3, paramArrayOfByte, paramInt4, false, l);
  }
  

  public void glPopDebugGroup()
  {
    long l = _pat._addressof_glPopDebugGroup;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPopDebugGroup" }));
    }
    dispatch_glPopDebugGroup1(l);
  }
  


  private native void dispatch_glPopDebugGroup1(long paramLong);
  

  public void glObjectLabel(int paramInt1, int paramInt2, int paramInt3, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glObjectLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glObjectLabel" }));
    }
    dispatch_glObjectLabel1(paramInt1, paramInt2, paramInt3, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glObjectLabel1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glObjectLabel(int paramInt1, int paramInt2, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"label_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glObjectLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glObjectLabel" }));
    }
    dispatch_glObjectLabel1(paramInt1, paramInt2, paramInt3, paramArrayOfByte, paramInt4, false, l);
  }
  



  public void glGetObjectLabel(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetObjectLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetObjectLabel" }));
    }
    dispatch_glGetObjectLabel1(paramInt1, paramInt2, paramInt3, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetObjectLabel1(int paramInt1, int paramInt2, int paramInt3, Object paramObject1, int paramInt4, boolean paramBoolean1, Object paramObject2, int paramInt5, boolean paramBoolean2, long paramLong);
  


  public void glGetObjectLabel(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4, byte[] paramArrayOfByte, int paramInt5)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt5))
      throw new GLException("array offset argument \"label_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetObjectLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetObjectLabel" }));
    }
    dispatch_glGetObjectLabel1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, paramArrayOfByte, paramInt5, false, l);
  }
  



  public void glObjectPtrLabel(Buffer paramBuffer, int paramInt, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glObjectPtrLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glObjectPtrLabel" }));
    }
    dispatch_glObjectPtrLabel1(bool1 ? paramBuffer : Buffers.getArray(paramBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool1, paramInt, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  



  private native void dispatch_glObjectPtrLabel1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glObjectPtrLabel(Buffer paramBuffer, int paramInt1, byte[] paramArrayOfByte, int paramInt2)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt2))
      throw new GLException("array offset argument \"label_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glObjectPtrLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glObjectPtrLabel" }));
    }
    dispatch_glObjectPtrLabel1(bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt1, paramArrayOfByte, paramInt2, false, l);
  }
  




  public void glGetObjectPtrLabel(Buffer paramBuffer, int paramInt, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramBuffer);
    boolean bool2 = Buffers.isDirect(paramIntBuffer);
    boolean bool3 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetObjectPtrLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetObjectPtrLabel" }));
    }
    dispatch_glGetObjectPtrLabel1(bool1 ? paramBuffer : Buffers.getArray(paramBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool1, paramInt, bool2 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool2, bool3 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool3 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool3, l);
  }
  



  private native void dispatch_glGetObjectPtrLabel1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, Object paramObject3, int paramInt4, boolean paramBoolean3, long paramLong);
  



  public void glGetObjectPtrLabel(Buffer paramBuffer, int paramInt1, int[] paramArrayOfInt, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"label_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetObjectPtrLabel;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetObjectPtrLabel" }));
    }
    dispatch_glGetObjectPtrLabel1(bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt1, paramArrayOfInt, 4 * paramInt2, false, paramArrayOfByte, paramInt3, false, l);
  }
  

  public void glEnablei(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glEnablei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnablei" }));
    }
    dispatch_glEnablei1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glEnablei1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisablei(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDisablei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisablei" }));
    }
    dispatch_glDisablei1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDisablei1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationi(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendEquationi;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationi" }));
    }
    dispatch_glBlendEquationi1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendEquationi1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationSeparatei(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendEquationSeparatei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationSeparatei" }));
    }
    dispatch_glBlendEquationSeparatei1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendEquationSeparatei1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFunci(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendFunci;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFunci" }));
    }
    dispatch_glBlendFunci1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendFunci1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFuncSeparatei(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glBlendFuncSeparatei;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFuncSeparatei" }));
    }
    dispatch_glBlendFuncSeparatei1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glBlendFuncSeparatei1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glColorMaski(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4)
  {
    long l = _pat._addressof_glColorMaski;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorMaski" }));
    }
    dispatch_glColorMaski1(paramInt, paramBoolean1, paramBoolean2, paramBoolean3, paramBoolean4, l);
  }
  

  private native void dispatch_glColorMaski1(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4, long paramLong);
  

  public boolean glIsEnabledi(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glIsEnabledi;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnabledi" }));
    }
    return dispatch_glIsEnabledi1(paramInt1, paramInt2, l);
  }
  


  private native boolean dispatch_glIsEnabledi1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDrawElementsBaseVertex(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsBaseVertex" }));
    }
    dispatch_glDrawElementsBaseVertex1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsBaseVertex1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  

  public void glDrawElementsBaseVertex(int paramInt1, int paramInt2, int paramInt3, long paramLong, int paramInt4)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElementsBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsBaseVertex" }));
    }
    dispatch_glDrawElementsBaseVertex1(paramInt1, paramInt2, paramInt3, paramLong, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsBaseVertex1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, int paramInt4, long paramLong2);
  

  public void glDrawRangeElementsBaseVertex(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Buffer paramBuffer, int paramInt6)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt4);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElementsBaseVertex" }));
    }
    dispatch_glDrawRangeElementsBaseVertex1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt6, l);
  }
  


  private native void dispatch_glDrawRangeElementsBaseVertex1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Object paramObject, int paramInt6, boolean paramBoolean, int paramInt7, long paramLong);
  

  public void glDrawRangeElementsBaseVertex(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong, int paramInt6)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElementsBaseVertex" }));
    }
    dispatch_glDrawRangeElementsBaseVertex1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramLong, paramInt6, l);
  }
  


  private native void dispatch_glDrawRangeElementsBaseVertex1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong1, int paramInt6, long paramLong2);
  

  public void glDrawElementsInstancedBaseVertex(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4, int paramInt5)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertex" }));
    }
    dispatch_glDrawElementsInstancedBaseVertex1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glDrawElementsInstancedBaseVertex1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, int paramInt6, long paramLong);
  

  public void glDrawElementsInstancedBaseVertex(int paramInt1, int paramInt2, int paramInt3, long paramLong, int paramInt4, int paramInt5)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertex" }));
    }
    dispatch_glDrawElementsInstancedBaseVertex1(paramInt1, paramInt2, paramInt3, paramLong, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glDrawElementsInstancedBaseVertex1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, int paramInt4, int paramInt5, long paramLong2);
  

  public void glFramebufferTexture(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glFramebufferTexture;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture" }));
    }
    dispatch_glFramebufferTexture1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glFramebufferTexture1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glPrimitiveBoundingBox(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8)
  {
    long l = _pat._addressof_glPrimitiveBoundingBox;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPrimitiveBoundingBox" }));
    }
    dispatch_glPrimitiveBoundingBox1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, paramFloat6, paramFloat7, paramFloat8, l);
  }
  

  private native void dispatch_glPrimitiveBoundingBox1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8, long paramLong);
  

  public int glGetGraphicsResetStatus()
  {
    long l = _pat._addressof_glGetGraphicsResetStatus;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetGraphicsResetStatus" }));
    }
    return dispatch_glGetGraphicsResetStatus1(l);
  }
  


  private native int dispatch_glGetGraphicsResetStatus1(long paramLong);
  

  public void glReadnPixels(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glReadnPixels;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadnPixels" }));
    }
    dispatch_glReadnPixels1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glReadnPixels1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, Object paramObject, int paramInt8, boolean paramBoolean, long paramLong);
  


  public void glGetnUniformfv(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetnUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformfv" }));
    }
    dispatch_glGetnUniformfv1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetnUniformfv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetnUniformfv(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetnUniformfv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformfv" }));
    }
    dispatch_glGetnUniformfv1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glGetnUniformiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetnUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformiv" }));
    }
    dispatch_glGetnUniformiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetnUniformiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetnUniformiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetnUniformiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformiv" }));
    }
    dispatch_glGetnUniformiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  


  public void glGetnUniformuiv(int paramInt1, int paramInt2, int paramInt3, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetnUniformuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformuiv" }));
    }
    dispatch_glGetnUniformuiv1(paramInt1, paramInt2, paramInt3, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetnUniformuiv1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glGetnUniformuiv(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetnUniformuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetnUniformuiv" }));
    }
    dispatch_glGetnUniformuiv1(paramInt1, paramInt2, paramInt3, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  

  public void glMinSampleShading(float paramFloat)
  {
    long l = _pat._addressof_glMinSampleShading;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMinSampleShading" }));
    }
    dispatch_glMinSampleShading1(paramFloat, l);
  }
  

  private native void dispatch_glMinSampleShading1(float paramFloat, long paramLong);
  

  public void glPatchParameteri(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPatchParameteri;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPatchParameteri" }));
    }
    dispatch_glPatchParameteri1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glPatchParameteri1(int paramInt1, int paramInt2, long paramLong);
  

  public void glTexParameterIiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterIiv" }));
    }
    dispatch_glTexParameterIiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameterIiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameterIiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterIiv" }));
    }
    dispatch_glTexParameterIiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glTexParameterIuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glTexParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterIuiv" }));
    }
    dispatch_glTexParameterIuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glTexParameterIuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glTexParameterIuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glTexParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexParameterIuiv" }));
    }
    dispatch_glTexParameterIuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameterIiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterIiv" }));
    }
    dispatch_glGetTexParameterIiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameterIiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameterIiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterIiv" }));
    }
    dispatch_glGetTexParameterIiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetTexParameterIuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetTexParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterIuiv" }));
    }
    dispatch_glGetTexParameterIuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetTexParameterIuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetTexParameterIuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetTexParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTexParameterIuiv" }));
    }
    dispatch_glGetTexParameterIuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glSamplerParameterIiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glSamplerParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterIiv" }));
    }
    dispatch_glSamplerParameterIiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glSamplerParameterIiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glSamplerParameterIiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"param_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glSamplerParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterIiv" }));
    }
    dispatch_glSamplerParameterIiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glSamplerParameterIuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glSamplerParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterIuiv" }));
    }
    dispatch_glSamplerParameterIuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glSamplerParameterIuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glSamplerParameterIuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"param_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glSamplerParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSamplerParameterIuiv" }));
    }
    dispatch_glSamplerParameterIuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetSamplerParameterIiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetSamplerParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterIiv" }));
    }
    dispatch_glGetSamplerParameterIiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetSamplerParameterIiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetSamplerParameterIiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetSamplerParameterIiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterIiv" }));
    }
    dispatch_glGetSamplerParameterIiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetSamplerParameterIuiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetSamplerParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterIuiv" }));
    }
    dispatch_glGetSamplerParameterIuiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetSamplerParameterIuiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetSamplerParameterIuiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetSamplerParameterIuiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetSamplerParameterIuiv" }));
    }
    dispatch_glGetSamplerParameterIuiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glTexBuffer(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBuffer" }));
    }
    dispatch_glTexBuffer1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glTexBuffer1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexBufferRange(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glTexBufferRange;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBufferRange" }));
    }
    dispatch_glTexBufferRange1(paramInt1, paramInt2, paramInt3, paramLong1, paramLong2, l);
  }
  

  private native void dispatch_glTexBufferRange1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2, long paramLong3);
  

  public void glTexStorage3DMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexStorage3DMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage3DMultisample" }));
    }
    dispatch_glTexStorage3DMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramBoolean, l);
  }
  

  private native void dispatch_glTexStorage3DMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean, long paramLong);
  

  public void glTexStorage1D(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glTexStorage1D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage1D" }));
    }
    dispatch_glTexStorage1D1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glTexStorage1D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glTextureStorage1DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glTextureStorage1DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage1DEXT" }));
    }
    dispatch_glTextureStorage1DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glTextureStorage1DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glTextureStorage2DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glTextureStorage2DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage2DEXT" }));
    }
    dispatch_glTextureStorage2DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glTextureStorage2DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glTextureStorage3DEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7)
  {
    long l = _pat._addressof_glTextureStorage3DEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureStorage3DEXT" }));
    }
    dispatch_glTextureStorage3DEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, l);
  }
  

  private native void dispatch_glTextureStorage3DEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, long paramLong);
  

  public void glTexImage2DMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexImage2DMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage2DMultisample" }));
    }
    dispatch_glTexImage2DMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramBoolean, l);
  }
  

  private native void dispatch_glTexImage2DMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean, long paramLong);
  

  public void glTexImage3DMultisample(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexImage3DMultisample;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexImage3DMultisample" }));
    }
    dispatch_glTexImage3DMultisample1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramBoolean, l);
  }
  

  private native void dispatch_glTexImage3DMultisample1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean, long paramLong);
  

  public void glEGLImageTargetTexture2DOES(int paramInt, long paramLong)
  {
    long l = _pat._addressof_glEGLImageTargetTexture2DOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEGLImageTargetTexture2DOES" }));
    }
    dispatch_glEGLImageTargetTexture2DOES1(paramInt, paramLong, l);
  }
  

  private native void dispatch_glEGLImageTargetTexture2DOES1(int paramInt, long paramLong1, long paramLong2);
  

  public void glEGLImageTargetRenderbufferStorageOES(int paramInt, long paramLong)
  {
    long l = _pat._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEGLImageTargetRenderbufferStorageOES" }));
    }
    dispatch_glEGLImageTargetRenderbufferStorageOES1(paramInt, paramLong, l);
  }
  

  private native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int paramInt, long paramLong1, long paramLong2);
  

  public void glEnableiOES(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glEnableiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableiOES" }));
    }
    dispatch_glEnableiOES1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glEnableiOES1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisableiOES(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDisableiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableiOES" }));
    }
    dispatch_glDisableiOES1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDisableiOES1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationiOES(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendEquationiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationiOES" }));
    }
    dispatch_glBlendEquationiOES1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendEquationiOES1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationSeparateiOES(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendEquationSeparateiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationSeparateiOES" }));
    }
    dispatch_glBlendEquationSeparateiOES1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendEquationSeparateiOES1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFunciOES(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendFunciOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFunciOES" }));
    }
    dispatch_glBlendFunciOES1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendFunciOES1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFuncSeparateiOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glBlendFuncSeparateiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFuncSeparateiOES" }));
    }
    dispatch_glBlendFuncSeparateiOES1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glBlendFuncSeparateiOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glColorMaskiOES(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4)
  {
    long l = _pat._addressof_glColorMaskiOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorMaskiOES" }));
    }
    dispatch_glColorMaskiOES1(paramInt, paramBoolean1, paramBoolean2, paramBoolean3, paramBoolean4, l);
  }
  

  private native void dispatch_glColorMaskiOES1(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4, long paramLong);
  

  public boolean glIsEnablediOES(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glIsEnablediOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnablediOES" }));
    }
    return dispatch_glIsEnablediOES1(paramInt1, paramInt2, l);
  }
  


  private native boolean dispatch_glIsEnablediOES1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDrawElementsBaseVertexOES(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsBaseVertexOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsBaseVertexOES" }));
    }
    dispatch_glDrawElementsBaseVertexOES1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsBaseVertexOES1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  


  public void glDrawRangeElementsBaseVertexOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Buffer paramBuffer, int paramInt6)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawRangeElementsBaseVertexOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElementsBaseVertexOES" }));
    }
    dispatch_glDrawRangeElementsBaseVertexOES1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt6, l);
  }
  


  private native void dispatch_glDrawRangeElementsBaseVertexOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Object paramObject, int paramInt6, boolean paramBoolean, int paramInt7, long paramLong);
  


  public void glDrawElementsInstancedBaseVertexOES(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4, int paramInt5)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertexOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertexOES" }));
    }
    dispatch_glDrawElementsInstancedBaseVertexOES1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, paramInt5, l);
  }
  



  private native void dispatch_glDrawElementsInstancedBaseVertexOES1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, int paramInt6, long paramLong);
  



  public void glMultiDrawElementsBaseVertexOES(int paramInt1, IntBuffer paramIntBuffer1, int paramInt2, PointerBuffer paramPointerBuffer, int paramInt3, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramPointerBuffer);
    boolean bool3 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glMultiDrawElementsBaseVertexOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawElementsBaseVertexOES" }));
    }
    dispatch_glMultiDrawElementsBaseVertexOES1(paramInt1, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt2, bool2 ? null : paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : Buffers.getArray(paramPointerBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramPointerBuffer) : Buffers.getIndirectBufferByteOffset(paramPointerBuffer), bool2, paramInt3, bool3 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool3, l);
  }
  



  private native void dispatch_glMultiDrawElementsBaseVertexOES1(int paramInt1, Object paramObject1, int paramInt2, boolean paramBoolean1, int paramInt3, Object paramObject2, int paramInt4, boolean paramBoolean2, int paramInt5, Object paramObject3, int paramInt6, boolean paramBoolean3, long paramLong);
  



  public void glMultiDrawElementsBaseVertexOES(int paramInt1, int[] paramArrayOfInt1, int paramInt2, int paramInt3, PointerBuffer paramPointerBuffer, int paramInt4, int[] paramArrayOfInt2, int paramInt5)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt2))
      throw new GLException("array offset argument \"count_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    boolean bool = Buffers.isDirect(paramPointerBuffer);
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"basevertex_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glMultiDrawElementsBaseVertexOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawElementsBaseVertexOES" }));
    }
    dispatch_glMultiDrawElementsBaseVertexOES1(paramInt1, paramArrayOfInt1, 4 * paramInt2, false, paramInt3, bool ? null : paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : Buffers.getArray(paramPointerBuffer), bool ? Buffers.getDirectBufferByteOffset(paramPointerBuffer) : Buffers.getIndirectBufferByteOffset(paramPointerBuffer), bool, paramInt4, paramArrayOfInt2, 4 * paramInt5, false, l);
  }
  

  public void glFramebufferTextureOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glFramebufferTextureOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTextureOES" }));
    }
    dispatch_glFramebufferTextureOES1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  







  private native void dispatch_glFramebufferTextureOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  







  private long glMapBufferDelegate(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glMapBuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMapBuffer" }));
    }
    return dispatch_glMapBufferDelegate1(paramInt1, paramInt2, l);
  }
  







  private native long dispatch_glMapBufferDelegate1(int paramInt1, int paramInt2, long paramLong);
  







  public void glPrimitiveBoundingBoxOES(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8)
  {
    long l = _pat._addressof_glPrimitiveBoundingBoxOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPrimitiveBoundingBoxOES" }));
    }
    dispatch_glPrimitiveBoundingBoxOES1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, paramFloat6, paramFloat7, paramFloat8, l);
  }
  

  private native void dispatch_glPrimitiveBoundingBoxOES1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8, long paramLong);
  

  public void glMinSampleShadingOES(float paramFloat)
  {
    long l = _pat._addressof_glMinSampleShadingOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMinSampleShadingOES" }));
    }
    dispatch_glMinSampleShadingOES1(paramFloat, l);
  }
  

  private native void dispatch_glMinSampleShadingOES1(float paramFloat, long paramLong);
  

  public void glPatchParameteriOES(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPatchParameteriOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPatchParameteriOES" }));
    }
    dispatch_glPatchParameteriOES1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPatchParameteriOES1(int paramInt1, int paramInt2, long paramLong);
  

  public void glFramebufferTexture3D(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTexture3D;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture3D" }));
    }
    dispatch_glFramebufferTexture3D1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glFramebufferTexture3D1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glTexBufferOES(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexBufferOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBufferOES" }));
    }
    dispatch_glTexBufferOES1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glTexBufferOES1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexBufferRangeOES(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glTexBufferRangeOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBufferRangeOES" }));
    }
    dispatch_glTexBufferRangeOES1(paramInt1, paramInt2, paramInt3, paramLong1, paramLong2, l);
  }
  

  private native void dispatch_glTexBufferRangeOES1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2, long paramLong3);
  

  public void glTexStorage3DMultisampleOES(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexStorage3DMultisampleOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexStorage3DMultisampleOES" }));
    }
    dispatch_glTexStorage3DMultisampleOES1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramBoolean, l);
  }
  

  private native void dispatch_glTexStorage3DMultisampleOES1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, boolean paramBoolean, long paramLong);
  

  public void glTextureView(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    long l = _pat._addressof_glTextureView;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTextureView" }));
    }
    dispatch_glTextureView1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, l);
  }
  

  private native void dispatch_glTextureView1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, long paramLong);
  

  public void glBindVertexArrayOES(int paramInt)
  {
    long l = _pat._addressof_glBindVertexArrayOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindVertexArrayOES" }));
    }
    dispatch_glBindVertexArrayOES1(paramInt, l);
  }
  


  private native void dispatch_glBindVertexArrayOES1(int paramInt, long paramLong);
  

  public void glDeleteVertexArraysOES(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDeleteVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArraysOES" }));
    }
    dispatch_glDeleteVertexArraysOES1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDeleteVertexArraysOES1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glDeleteVertexArraysOES(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDeleteVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDeleteVertexArraysOES" }));
    }
    dispatch_glDeleteVertexArraysOES1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glGenVertexArraysOES(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGenVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArraysOES" }));
    }
    dispatch_glGenVertexArraysOES1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGenVertexArraysOES1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGenVertexArraysOES(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"arrays_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGenVertexArraysOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGenVertexArraysOES" }));
    }
    dispatch_glGenVertexArraysOES1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  

  public boolean glIsVertexArrayOES(int paramInt)
  {
    long l = _pat._addressof_glIsVertexArrayOES;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsVertexArrayOES" }));
    }
    return dispatch_glIsVertexArrayOES1(paramInt, l);
  }
  

  private native boolean dispatch_glIsVertexArrayOES1(int paramInt, long paramLong);
  

  public void glBlitFramebufferANGLE(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10)
  {
    long l = _pat._addressof_glBlitFramebufferANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlitFramebufferANGLE" }));
    }
    dispatch_glBlitFramebufferANGLE1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, l);
  }
  

  private native void dispatch_glBlitFramebufferANGLE1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong);
  

  public void glDrawArraysInstancedANGLE(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glDrawArraysInstancedANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysInstancedANGLE" }));
    }
    dispatch_glDrawArraysInstancedANGLE1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glDrawArraysInstancedANGLE1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glDrawElementsInstancedANGLE(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedANGLE" }));
    }
    dispatch_glDrawElementsInstancedANGLE1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsInstancedANGLE1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  

  public void glVertexAttribDivisorANGLE(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glVertexAttribDivisorANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribDivisorANGLE" }));
    }
    dispatch_glVertexAttribDivisorANGLE1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glVertexAttribDivisorANGLE1(int paramInt1, int paramInt2, long paramLong);
  


  public void glGetTranslatedShaderSourceANGLE(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetTranslatedShaderSourceANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTranslatedShaderSourceANGLE" }));
    }
    dispatch_glGetTranslatedShaderSourceANGLE1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetTranslatedShaderSourceANGLE1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetTranslatedShaderSourceANGLE(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"source_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetTranslatedShaderSourceANGLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetTranslatedShaderSourceANGLE" }));
    }
    dispatch_glGetTranslatedShaderSourceANGLE1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  

  public void glCopyTextureLevelsAPPLE(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glCopyTextureLevelsAPPLE;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyTextureLevelsAPPLE" }));
    }
    dispatch_glCopyTextureLevelsAPPLE1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  

  private native void dispatch_glCopyTextureLevelsAPPLE1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glResolveMultisampleFramebuffer()
  {
    long l = _pat._addressof_glResolveMultisampleFramebuffer;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glResolveMultisampleFramebuffer" }));
    }
    dispatch_glResolveMultisampleFramebuffer1(l);
  }
  

  private native void dispatch_glResolveMultisampleFramebuffer1(long paramLong);
  

  public void glDrawArraysInstancedBaseInstance(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glDrawArraysInstancedBaseInstance;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysInstancedBaseInstance" }));
    }
    dispatch_glDrawArraysInstancedBaseInstance1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glDrawArraysInstancedBaseInstance1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glDrawElementsInstancedBaseInstance(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4, int paramInt5)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseInstance" }));
    }
    dispatch_glDrawElementsInstancedBaseInstance1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glDrawElementsInstancedBaseInstance1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, int paramInt6, long paramLong);
  

  public void glDrawElementsInstancedBaseInstance(int paramInt1, int paramInt2, int paramInt3, long paramLong, int paramInt4, int paramInt5)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseInstance" }));
    }
    dispatch_glDrawElementsInstancedBaseInstance1(paramInt1, paramInt2, paramInt3, paramLong, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glDrawElementsInstancedBaseInstance1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, int paramInt4, int paramInt5, long paramLong2);
  

  public void glDrawElementsInstancedBaseVertexBaseInstance(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4, int paramInt5, int paramInt6)
  {
    checkElementVBOUnbound(true);
    Buffers.rangeCheck(paramBuffer, paramInt2);
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertexBaseInstance" }));
    }
    dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, int paramInt6, int paramInt7, long paramLong);
  

  public void glDrawElementsInstancedBaseVertexBaseInstance(int paramInt1, int paramInt2, int paramInt3, long paramLong, int paramInt4, int paramInt5, int paramInt6)
  {
    checkElementVBOBound(true);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertexBaseInstance" }));
    }
    dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(paramInt1, paramInt2, paramInt3, paramLong, paramInt4, paramInt5, paramInt6, l);
  }
  


  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, int paramInt4, int paramInt5, int paramInt6, long paramLong2);
  

  public void glBindFragDataLocationIndexedEXT(int paramInt1, int paramInt2, int paramInt3, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glBindFragDataLocationIndexedEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFragDataLocationIndexedEXT" }));
    }
    dispatch_glBindFragDataLocationIndexedEXT1(paramInt1, paramInt2, paramInt3, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glBindFragDataLocationIndexedEXT1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glBindFragDataLocationIndexedEXT(int paramInt1, int paramInt2, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glBindFragDataLocationIndexedEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFragDataLocationIndexedEXT" }));
    }
    dispatch_glBindFragDataLocationIndexedEXT1(paramInt1, paramInt2, paramInt3, paramArrayOfByte, paramInt4, false, l);
  }
  


  public void glBindFragDataLocationEXT(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glBindFragDataLocationEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFragDataLocationEXT" }));
    }
    dispatch_glBindFragDataLocationEXT1(paramInt1, paramInt2, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native void dispatch_glBindFragDataLocationEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glBindFragDataLocationEXT(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glBindFragDataLocationEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBindFragDataLocationEXT" }));
    }
    dispatch_glBindFragDataLocationEXT1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, l);
  }
  


  public int glGetProgramResourceLocationIndexEXT(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetProgramResourceLocationIndexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceLocationIndexEXT" }));
    }
    return dispatch_glGetProgramResourceLocationIndexEXT1(paramInt1, paramInt2, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native int dispatch_glGetProgramResourceLocationIndexEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public int glGetProgramResourceLocationIndexEXT(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetProgramResourceLocationIndexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetProgramResourceLocationIndexEXT" }));
    }
    return dispatch_glGetProgramResourceLocationIndexEXT1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, l);
  }
  


  public int glGetFragDataIndexEXT(int paramInt, ByteBuffer paramByteBuffer)
  {
    boolean bool = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetFragDataIndexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFragDataIndexEXT" }));
    }
    return dispatch_glGetFragDataIndexEXT1(paramInt, bool ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool, l);
  }
  


  private native int dispatch_glGetFragDataIndexEXT1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public int glGetFragDataIndexEXT(int paramInt1, byte[] paramArrayOfByte, int paramInt2)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt2))
      throw new GLException("array offset argument \"name_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetFragDataIndexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFragDataIndexEXT" }));
    }
    return dispatch_glGetFragDataIndexEXT1(paramInt1, paramArrayOfByte, paramInt2, false, l);
  }
  


  public void glBufferStorageEXT(int paramInt1, long paramLong, Buffer paramBuffer, int paramInt2)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glBufferStorageEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBufferStorageEXT" }));
    }
    dispatch_glBufferStorageEXT1(paramInt1, paramLong, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt2, l);
  }
  


  private native void dispatch_glBufferStorageEXT1(int paramInt1, long paramLong1, Object paramObject, int paramInt2, boolean paramBoolean, int paramInt3, long paramLong2);
  


  public void glDiscardFramebufferEXT(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glDiscardFramebufferEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDiscardFramebufferEXT" }));
    }
    dispatch_glDiscardFramebufferEXT1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glDiscardFramebufferEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glDiscardFramebufferEXT(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"attachments_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glDiscardFramebufferEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDiscardFramebufferEXT" }));
    }
    dispatch_glDiscardFramebufferEXT1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glQueryCounter(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glQueryCounter;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glQueryCounter" }));
    }
    dispatch_glQueryCounter1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glQueryCounter1(int paramInt1, int paramInt2, long paramLong);
  

  public void glGetQueryObjectiv(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetQueryObjectiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectiv" }));
    }
    dispatch_glGetQueryObjectiv1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetQueryObjectiv1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetQueryObjectiv(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetQueryObjectiv;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectiv" }));
    }
    dispatch_glGetQueryObjectiv1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  


  public void glGetQueryObjecti64v(int paramInt1, int paramInt2, LongBuffer paramLongBuffer)
  {
    boolean bool = Buffers.isDirect(paramLongBuffer);
    long l = _pat._addressof_glGetQueryObjecti64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjecti64v" }));
    }
    dispatch_glGetQueryObjecti64v1(paramInt1, paramInt2, bool ? paramLongBuffer : Buffers.getArray(paramLongBuffer), bool ? Buffers.getDirectBufferByteOffset(paramLongBuffer) : Buffers.getIndirectBufferByteOffset(paramLongBuffer), bool, l);
  }
  


  private native void dispatch_glGetQueryObjecti64v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetQueryObjecti64v(int paramInt1, int paramInt2, long[] paramArrayOfLong, int paramInt3)
  {
    if ((paramArrayOfLong != null) && (paramArrayOfLong.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfLong.length + ")");
    long l = _pat._addressof_glGetQueryObjecti64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjecti64v" }));
    }
    dispatch_glGetQueryObjecti64v1(paramInt1, paramInt2, paramArrayOfLong, 8 * paramInt3, false, l);
  }
  


  public void glGetQueryObjectui64v(int paramInt1, int paramInt2, LongBuffer paramLongBuffer)
  {
    boolean bool = Buffers.isDirect(paramLongBuffer);
    long l = _pat._addressof_glGetQueryObjectui64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectui64v" }));
    }
    dispatch_glGetQueryObjectui64v1(paramInt1, paramInt2, bool ? paramLongBuffer : Buffers.getArray(paramLongBuffer), bool ? Buffers.getDirectBufferByteOffset(paramLongBuffer) : Buffers.getIndirectBufferByteOffset(paramLongBuffer), bool, l);
  }
  


  private native void dispatch_glGetQueryObjectui64v1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetQueryObjectui64v(int paramInt1, int paramInt2, long[] paramArrayOfLong, int paramInt3)
  {
    if ((paramArrayOfLong != null) && (paramArrayOfLong.length <= paramInt3))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfLong.length + ")");
    long l = _pat._addressof_glGetQueryObjectui64v;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetQueryObjectui64v" }));
    }
    dispatch_glGetQueryObjectui64v1(paramInt1, paramInt2, paramArrayOfLong, 8 * paramInt3, false, l);
  }
  

  public void glEnableiEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glEnableiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableiEXT" }));
    }
    dispatch_glEnableiEXT1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glEnableiEXT1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisableiEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDisableiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableiEXT" }));
    }
    dispatch_glDisableiEXT1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDisableiEXT1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationiEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBlendEquationiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationiEXT" }));
    }
    dispatch_glBlendEquationiEXT1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBlendEquationiEXT1(int paramInt1, int paramInt2, long paramLong);
  

  public void glBlendEquationSeparateiEXT(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendEquationSeparateiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendEquationSeparateiEXT" }));
    }
    dispatch_glBlendEquationSeparateiEXT1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendEquationSeparateiEXT1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFunciEXT(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glBlendFunciEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFunciEXT" }));
    }
    dispatch_glBlendFunciEXT1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glBlendFunciEXT1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glBlendFuncSeparateiEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glBlendFuncSeparateiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlendFuncSeparateiEXT" }));
    }
    dispatch_glBlendFuncSeparateiEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glBlendFuncSeparateiEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glColorMaskiEXT(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4)
  {
    long l = _pat._addressof_glColorMaskiEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glColorMaskiEXT" }));
    }
    dispatch_glColorMaskiEXT1(paramInt, paramBoolean1, paramBoolean2, paramBoolean3, paramBoolean4, l);
  }
  

  private native void dispatch_glColorMaskiEXT1(int paramInt, boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, boolean paramBoolean4, long paramLong);
  

  public boolean glIsEnablediEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glIsEnablediEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnablediEXT" }));
    }
    return dispatch_glIsEnablediEXT1(paramInt1, paramInt2, l);
  }
  


  private native boolean dispatch_glIsEnablediEXT1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDrawElementsBaseVertexEXT(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsBaseVertexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsBaseVertexEXT" }));
    }
    dispatch_glDrawElementsBaseVertexEXT1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsBaseVertexEXT1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  


  public void glDrawRangeElementsBaseVertexEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Buffer paramBuffer, int paramInt6)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawRangeElementsBaseVertexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawRangeElementsBaseVertexEXT" }));
    }
    dispatch_glDrawRangeElementsBaseVertexEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt6, l);
  }
  


  private native void dispatch_glDrawRangeElementsBaseVertexEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, Object paramObject, int paramInt6, boolean paramBoolean, int paramInt7, long paramLong);
  


  public void glDrawElementsInstancedBaseVertexEXT(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4, int paramInt5)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedBaseVertexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedBaseVertexEXT" }));
    }
    dispatch_glDrawElementsInstancedBaseVertexEXT1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, paramInt5, l);
  }
  



  private native void dispatch_glDrawElementsInstancedBaseVertexEXT1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, int paramInt6, long paramLong);
  



  public void glMultiDrawElementsBaseVertexEXT(int paramInt1, IntBuffer paramIntBuffer1, int paramInt2, PointerBuffer paramPointerBuffer, int paramInt3, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramPointerBuffer);
    boolean bool3 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glMultiDrawElementsBaseVertexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawElementsBaseVertexEXT" }));
    }
    dispatch_glMultiDrawElementsBaseVertexEXT1(paramInt1, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt2, bool2 ? null : paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : Buffers.getArray(paramPointerBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramPointerBuffer) : Buffers.getIndirectBufferByteOffset(paramPointerBuffer), bool2, paramInt3, bool3 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool3 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool3, l);
  }
  



  private native void dispatch_glMultiDrawElementsBaseVertexEXT1(int paramInt1, Object paramObject1, int paramInt2, boolean paramBoolean1, int paramInt3, Object paramObject2, int paramInt4, boolean paramBoolean2, int paramInt5, Object paramObject3, int paramInt6, boolean paramBoolean3, long paramLong);
  



  public void glMultiDrawElementsBaseVertexEXT(int paramInt1, int[] paramArrayOfInt1, int paramInt2, int paramInt3, PointerBuffer paramPointerBuffer, int paramInt4, int[] paramArrayOfInt2, int paramInt5)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt2))
      throw new GLException("array offset argument \"count_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    boolean bool = Buffers.isDirect(paramPointerBuffer);
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt5))
      throw new GLException("array offset argument \"basevertex_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glMultiDrawElementsBaseVertexEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawElementsBaseVertexEXT" }));
    }
    dispatch_glMultiDrawElementsBaseVertexEXT1(paramInt1, paramArrayOfInt1, 4 * paramInt2, false, paramInt3, bool ? null : paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : Buffers.getArray(paramPointerBuffer), bool ? Buffers.getDirectBufferByteOffset(paramPointerBuffer) : Buffers.getIndirectBufferByteOffset(paramPointerBuffer), bool, paramInt4, paramArrayOfInt2, 4 * paramInt5, false, l);
  }
  

  public void glFramebufferTextureEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glFramebufferTextureEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTextureEXT" }));
    }
    dispatch_glFramebufferTextureEXT1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glFramebufferTextureEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glMultiDrawArraysIndirectEXT(int paramInt1, Buffer paramBuffer, int paramInt2, int paramInt3)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glMultiDrawArraysIndirectEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawArraysIndirectEXT" }));
    }
    dispatch_glMultiDrawArraysIndirectEXT1(paramInt1, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glMultiDrawArraysIndirectEXT1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, int paramInt3, int paramInt4, long paramLong);
  


  public void glMultiDrawElementsIndirectEXT(int paramInt1, int paramInt2, Buffer paramBuffer, int paramInt3, int paramInt4)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glMultiDrawElementsIndirectEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glMultiDrawElementsIndirectEXT" }));
    }
    dispatch_glMultiDrawElementsIndirectEXT1(paramInt1, paramInt2, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glMultiDrawElementsIndirectEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, int paramInt4, int paramInt5, long paramLong);
  

  public void glRenderbufferStorageMultisampleEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisampleEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisampleEXT" }));
    }
    dispatch_glRenderbufferStorageMultisampleEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisampleEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFramebufferTexture2DMultisampleEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTexture2DMultisampleEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2DMultisampleEXT" }));
    }
    dispatch_glFramebufferTexture2DMultisampleEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glFramebufferTexture2DMultisampleEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glReadBufferIndexedEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glReadBufferIndexedEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadBufferIndexedEXT" }));
    }
    dispatch_glReadBufferIndexedEXT1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glReadBufferIndexedEXT1(int paramInt1, int paramInt2, long paramLong);
  


  public void glDrawBuffersIndexedEXT(int paramInt, IntBuffer paramIntBuffer1, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glDrawBuffersIndexedEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawBuffersIndexedEXT" }));
    }
    dispatch_glDrawBuffersIndexedEXT1(paramInt, bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glDrawBuffersIndexedEXT1(int paramInt1, Object paramObject1, int paramInt2, boolean paramBoolean1, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glDrawBuffersIndexedEXT(int paramInt1, int[] paramArrayOfInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt2))
      throw new GLException("array offset argument \"location_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"indices_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glDrawBuffersIndexedEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawBuffersIndexedEXT" }));
    }
    dispatch_glDrawBuffersIndexedEXT1(paramInt1, paramArrayOfInt1, 4 * paramInt2, false, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  


  public void glGetIntegeri_vEXT(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glGetIntegeri_vEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegeri_vEXT" }));
    }
    dispatch_glGetIntegeri_vEXT1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glGetIntegeri_vEXT1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetIntegeri_vEXT(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glGetIntegeri_vEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetIntegeri_vEXT" }));
    }
    dispatch_glGetIntegeri_vEXT1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glPrimitiveBoundingBoxEXT(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8)
  {
    long l = _pat._addressof_glPrimitiveBoundingBoxEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPrimitiveBoundingBoxEXT" }));
    }
    dispatch_glPrimitiveBoundingBoxEXT1(paramFloat1, paramFloat2, paramFloat3, paramFloat4, paramFloat5, paramFloat6, paramFloat7, paramFloat8, l);
  }
  

  private native void dispatch_glPrimitiveBoundingBoxEXT1(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, float paramFloat6, float paramFloat7, float paramFloat8, long paramLong);
  

  public void glRasterSamplesEXT(int paramInt, boolean paramBoolean)
  {
    long l = _pat._addressof_glRasterSamplesEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRasterSamplesEXT" }));
    }
    dispatch_glRasterSamplesEXT1(paramInt, paramBoolean, l);
  }
  

  private native void dispatch_glRasterSamplesEXT1(int paramInt, boolean paramBoolean, long paramLong);
  

  public void glTexPageCommitmentEXT(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, boolean paramBoolean)
  {
    long l = _pat._addressof_glTexPageCommitmentEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexPageCommitmentEXT" }));
    }
    dispatch_glTexPageCommitmentEXT1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramBoolean, l);
  }
  

  private native void dispatch_glTexPageCommitmentEXT1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, boolean paramBoolean, long paramLong);
  

  public void glPatchParameteriEXT(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPatchParameteriEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPatchParameteriEXT" }));
    }
    dispatch_glPatchParameteriEXT1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPatchParameteriEXT1(int paramInt1, int paramInt2, long paramLong);
  

  public void glTexBufferEXT(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glTexBufferEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBufferEXT" }));
    }
    dispatch_glTexBufferEXT1(paramInt1, paramInt2, paramInt3, l);
  }
  

  private native void dispatch_glTexBufferEXT1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glTexBufferRangeEXT(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2)
  {
    long l = _pat._addressof_glTexBufferRangeEXT;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glTexBufferRangeEXT" }));
    }
    dispatch_glTexBufferRangeEXT1(paramInt1, paramInt2, paramInt3, paramLong1, paramLong2, l);
  }
  

  private native void dispatch_glTexBufferRangeEXT1(int paramInt1, int paramInt2, int paramInt3, long paramLong1, long paramLong2, long paramLong3);
  

  public void glRenderbufferStorageMultisampleIMG(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisampleIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisampleIMG" }));
    }
    dispatch_glRenderbufferStorageMultisampleIMG1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisampleIMG1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glFramebufferTexture2DMultisampleIMG(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTexture2DMultisampleIMG;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTexture2DMultisampleIMG" }));
    }
    dispatch_glFramebufferTexture2DMultisampleIMG1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glFramebufferTexture2DMultisampleIMG1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glApplyFramebufferAttachmentCMAAINTEL()
  {
    long l = _pat._addressof_glApplyFramebufferAttachmentCMAAINTEL;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glApplyFramebufferAttachmentCMAAINTEL" }));
    }
    dispatch_glApplyFramebufferAttachmentCMAAINTEL1(l);
  }
  

  private native void dispatch_glApplyFramebufferAttachmentCMAAINTEL1(long paramLong);
  

  public void glBeginConditionalRender(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glBeginConditionalRender;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBeginConditionalRender" }));
    }
    dispatch_glBeginConditionalRender1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glBeginConditionalRender1(int paramInt1, int paramInt2, long paramLong);
  

  public void glEndConditionalRender()
  {
    long l = _pat._addressof_glEndConditionalRender;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEndConditionalRender" }));
    }
    dispatch_glEndConditionalRender1(l);
  }
  

  private native void dispatch_glEndConditionalRender1(long paramLong);
  

  public void glSubpixelPrecisionBiasNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glSubpixelPrecisionBiasNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glSubpixelPrecisionBiasNV" }));
    }
    dispatch_glSubpixelPrecisionBiasNV1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glSubpixelPrecisionBiasNV1(int paramInt1, int paramInt2, long paramLong);
  

  public void glCopyBufferSubDataNV(int paramInt1, int paramInt2, long paramLong1, long paramLong2, long paramLong3)
  {
    long l = _pat._addressof_glCopyBufferSubDataNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCopyBufferSubDataNV" }));
    }
    dispatch_glCopyBufferSubDataNV1(paramInt1, paramInt2, paramLong1, paramLong2, paramLong3, l);
  }
  

  private native void dispatch_glCopyBufferSubDataNV1(int paramInt1, int paramInt2, long paramLong1, long paramLong2, long paramLong3, long paramLong4);
  

  public void glCoverageMaskNV(boolean paramBoolean)
  {
    long l = _pat._addressof_glCoverageMaskNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCoverageMaskNV" }));
    }
    dispatch_glCoverageMaskNV1(paramBoolean, l);
  }
  

  private native void dispatch_glCoverageMaskNV1(boolean paramBoolean, long paramLong);
  

  public void glCoverageOperationNV(int paramInt)
  {
    long l = _pat._addressof_glCoverageOperationNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCoverageOperationNV" }));
    }
    dispatch_glCoverageOperationNV1(paramInt, l);
  }
  

  private native void dispatch_glCoverageOperationNV1(int paramInt, long paramLong);
  

  public void glDrawArraysInstancedNV(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    long l = _pat._addressof_glDrawArraysInstancedNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawArraysInstancedNV" }));
    }
    dispatch_glDrawArraysInstancedNV1(paramInt1, paramInt2, paramInt3, paramInt4, l);
  }
  


  private native void dispatch_glDrawArraysInstancedNV1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, long paramLong);
  

  public void glDrawElementsInstancedNV(int paramInt1, int paramInt2, int paramInt3, Buffer paramBuffer, int paramInt4)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glDrawElementsInstancedNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDrawElementsInstancedNV" }));
    }
    dispatch_glDrawElementsInstancedNV1(paramInt1, paramInt2, paramInt3, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, paramInt4, l);
  }
  


  private native void dispatch_glDrawElementsInstancedNV1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, int paramInt5, long paramLong);
  

  public void glFragmentCoverageColorNV(int paramInt)
  {
    long l = _pat._addressof_glFragmentCoverageColorNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFragmentCoverageColorNV" }));
    }
    dispatch_glFragmentCoverageColorNV1(paramInt, l);
  }
  

  private native void dispatch_glFragmentCoverageColorNV1(int paramInt, long paramLong);
  

  public void glBlitFramebufferNV(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10)
  {
    long l = _pat._addressof_glBlitFramebufferNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glBlitFramebufferNV" }));
    }
    dispatch_glBlitFramebufferNV1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, l);
  }
  


  private native void dispatch_glBlitFramebufferNV1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, long paramLong);
  

  public void glCoverageModulationTableNV(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glCoverageModulationTableNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCoverageModulationTableNV" }));
    }
    dispatch_glCoverageModulationTableNV1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glCoverageModulationTableNV1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glCoverageModulationTableNV(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glCoverageModulationTableNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCoverageModulationTableNV" }));
    }
    dispatch_glCoverageModulationTableNV1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glGetCoverageModulationTableNV(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetCoverageModulationTableNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetCoverageModulationTableNV" }));
    }
    dispatch_glGetCoverageModulationTableNV1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetCoverageModulationTableNV1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glGetCoverageModulationTableNV(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetCoverageModulationTableNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetCoverageModulationTableNV" }));
    }
    dispatch_glGetCoverageModulationTableNV1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  

  public void glCoverageModulationNV(int paramInt)
  {
    long l = _pat._addressof_glCoverageModulationNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glCoverageModulationNV" }));
    }
    dispatch_glCoverageModulationNV1(paramInt, l);
  }
  

  private native void dispatch_glCoverageModulationNV1(int paramInt, long paramLong);
  

  public void glRenderbufferStorageMultisampleNV(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glRenderbufferStorageMultisampleNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glRenderbufferStorageMultisampleNV" }));
    }
    dispatch_glRenderbufferStorageMultisampleNV1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glRenderbufferStorageMultisampleNV1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glVertexAttribDivisorNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glVertexAttribDivisorNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glVertexAttribDivisorNV" }));
    }
    dispatch_glVertexAttribDivisorNV1(paramInt1, paramInt2, l);
  }
  


  private native void dispatch_glVertexAttribDivisorNV1(int paramInt1, int paramInt2, long paramLong);
  

  public void glUniformMatrix2x3fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix2x3fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x3fvNV" }));
    }
    dispatch_glUniformMatrix2x3fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix2x3fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix2x3fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix2x3fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x3fvNV" }));
    }
    dispatch_glUniformMatrix2x3fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix3x2fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix3x2fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x2fvNV" }));
    }
    dispatch_glUniformMatrix3x2fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix3x2fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix3x2fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix3x2fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x2fvNV" }));
    }
    dispatch_glUniformMatrix3x2fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix2x4fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix2x4fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x4fvNV" }));
    }
    dispatch_glUniformMatrix2x4fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix2x4fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix2x4fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix2x4fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix2x4fvNV" }));
    }
    dispatch_glUniformMatrix2x4fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix4x2fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix4x2fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x2fvNV" }));
    }
    dispatch_glUniformMatrix4x2fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix4x2fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix4x2fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix4x2fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x2fvNV" }));
    }
    dispatch_glUniformMatrix4x2fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix3x4fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix3x4fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x4fvNV" }));
    }
    dispatch_glUniformMatrix3x4fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix3x4fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix3x4fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix3x4fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix3x4fvNV" }));
    }
    dispatch_glUniformMatrix3x4fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  


  public void glUniformMatrix4x3fvNV(int paramInt1, int paramInt2, boolean paramBoolean, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glUniformMatrix4x3fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x3fvNV" }));
    }
    dispatch_glUniformMatrix4x3fvNV1(paramInt1, paramInt2, paramBoolean, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glUniformMatrix4x3fvNV1(int paramInt1, int paramInt2, boolean paramBoolean1, Object paramObject, int paramInt3, boolean paramBoolean2, long paramLong);
  

  public void glUniformMatrix4x3fvNV(int paramInt1, int paramInt2, boolean paramBoolean, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"value_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glUniformMatrix4x3fvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glUniformMatrix4x3fvNV" }));
    }
    dispatch_glUniformMatrix4x3fvNV1(paramInt1, paramInt2, paramBoolean, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glPolygonModeNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glPolygonModeNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glPolygonModeNV" }));
    }
    dispatch_glPolygonModeNV1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glPolygonModeNV1(int paramInt1, int paramInt2, long paramLong);
  

  public void glReadBufferNV(int paramInt)
  {
    long l = _pat._addressof_glReadBufferNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glReadBufferNV" }));
    }
    dispatch_glReadBufferNV1(paramInt, l);
  }
  


  private native void dispatch_glReadBufferNV1(int paramInt, long paramLong);
  

  public void glFramebufferSampleLocationsfvNV(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferSampleLocationsfvNV" }));
    }
    dispatch_glFramebufferSampleLocationsfvNV1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glFramebufferSampleLocationsfvNV1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glFramebufferSampleLocationsfvNV(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferSampleLocationsfvNV" }));
    }
    dispatch_glFramebufferSampleLocationsfvNV1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  


  public void glNamedFramebufferSampleLocationsfvNV(int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNamedFramebufferSampleLocationsfvNV" }));
    }
    dispatch_glNamedFramebufferSampleLocationsfvNV1(paramInt1, paramInt2, paramInt3, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glNamedFramebufferSampleLocationsfvNV1(int paramInt1, int paramInt2, int paramInt3, Object paramObject, int paramInt4, boolean paramBoolean, long paramLong);
  

  public void glNamedFramebufferSampleLocationsfvNV(int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOfFloat, int paramInt4)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt4))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glNamedFramebufferSampleLocationsfvNV" }));
    }
    dispatch_glNamedFramebufferSampleLocationsfvNV1(paramInt1, paramInt2, paramInt3, paramArrayOfFloat, 4 * paramInt4, false, l);
  }
  

  public void glResolveDepthValuesNV()
  {
    long l = _pat._addressof_glResolveDepthValuesNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glResolveDepthValuesNV" }));
    }
    dispatch_glResolveDepthValuesNV1(l);
  }
  


  private native void dispatch_glResolveDepthValuesNV1(long paramLong);
  

  public void glViewportArrayvNV(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glViewportArrayvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewportArrayvNV" }));
    }
    dispatch_glViewportArrayvNV1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glViewportArrayvNV1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glViewportArrayvNV(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glViewportArrayvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewportArrayvNV" }));
    }
    dispatch_glViewportArrayvNV1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glViewportIndexedfNV(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    long l = _pat._addressof_glViewportIndexedfNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewportIndexedfNV" }));
    }
    dispatch_glViewportIndexedfNV1(paramInt, paramFloat1, paramFloat2, paramFloat3, paramFloat4, l);
  }
  


  private native void dispatch_glViewportIndexedfNV1(int paramInt, float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, long paramLong);
  

  public void glViewportIndexedfvNV(int paramInt, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glViewportIndexedfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewportIndexedfvNV" }));
    }
    dispatch_glViewportIndexedfvNV1(paramInt, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glViewportIndexedfvNV1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glViewportIndexedfvNV(int paramInt1, float[] paramArrayOfFloat, int paramInt2)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glViewportIndexedfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glViewportIndexedfvNV" }));
    }
    dispatch_glViewportIndexedfvNV1(paramInt1, paramArrayOfFloat, 4 * paramInt2, false, l);
  }
  


  public void glScissorArrayvNV(int paramInt1, int paramInt2, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glScissorArrayvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissorArrayvNV" }));
    }
    dispatch_glScissorArrayvNV1(paramInt1, paramInt2, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glScissorArrayvNV1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glScissorArrayvNV(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glScissorArrayvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissorArrayvNV" }));
    }
    dispatch_glScissorArrayvNV1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, l);
  }
  

  public void glScissorIndexedNV(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glScissorIndexedNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissorIndexedNV" }));
    }
    dispatch_glScissorIndexedNV1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  


  private native void dispatch_glScissorIndexedNV1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glScissorIndexedvNV(int paramInt, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glScissorIndexedvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissorIndexedvNV" }));
    }
    dispatch_glScissorIndexedvNV1(paramInt, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glScissorIndexedvNV1(int paramInt1, Object paramObject, int paramInt2, boolean paramBoolean, long paramLong);
  

  public void glScissorIndexedvNV(int paramInt1, int[] paramArrayOfInt, int paramInt2)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt2))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt2 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glScissorIndexedvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glScissorIndexedvNV" }));
    }
    dispatch_glScissorIndexedvNV1(paramInt1, paramArrayOfInt, 4 * paramInt2, false, l);
  }
  


  public void glDepthRangeArrayfvNV(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glDepthRangeArrayfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangeArrayfvNV" }));
    }
    dispatch_glDepthRangeArrayfvNV1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glDepthRangeArrayfvNV1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glDepthRangeArrayfvNV(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"v_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glDepthRangeArrayfvNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangeArrayfvNV" }));
    }
    dispatch_glDepthRangeArrayfvNV1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glDepthRangeIndexedfNV(int paramInt, float paramFloat1, float paramFloat2)
  {
    long l = _pat._addressof_glDepthRangeIndexedfNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDepthRangeIndexedfNV" }));
    }
    dispatch_glDepthRangeIndexedfNV1(paramInt, paramFloat1, paramFloat2, l);
  }
  


  private native void dispatch_glDepthRangeIndexedfNV1(int paramInt, float paramFloat1, float paramFloat2, long paramLong);
  

  public void glGetFloati_vNV(int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer)
  {
    boolean bool = Buffers.isDirect(paramFloatBuffer);
    long l = _pat._addressof_glGetFloati_vNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloati_vNV" }));
    }
    dispatch_glGetFloati_vNV1(paramInt1, paramInt2, bool ? paramFloatBuffer : Buffers.getArray(paramFloatBuffer), bool ? Buffers.getDirectBufferByteOffset(paramFloatBuffer) : Buffers.getIndirectBufferByteOffset(paramFloatBuffer), bool, l);
  }
  


  private native void dispatch_glGetFloati_vNV1(int paramInt1, int paramInt2, Object paramObject, int paramInt3, boolean paramBoolean, long paramLong);
  

  public void glGetFloati_vNV(int paramInt1, int paramInt2, float[] paramArrayOfFloat, int paramInt3)
  {
    if ((paramArrayOfFloat != null) && (paramArrayOfFloat.length <= paramInt3))
      throw new GLException("array offset argument \"data_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfFloat.length + ")");
    long l = _pat._addressof_glGetFloati_vNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetFloati_vNV" }));
    }
    dispatch_glGetFloati_vNV1(paramInt1, paramInt2, paramArrayOfFloat, 4 * paramInt3, false, l);
  }
  

  public void glEnableiNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glEnableiNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableiNV" }));
    }
    dispatch_glEnableiNV1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glEnableiNV1(int paramInt1, int paramInt2, long paramLong);
  

  public void glDisableiNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glDisableiNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableiNV" }));
    }
    dispatch_glDisableiNV1(paramInt1, paramInt2, l);
  }
  

  private native void dispatch_glDisableiNV1(int paramInt1, int paramInt2, long paramLong);
  

  public boolean glIsEnablediNV(int paramInt1, int paramInt2)
  {
    long l = _pat._addressof_glIsEnablediNV;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glIsEnablediNV" }));
    }
    return dispatch_glIsEnablediNV1(paramInt1, paramInt2, l);
  }
  

  private native boolean dispatch_glIsEnablediNV1(int paramInt1, int paramInt2, long paramLong);
  

  public void glFramebufferTextureMultiviewOVR(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)
  {
    long l = _pat._addressof_glFramebufferTextureMultiviewOVR;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glFramebufferTextureMultiviewOVR" }));
    }
    dispatch_glFramebufferTextureMultiviewOVR1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, l);
  }
  

  private native void dispatch_glFramebufferTextureMultiviewOVR1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, long paramLong);
  

  public void glAlphaFuncQCOM(int paramInt, float paramFloat)
  {
    long l = _pat._addressof_glAlphaFuncQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glAlphaFuncQCOM" }));
    }
    dispatch_glAlphaFuncQCOM1(paramInt, paramFloat, l);
  }
  


  private native void dispatch_glAlphaFuncQCOM1(int paramInt, float paramFloat, long paramLong);
  


  public void glGetDriverControlsQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glGetDriverControlsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlsQCOM" }));
    }
    dispatch_glGetDriverControlsQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glGetDriverControlsQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glGetDriverControlsQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"num_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"driverControls_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glGetDriverControlsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlsQCOM" }));
    }
    dispatch_glGetDriverControlsQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glGetDriverControlStringQCOM(int paramInt1, int paramInt2, IntBuffer paramIntBuffer, ByteBuffer paramByteBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer);
    boolean bool2 = Buffers.isDirect(paramByteBuffer);
    long l = _pat._addressof_glGetDriverControlStringQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlStringQCOM" }));
    }
    dispatch_glGetDriverControlStringQCOM1(paramInt1, paramInt2, bool1 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool1, bool2 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool2, l);
  }
  


  private native void dispatch_glGetDriverControlStringQCOM1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glGetDriverControlStringQCOM(int paramInt1, int paramInt2, int[] paramArrayOfInt, int paramInt3, byte[] paramArrayOfByte, int paramInt4)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt3))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt4))
      throw new GLException("array offset argument \"driverControlString_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    long l = _pat._addressof_glGetDriverControlStringQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glGetDriverControlStringQCOM" }));
    }
    dispatch_glGetDriverControlStringQCOM1(paramInt1, paramInt2, paramArrayOfInt, 4 * paramInt3, false, paramArrayOfByte, paramInt4, false, l);
  }
  

  public void glEnableDriverControlQCOM(int paramInt)
  {
    long l = _pat._addressof_glEnableDriverControlQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEnableDriverControlQCOM" }));
    }
    dispatch_glEnableDriverControlQCOM1(paramInt, l);
  }
  

  private native void dispatch_glEnableDriverControlQCOM1(int paramInt, long paramLong);
  

  public void glDisableDriverControlQCOM(int paramInt)
  {
    long l = _pat._addressof_glDisableDriverControlQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glDisableDriverControlQCOM" }));
    }
    dispatch_glDisableDriverControlQCOM1(paramInt, l);
  }
  


  private native void dispatch_glDisableDriverControlQCOM1(int paramInt, long paramLong);
  


  public void glExtGetTexturesQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetTexturesQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexturesQCOM" }));
    }
    dispatch_glExtGetTexturesQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetTexturesQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetTexturesQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"textures_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numTextures_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetTexturesQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexturesQCOM" }));
    }
    dispatch_glExtGetTexturesQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetBuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetBuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBuffersQCOM" }));
    }
    dispatch_glExtGetBuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetBuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetBuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"buffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numBuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetBuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBuffersQCOM" }));
    }
    dispatch_glExtGetBuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetRenderbuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetRenderbuffersQCOM" }));
    }
    dispatch_glExtGetRenderbuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetRenderbuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetRenderbuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetRenderbuffersQCOM" }));
    }
    dispatch_glExtGetRenderbuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetFramebuffersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetFramebuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetFramebuffersQCOM" }));
    }
    dispatch_glExtGetFramebuffersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetFramebuffersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetFramebuffersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"framebuffers_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetFramebuffersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetFramebuffersQCOM" }));
    }
    dispatch_glExtGetFramebuffersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  


  public void glExtGetTexLevelParameterivQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, IntBuffer paramIntBuffer)
  {
    boolean bool = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexLevelParameterivQCOM" }));
    }
    dispatch_glExtGetTexLevelParameterivQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, bool ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool, l);
  }
  


  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, Object paramObject, int paramInt5, boolean paramBoolean, long paramLong);
  

  public void glExtGetTexLevelParameterivQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5)
  {
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt5))
      throw new GLException("array offset argument \"params_offset\" (" + paramInt5 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexLevelParameterivQCOM" }));
    }
    dispatch_glExtGetTexLevelParameterivQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, 4 * paramInt5, false, l);
  }
  

  public void glExtTexObjectStateOverrideiQCOM(int paramInt1, int paramInt2, int paramInt3)
  {
    long l = _pat._addressof_glExtTexObjectStateOverrideiQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtTexObjectStateOverrideiQCOM" }));
    }
    dispatch_glExtTexObjectStateOverrideiQCOM1(paramInt1, paramInt2, paramInt3, l);
  }
  


  private native void dispatch_glExtTexObjectStateOverrideiQCOM1(int paramInt1, int paramInt2, int paramInt3, long paramLong);
  

  public void glExtGetTexSubImageQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Buffer paramBuffer)
  {
    boolean bool = Buffers.isDirect(paramBuffer);
    long l = _pat._addressof_glExtGetTexSubImageQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetTexSubImageQCOM" }));
    }
    dispatch_glExtGetTexSubImageQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7, paramInt8, paramInt9, paramInt10, bool ? paramBuffer : Buffers.getArray(paramBuffer), bool ? Buffers.getDirectBufferByteOffset(paramBuffer) : Buffers.getIndirectBufferByteOffset(paramBuffer), bool, l);
  }
  


  private native void dispatch_glExtGetTexSubImageQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8, int paramInt9, int paramInt10, Object paramObject, int paramInt11, boolean paramBoolean, long paramLong);
  


  public void glExtGetBufferPointervQCOM(int paramInt, PointerBuffer paramPointerBuffer)
  {
    if (!Buffers.isDirect(paramPointerBuffer))
      throw new GLException("Argument \"params\" is not a direct buffer");
    long l = _pat._addressof_glExtGetBufferPointervQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetBufferPointervQCOM" }));
    }
    dispatch_glExtGetBufferPointervQCOM0(paramInt, paramPointerBuffer != null ? paramPointerBuffer.getBuffer() : null, Buffers.getDirectBufferByteOffset(paramPointerBuffer), l);
  }
  



  private native void dispatch_glExtGetBufferPointervQCOM0(int paramInt1, Object paramObject, int paramInt2, long paramLong);
  


  public void glExtGetShadersQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetShadersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetShadersQCOM" }));
    }
    dispatch_glExtGetShadersQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetShadersQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetShadersQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"shaders_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numShaders_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetShadersQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetShadersQCOM" }));
    }
    dispatch_glExtGetShadersQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  



  public void glExtGetProgramsQCOM(IntBuffer paramIntBuffer1, int paramInt, IntBuffer paramIntBuffer2)
  {
    boolean bool1 = Buffers.isDirect(paramIntBuffer1);
    boolean bool2 = Buffers.isDirect(paramIntBuffer2);
    long l = _pat._addressof_glExtGetProgramsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramsQCOM" }));
    }
    dispatch_glExtGetProgramsQCOM1(bool1 ? paramIntBuffer1 : Buffers.getArray(paramIntBuffer1), bool1 ? Buffers.getDirectBufferByteOffset(paramIntBuffer1) : Buffers.getIndirectBufferByteOffset(paramIntBuffer1), bool1, paramInt, bool2 ? paramIntBuffer2 : Buffers.getArray(paramIntBuffer2), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer2) : Buffers.getIndirectBufferByteOffset(paramIntBuffer2), bool2, l);
  }
  


  private native void dispatch_glExtGetProgramsQCOM1(Object paramObject1, int paramInt1, boolean paramBoolean1, int paramInt2, Object paramObject2, int paramInt3, boolean paramBoolean2, long paramLong);
  


  public void glExtGetProgramsQCOM(int[] paramArrayOfInt1, int paramInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3)
  {
    if ((paramArrayOfInt1 != null) && (paramArrayOfInt1.length <= paramInt1))
      throw new GLException("array offset argument \"programs_offset\" (" + paramInt1 + ") equals or exceeds array length (" + paramArrayOfInt1.length + ")");
    if ((paramArrayOfInt2 != null) && (paramArrayOfInt2.length <= paramInt3))
      throw new GLException("array offset argument \"numPrograms_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfInt2.length + ")");
    long l = _pat._addressof_glExtGetProgramsQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramsQCOM" }));
    }
    dispatch_glExtGetProgramsQCOM1(paramArrayOfInt1, 4 * paramInt1, false, paramInt2, paramArrayOfInt2, 4 * paramInt3, false, l);
  }
  

  public boolean glExtIsProgramBinaryQCOM(int paramInt)
  {
    long l = _pat._addressof_glExtIsProgramBinaryQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtIsProgramBinaryQCOM" }));
    }
    return dispatch_glExtIsProgramBinaryQCOM1(paramInt, l);
  }
  


  private native boolean dispatch_glExtIsProgramBinaryQCOM1(int paramInt, long paramLong);
  


  public void glExtGetProgramBinarySourceQCOM(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer, IntBuffer paramIntBuffer)
  {
    boolean bool1 = Buffers.isDirect(paramByteBuffer);
    boolean bool2 = Buffers.isDirect(paramIntBuffer);
    long l = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramBinarySourceQCOM" }));
    }
    dispatch_glExtGetProgramBinarySourceQCOM1(paramInt1, paramInt2, bool1 ? paramByteBuffer : Buffers.getArray(paramByteBuffer), bool1 ? Buffers.getDirectBufferByteOffset(paramByteBuffer) : Buffers.getIndirectBufferByteOffset(paramByteBuffer), bool1, bool2 ? paramIntBuffer : Buffers.getArray(paramIntBuffer), bool2 ? Buffers.getDirectBufferByteOffset(paramIntBuffer) : Buffers.getIndirectBufferByteOffset(paramIntBuffer), bool2, l);
  }
  


  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int paramInt1, int paramInt2, Object paramObject1, int paramInt3, boolean paramBoolean1, Object paramObject2, int paramInt4, boolean paramBoolean2, long paramLong);
  


  public void glExtGetProgramBinarySourceQCOM(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3, int[] paramArrayOfInt, int paramInt4)
  {
    if ((paramArrayOfByte != null) && (paramArrayOfByte.length <= paramInt3))
      throw new GLException("array offset argument \"source_offset\" (" + paramInt3 + ") equals or exceeds array length (" + paramArrayOfByte.length + ")");
    if ((paramArrayOfInt != null) && (paramArrayOfInt.length <= paramInt4))
      throw new GLException("array offset argument \"length_offset\" (" + paramInt4 + ") equals or exceeds array length (" + paramArrayOfInt.length + ")");
    long l = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glExtGetProgramBinarySourceQCOM" }));
    }
    dispatch_glExtGetProgramBinarySourceQCOM1(paramInt1, paramInt2, paramArrayOfByte, paramInt3, false, paramArrayOfInt, 4 * paramInt4, false, l);
  }
  

  public void glStartTilingQCOM(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    long l = _pat._addressof_glStartTilingQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glStartTilingQCOM" }));
    }
    dispatch_glStartTilingQCOM1(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, l);
  }
  

  private native void dispatch_glStartTilingQCOM1(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, long paramLong);
  

  public void glEndTilingQCOM(int paramInt)
  {
    long l = _pat._addressof_glEndTilingQCOM;
    if (l == 0L) {
      throw new GLException(String.format("Method \"%s\" not available", new Object[] { "glEndTilingQCOM" }));
    }
    dispatch_glEndTilingQCOM1(paramInt, l);
  }
  




  private native void dispatch_glEndTilingQCOM1(int paramInt, long paramLong);
  




  public com.jogamp.opengl.GLProfile getGLProfile()
  {
    return glProfile;
  }
  
  public final int getBoundBuffer(int paramInt)
  {
    return bufferStateTracker.getBoundBufferObject(paramInt, this);
  }
  
  public final GLBufferStorage getBufferStorage(int paramInt)
  {
    return bufferObjectTracker.getBufferStorage(paramInt);
  }
  
  public final boolean isVBOArrayBound()
  {
    return checkArrayVBOBound(false);
  }
  
  public final boolean isVBOElementArrayBound()
  {
    return checkElementVBOBound(false);
  }
  
  public final com.jogamp.opengl.GL getDownstreamGL() throws GLException
  {
    return null;
  }
  
  public final com.jogamp.opengl.GL getRootGL() throws GLException
  {
    return this;
  }
  
  public final boolean isGL()
  {
    return true;
  }
  
  public final com.jogamp.opengl.GL getGL() throws GLException
  {
    return this;
  }
  
  public final boolean isFunctionAvailable(String paramString)
  {
    return _context.isFunctionAvailable(paramString);
  }
  
  public final boolean isExtensionAvailable(String paramString)
  {
    return _context.isExtensionAvailable(paramString);
  }
  

  public final Object getExtension(String paramString)
  {
    return null;
  }
  
  public final boolean hasBasicFBOSupport()
  {
    return _context.hasBasicFBOSupport();
  }
  
  public final boolean hasFullFBOSupport()
  {
    return _context.hasFullFBOSupport();
  }
  
  public final int getMaxRenderbufferSamples()
  {
    return _context.getMaxRenderbufferSamples();
  }
  
  public final boolean isTextureFormatBGRA8888Available()
  {
    return _context.isTextureFormatBGRA8888Available();
  }
  
  public final com.jogamp.opengl.GLContext getContext()
  {
    return _context;
  }
  



  public final void setSwapInterval(int paramInt)
  {
    _context.setSwapInterval(paramInt);
  }
  



  public final int getSwapInterval()
  {
    return _context.getSwapInterval();
  }
  
  public final Object getPlatformGLExtensions()
  {
    return _context.getPlatformGLExtensions();
  }
  
  public final int getBoundFramebuffer(int paramInt)
  {
    return _context.getBoundFramebuffer(paramInt);
  }
  
  public final int getDefaultDrawFramebuffer()
  {
    return _context.getDefaultDrawFramebuffer();
  }
  
  public final int getDefaultReadFramebuffer()
  {
    return _context.getDefaultReadFramebuffer();
  }
  
  public final int getDefaultReadBuffer()
  {
    return _context.getDefaultReadBuffer();
  }
  








  public final void glBufferData(int paramInt1, long paramLong, Buffer paramBuffer, int paramInt2)
  {
    bufferObjectTracker.createBufferStorage(bufferStateTracker, this, paramInt1, paramLong, paramBuffer, paramInt2, 0, glBufferDataDispatch);
  }
  

  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch = new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch()
  {
    public final void create(int paramAnonymousInt1, long paramAnonymousLong, Buffer paramAnonymousBuffer, int paramAnonymousInt2) {
      GLES3Impl.this.glBufferDataDelegate(paramAnonymousInt1, paramAnonymousLong, paramAnonymousBuffer, paramAnonymousInt2);
    }
  };
  


  public boolean glUnmapBuffer(int paramInt) { return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, paramInt, glUnmapBufferDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch = new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch()
  {
    public final boolean unmap(int paramAnonymousInt) {
      return GLES3Impl.this.glUnmapBufferDelegate(paramAnonymousInt);
    }
  };
  
  public final ByteBuffer glMapBuffer(int paramInt1, int paramInt2)
  {
    return mapBuffer(paramInt1, paramInt2).getMappedBuffer();
  }
  

  public final GLBufferStorage mapBuffer(int paramInt1, int paramInt2) { return bufferObjectTracker.mapBuffer(bufferStateTracker, this, paramInt1, paramInt2, glMapBufferDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch = new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch()
  {
    public final ByteBuffer allocNioByteBuffer(long paramAnonymousLong1, long paramAnonymousLong2) { return GLES3Impl.this.newDirectByteBuffer(paramAnonymousLong1, paramAnonymousLong2); }
    
    public final long mapBuffer(int paramAnonymousInt1, int paramAnonymousInt2) { return GLES3Impl.this.glMapBufferDelegate(paramAnonymousInt1, paramAnonymousInt2); }
  };
  

  public final ByteBuffer glMapBufferRange(int paramInt1, long paramLong1, long paramLong2, int paramInt2)
  {
    return mapBufferRange(paramInt1, paramLong1, paramLong2, paramInt2).getMappedBuffer();
  }
  

  public final GLBufferStorage mapBufferRange(int paramInt1, long paramLong1, long paramLong2, int paramInt2) { return bufferObjectTracker.mapBuffer(bufferStateTracker, this, paramInt1, paramLong1, paramLong2, paramInt2, glMapBufferRangeDispatch); }
  
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch = new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch()
  {
    public final ByteBuffer allocNioByteBuffer(long paramAnonymousLong1, long paramAnonymousLong2) { return GLES3Impl.this.newDirectByteBuffer(paramAnonymousLong1, paramAnonymousLong2); }
    
    public final long mapBuffer(int paramAnonymousInt1, long paramAnonymousLong1, long paramAnonymousLong2, int paramAnonymousInt2) { return GLES3Impl.this.glMapBufferRangeDelegate(paramAnonymousInt1, paramAnonymousLong1, paramAnonymousLong2, paramAnonymousInt2); }
  };
  
  private final GLES3ProcAddressTable _pat;
  
  private native ByteBuffer newDirectByteBuffer(long paramLong1, long paramLong2);
  
  public GLES3Impl(com.jogamp.opengl.GLProfile paramGLProfile, GLContextImpl paramGLContextImpl)
  {
    _context = paramGLContextImpl;
    _pat = ((GLES3ProcAddressTable)_context.getGLProcAddressTable());
    bufferObjectTracker = paramGLContextImpl.getBufferObjectTracker();
    bufferStateTracker = paramGLContextImpl.getBufferStateTracker();
    glStateTracker = paramGLContextImpl.getGLStateTracker();
    glProfile = paramGLProfile;
    _isES3 = (paramGLProfile.getImplName() == "GLES3");
  }
  

  public final void finalizeInit() {}
  

  private int[] imageSizeTemp = new int[1];
  
  private final int imageSizeInBytes(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean) {
    return com.jogamp.opengl.util.GLBuffers.sizeof(this, imageSizeTemp, paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramBoolean); }
  

  public final boolean isGL4bc()
  {
    return false;
  }
  
  public final boolean isGL4()
  {
    return false;
  }
  
  public final boolean isGL3bc()
  {
    return false;
  }
  
  public final boolean isGL3()
  {
    return false;
  }
  
  public final boolean isGL2() {
    return false;
  }
  
  public final boolean isGLES1()
  {
    return false;
  }
  
  public final boolean isGLES2()
  {
    return true;
  }
  
  public final boolean isGLES3()
  {
    return _isES3;
  }
  
  public final boolean isGLES()
  {
    return true;
  }
  
  public final boolean isGL2ES1()
  {
    return false;
  }
  
  public final boolean isGL2ES2()
  {
    return true;
  }
  
  public final boolean isGL2ES3()
  {
    return _isES3;
  }
  
  public final boolean isGL3ES3()
  {
    return _isES3;
  }
  
  public final boolean isGL4ES3()
  {
    return _isES3;
  }
  
  public final boolean isGL4core()
  {
    return false;
  }
  
  public final boolean isGL3core()
  {
    return false;
  }
  
  public final boolean isGLcore()
  {
    return true;
  }
  
  public final boolean isGLES2Compatible()
  {
    return true;
  }
  
  public final boolean isGLES3Compatible()
  {
    return _isES3;
  }
  
  public final boolean isGLES31Compatible()
  {
    return _context.isGLES31Compatible();
  }
  
  public final boolean isGLES32Compatible()
  {
    return _context.isGLES32Compatible();
  }
  
  public final boolean isGL2GL3()
  {
    return false;
  }
  
  public final boolean hasGLSL()
  {
    return true;
  }
  
  public boolean isNPOTTextureAvailable()
  {
    return true;
  }
  
  public final com.jogamp.opengl.GL4bc getGL4bc() throws GLException
  {
    throw new GLException("Not a GL4bc implementation");
  }
  
  public final com.jogamp.opengl.GL4 getGL4() throws GLException
  {
    throw new GLException("Not a GL4 implementation");
  }
  
  public final com.jogamp.opengl.GL3bc getGL3bc() throws GLException
  {
    throw new GLException("Not a GL3bc implementation");
  }
  
  public final com.jogamp.opengl.GL3 getGL3() throws GLException
  {
    throw new GLException("Not a GL3 implementation");
  }
  
  public final com.jogamp.opengl.GL2 getGL2() throws GLException
  {
    throw new GLException("Not a GL2 implementation");
  }
  
  public final com.jogamp.opengl.GLES1 getGLES1() throws GLException
  {
    throw new GLException("Not a GLES1 implementation");
  }
  
  public final com.jogamp.opengl.GLES2 getGLES2() throws GLException
  {
    return this;
  }
  
  public final com.jogamp.opengl.GLES3 getGLES3() throws GLException
  {
    if (!_isES3) {
      throw new GLException("Not a GLES3 implementation");
    }
    return this;
  }
  
  public final com.jogamp.opengl.GL2ES1 getGL2ES1() throws GLException
  {
    throw new GLException("Not a GL2ES1 implementation");
  }
  
  public final com.jogamp.opengl.GL2ES2 getGL2ES2() throws GLException
  {
    return this;
  }
  
  public final com.jogamp.opengl.GL2ES3 getGL2ES3() throws GLException
  {
    if (!_isES3) {
      throw new GLException("Not a GL2ES3 implementation");
    }
    return this;
  }
  
  public final com.jogamp.opengl.GL3ES3 getGL3ES3() throws GLException
  {
    if (!_isES3) {
      throw new GLException("Not a GL3ES3 implementation");
    }
    return this;
  }
  
  public final com.jogamp.opengl.GL4ES3 getGL4ES3() throws GLException
  {
    if (!_isES3) {
      throw new GLException("Not a GL4ES3 implementation");
    }
    return this;
  }
  
  public final com.jogamp.opengl.GL2GL3 getGL2GL3() throws GLException
  {
    throw new GLException("Not a GL2GL3 implementation");
  }
  




  private final boolean _isES3;
  



  private final boolean checkBufferObject(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3, int paramInt, String paramString, boolean paramBoolean4)
  {
    if (!paramBoolean1) {
      if (!paramBoolean3) {
        return true;
      }
      if (paramBoolean4) {
        throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int i = bufferStateTracker.getBoundBufferObject(paramInt, this);
    if (paramBoolean3) {
      if (0 != i) {
        return true;
      }
      if (paramBoolean2) {
        i = bufferStateTracker.getBoundBufferObject(34229, this);
        if ((0 != i) && (_context.getDefaultVAO() != i)) {
          return true;
        }
      }
      if (paramBoolean4) {
        throw new GLException(paramString + " must be bound to call this method");
      }
      return false;
    }
    if (0 == i) {
      return true;
    }
    if (paramBoolean4) {
      throw new GLException(paramString + " must be unbound to call this method");
    }
    return false;
  }
  
  private final void validateCPUSourcedAvail()
  {
    if (!_context.isCPUDataSourcingAvail()) {
      throw new GLException("CPU data sourcing n/a w/ " + _context);
    }
  }
  
  private final boolean checkArrayVBOUnbound(boolean paramBoolean) {
    if (paramBoolean) {
      validateCPUSourcedAvail();
    }
    return checkBufferObject(true, _isES3, false, 34962, "array vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkArrayVBOBound(boolean paramBoolean)
  {
    return checkBufferObject(true, _isES3, true, 34962, "array vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkElementVBOUnbound(boolean paramBoolean)
  {
    if (paramBoolean) {
      validateCPUSourcedAvail();
    }
    return checkBufferObject(true, _isES3, false, 34963, "element vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkElementVBOBound(boolean paramBoolean)
  {
    return checkBufferObject(true, _isES3, true, 34963, "element vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkIndirectVBOUnbound(boolean paramBoolean)
  {
    if (paramBoolean) {
      validateCPUSourcedAvail();
    }
    return checkBufferObject(true, _isES3, false, 36671, "indirect vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkIndirectVBOBound(boolean paramBoolean)
  {
    return checkBufferObject(true, _isES3, true, 36671, "indirect vertex_buffer_object", paramBoolean);
  }
  



  private final boolean checkUnpackPBOUnbound(boolean paramBoolean)
  {
    return checkBufferObject(_isES3, false, false, 35052, "unpack pixel_buffer_object", paramBoolean);
  }
  



  private final boolean checkUnpackPBOBound(boolean paramBoolean)
  {
    return checkBufferObject(_isES3, false, true, 35052, "unpack pixel_buffer_object", paramBoolean);
  }
  



  private final boolean checkPackPBOUnbound(boolean paramBoolean)
  {
    return checkBufferObject(_isES3, false, false, 35051, "pack pixel_buffer_object", paramBoolean);
  }
  



  private final boolean checkPackPBOBound(boolean paramBoolean)
  {
    return checkBufferObject(_isES3, false, true, 35051, "pack pixel_buffer_object", paramBoolean);
  }
  




  public final boolean isPBOPackBound()
  {
    return checkPackPBOBound(false);
  }
  
  public final boolean isPBOUnpackBound()
  {
    return checkUnpackPBOBound(false);
  }
  
  public final void glClearDepth(double paramDouble)
  {
    glClearDepthf((float)paramDouble);
  }
  
  public final void glDepthRange(double paramDouble1, double paramDouble2)
  {
    glDepthRangef((float)paramDouble1, (float)paramDouble2);
  }
  
  public final void glVertexAttribPointer(GLArrayData paramGLArrayData)
  {
    if (paramGLArrayData.getComponentCount() == 0) return;
    if (paramGLArrayData.isVBO()) {
      glVertexAttribPointer(paramGLArrayData.getLocation(), paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData
        .getNormalized(), paramGLArrayData.getStride(), paramGLArrayData.getVBOOffset());
    } else {
      glVertexAttribPointer(paramGLArrayData.getLocation(), paramGLArrayData.getComponentCount(), paramGLArrayData.getComponentType(), paramGLArrayData
        .getNormalized(), paramGLArrayData.getStride(), paramGLArrayData.getBuffer());
    }
  }
  
  public final void glUniform(GLUniformData paramGLUniformData)
  {
    int i = 0;
    Object localObject; if (paramGLUniformData.isBuffer()) {
      localObject = paramGLUniformData.getBuffer();
      if (paramGLUniformData.isMatrix()) {
        if ((localObject instanceof FloatBuffer)) {
          switch (paramGLUniformData.columns()) {
          case 2:  glUniformMatrix2fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), false, (FloatBuffer)localObject);i = 1; break;
          case 3:  glUniformMatrix3fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), false, (FloatBuffer)localObject);i = 1; break;
          case 4:  glUniformMatrix4fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), false, (FloatBuffer)localObject);i = 1;
          }
        }
        if (i == 0) {
          throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
        }
      } else {
        if ((localObject instanceof IntBuffer)) {
          switch (paramGLUniformData.components()) {
          case 1:  glUniform1iv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (IntBuffer)localObject);i = 1; break;
          case 2:  glUniform2iv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (IntBuffer)localObject);i = 1; break;
          case 3:  glUniform3iv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (IntBuffer)localObject);i = 1; break;
          case 4:  glUniform4iv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (IntBuffer)localObject);i = 1;
          }
        } else if ((localObject instanceof FloatBuffer)) {
          switch (paramGLUniformData.components()) {
          case 1:  glUniform1fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (FloatBuffer)localObject);i = 1; break;
          case 2:  glUniform2fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (FloatBuffer)localObject);i = 1; break;
          case 3:  glUniform3fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (FloatBuffer)localObject);i = 1; break;
          case 4:  glUniform4fv(paramGLUniformData.getLocation(), paramGLUniformData.count(), (FloatBuffer)localObject);i = 1;
          }
        }
        if (i == 0) {
          throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
        }
      }
    } else {
      localObject = paramGLUniformData.getObject();
      if ((localObject instanceof Integer)) {
        glUniform1i(paramGLUniformData.getLocation(), ((Integer)localObject).intValue());
        i = 1;
      } else if ((localObject instanceof Float)) {
        glUniform1f(paramGLUniformData.getLocation(), ((Float)localObject).floatValue());
        i = 1;
      }
      if (i == 0) {
        throw new GLException("glUniform atom only available for 1i and 1f");
      }
    }
  }
}
