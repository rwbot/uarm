package jogamp.graph.font.typecast.ot;


public class Mnemonic
{
  public static final short SVTCA = 0;
  
  public static final short SPVTCA = 2;
  
  public static final short SFVTCA = 4;
  
  public static final short SPVTL = 6;
  
  public static final short SFVTL = 8;
  
  public static final short SPVFS = 10;
  
  public static final short SFVFS = 11;
  
  public static final short GPV = 12;
  
  public static final short GFV = 13;
  
  public static final short SFVTPV = 14;
  
  public static final short ISECT = 15;
  
  public static final short SRP0 = 16;
  
  public static final short SRP1 = 17;
  
  public static final short SRP2 = 18;
  
  public static final short SZP0 = 19;
  public static final short SZP1 = 20;
  public static final short SZP2 = 21;
  public static final short SZPS = 22;
  public static final short SLOOP = 23;
  public static final short RTG = 24;
  public static final short RTHG = 25;
  public static final short SMD = 26;
  public static final short ELSE = 27;
  public static final short JMPR = 28;
  public static final short SCVTCI = 29;
  public static final short SSWCI = 30;
  public static final short SSW = 31;
  public static final short DUP = 32;
  public static final short POP = 33;
  public static final short CLEAR = 34;
  public static final short SWAP = 35;
  public static final short DEPTH = 36;
  public static final short CINDEX = 37;
  public static final short MINDEX = 38;
  public static final short ALIGNPTS = 39;
  public static final short UTP = 41;
  public static final short LOOPCALL = 42;
  public static final short CALL = 43;
  public static final short FDEF = 44;
  public static final short ENDF = 45;
  public static final short MDAP = 46;
  public static final short IUP = 48;
  public static final short SHP = 50;
  public static final short SHC = 52;
  public static final short SHZ = 54;
  public static final short SHPIX = 56;
  public static final short IP = 57;
  public static final short MSIRP = 58;
  public static final short ALIGNRP = 60;
  public static final short RTDG = 61;
  public static final short MIAP = 62;
  public static final short NPUSHB = 64;
  public static final short NPUSHW = 65;
  public static final short WS = 66;
  public static final short RS = 67;
  public static final short WCVTP = 68;
  public static final short RCVT = 69;
  public static final short GC = 70;
  public static final short SCFS = 72;
  public static final short MD = 73;
  public static final short MPPEM = 75;
  public static final short MPS = 76;
  public static final short FLIPON = 77;
  public static final short FLIPOFF = 78;
  public static final short DEBUG = 79;
  public static final short LT = 80;
  public static final short LTEQ = 81;
  public static final short GT = 82;
  public static final short GTEQ = 83;
  public static final short EQ = 84;
  public static final short NEQ = 85;
  public static final short ODD = 86;
  public static final short EVEN = 87;
  public static final short IF = 88;
  public static final short EIF = 89;
  public static final short AND = 90;
  public static final short OR = 91;
  public static final short NOT = 92;
  public static final short DELTAP1 = 93;
  public static final short SDB = 94;
  public static final short SDS = 95;
  public static final short ADD = 96;
  public static final short SUB = 97;
  public static final short DIV = 98;
  public static final short MUL = 99;
  public static final short ABS = 100;
  public static final short NEG = 101;
  public static final short FLOOR = 102;
  public static final short CEILING = 103;
  public static final short ROUND = 104;
  public static final short NROUND = 108;
  public static final short WCVTF = 112;
  public static final short DELTAP2 = 113;
  public static final short DELTAP3 = 114;
  public static final short DELTAC1 = 115;
  public static final short DELTAC2 = 116;
  public static final short DELTAC3 = 117;
  public static final short SROUND = 118;
  public static final short S45ROUND = 119;
  public static final short JROT = 120;
  public static final short JROF = 121;
  public static final short ROFF = 122;
  public static final short RUTG = 124;
  public static final short RDTG = 125;
  public static final short SANGW = 126;
  public static final short AA = 127;
  public static final short FLIPPT = 128;
  public static final short FLIPRGON = 129;
  public static final short FLIPRGOFF = 130;
  public static final short SCANCTRL = 133;
  public static final short SDPVTL = 134;
  public static final short GETINFO = 136;
  public static final short IDEF = 137;
  public static final short ROLL = 138;
  public static final short MAX = 139;
  public static final short MIN = 140;
  public static final short SCANTYPE = 141;
  public static final short INSTCTRL = 142;
  public static final short PUSHB = 176;
  public static final short PUSHW = 184;
  public static final short MDRP = 192;
  public static final short MIRP = 224;
  
  public Mnemonic() {}
  
  public static String getMnemonic(short paramShort)
  {
    if (paramShort >= 224) return "MIRP[" + ((paramShort & 0x10) == 0 ? "nrp0," : "srp0,") + ((paramShort & 0x8) == 0 ? "nmd," : "md,") + ((paramShort & 0x4) == 0 ? "nrd," : "rd,") + (paramShort & 0x3) + "]";
    if (paramShort >= 192) return "MDRP[" + ((paramShort & 0x10) == 0 ? "nrp0," : "srp0,") + ((paramShort & 0x8) == 0 ? "nmd," : "md,") + ((paramShort & 0x4) == 0 ? "nrd," : "rd,") + (paramShort & 0x3) + "]";
    if (paramShort >= 184) return "PUSHW[" + ((paramShort & 0x7) + 1) + "]";
    if (paramShort >= 176) return "PUSHB[" + ((paramShort & 0x7) + 1) + "]";
    if (paramShort >= 142) return "INSTCTRL";
    if (paramShort >= 141) return "SCANTYPE";
    if (paramShort >= 140) return "MIN";
    if (paramShort >= 139) return "MAX";
    if (paramShort >= 138) return "ROLL";
    if (paramShort >= 137) return "IDEF";
    if (paramShort >= 136) return "GETINFO";
    if (paramShort >= 134) return "SDPVTL[" + (paramShort & 0x1) + "]";
    if (paramShort >= 133) return "SCANCTRL";
    if (paramShort >= 130) return "FLIPRGOFF";
    if (paramShort >= 129) return "FLIPRGON";
    if (paramShort >= 128) return "FLIPPT";
    if (paramShort >= 127) return "AA";
    if (paramShort >= 126) return "SANGW";
    if (paramShort >= 125) return "RDTG";
    if (paramShort >= 124) return "RUTG";
    if (paramShort >= 122) return "ROFF";
    if (paramShort >= 121) return "JROF";
    if (paramShort >= 120) return "JROT";
    if (paramShort >= 119) return "S45ROUND";
    if (paramShort >= 118) return "SROUND";
    if (paramShort >= 117) return "DELTAC3";
    if (paramShort >= 116) return "DELTAC2";
    if (paramShort >= 115) return "DELTAC1";
    if (paramShort >= 114) return "DELTAP3";
    if (paramShort >= 113) return "DELTAP2";
    if (paramShort >= 112) return "WCVTF";
    if (paramShort >= 108) return "NROUND[" + (paramShort & 0x3) + "]";
    if (paramShort >= 104) return "ROUND[" + (paramShort & 0x3) + "]";
    if (paramShort >= 103) return "CEILING";
    if (paramShort >= 102) return "FLOOR";
    if (paramShort >= 101) return "NEG";
    if (paramShort >= 100) return "ABS";
    if (paramShort >= 99) return "MUL";
    if (paramShort >= 98) return "DIV";
    if (paramShort >= 97) return "SUB";
    if (paramShort >= 96) return "ADD";
    if (paramShort >= 95) return "SDS";
    if (paramShort >= 94) return "SDB";
    if (paramShort >= 93) return "DELTAP1";
    if (paramShort >= 92) return "NOT";
    if (paramShort >= 91) return "OR";
    if (paramShort >= 90) return "AND";
    if (paramShort >= 89) return "EIF";
    if (paramShort >= 88) return "IF";
    if (paramShort >= 87) return "EVEN";
    if (paramShort >= 86) return "ODD";
    if (paramShort >= 85) return "NEQ";
    if (paramShort >= 84) return "EQ";
    if (paramShort >= 83) return "GTEQ";
    if (paramShort >= 82) return "GT";
    if (paramShort >= 81) return "LTEQ";
    if (paramShort >= 80) return "LT";
    if (paramShort >= 79) return "DEBUG";
    if (paramShort >= 78) return "FLIPOFF";
    if (paramShort >= 77) return "FLIPON";
    if (paramShort >= 76) return "MPS";
    if (paramShort >= 75) return "MPPEM";
    if (paramShort >= 73) return "MD[" + (paramShort & 0x1) + "]";
    if (paramShort >= 72) return "SCFS";
    if (paramShort >= 70) return "GC[" + (paramShort & 0x1) + "]";
    if (paramShort >= 69) return "RCVT";
    if (paramShort >= 68) return "WCVTP";
    if (paramShort >= 67) return "RS";
    if (paramShort >= 66) return "WS";
    if (paramShort >= 65) return "NPUSHW";
    if (paramShort >= 64) return "NPUSHB";
    if (paramShort >= 62) return "MIAP[" + ((paramShort & 0x1) == 0 ? "nrd+nci" : "rd+ci") + "]";
    if (paramShort >= 61) return "RTDG";
    if (paramShort >= 60) return "ALIGNRP";
    if (paramShort >= 58) return "MSIRP[" + (paramShort & 0x1) + "]";
    if (paramShort >= 57) return "IP";
    if (paramShort >= 56) return "SHPIX";
    if (paramShort >= 54) return "SHZ[" + (paramShort & 0x1) + "]";
    if (paramShort >= 52) return "SHC[" + (paramShort & 0x1) + "]";
    if (paramShort >= 50) return "SHP";
    if (paramShort >= 48) return "IUP[" + ((paramShort & 0x1) == 0 ? "y" : "x") + "]";
    if (paramShort >= 46) return "MDAP[" + ((paramShort & 0x1) == 0 ? "nrd" : "rd") + "]";
    if (paramShort >= 45) return "ENDF";
    if (paramShort >= 44) return "FDEF";
    if (paramShort >= 43) return "CALL";
    if (paramShort >= 42) return "LOOPCALL";
    if (paramShort >= 41) return "UTP";
    if (paramShort >= 39) return "ALIGNPTS";
    if (paramShort >= 38) return "MINDEX";
    if (paramShort >= 37) return "CINDEX";
    if (paramShort >= 36) return "DEPTH";
    if (paramShort >= 35) return "SWAP";
    if (paramShort >= 34) return "CLEAR";
    if (paramShort >= 33) return "POP";
    if (paramShort >= 32) return "DUP";
    if (paramShort >= 31) return "SSW";
    if (paramShort >= 30) return "SSWCI";
    if (paramShort >= 29) return "SCVTCI";
    if (paramShort >= 28) return "JMPR";
    if (paramShort >= 27) return "ELSE";
    if (paramShort >= 26) return "SMD";
    if (paramShort >= 25) return "RTHG";
    if (paramShort >= 24) return "RTG";
    if (paramShort >= 23) return "SLOOP";
    if (paramShort >= 22) return "SZPS";
    if (paramShort >= 21) return "SZP2";
    if (paramShort >= 20) return "SZP1";
    if (paramShort >= 19) return "SZP0";
    if (paramShort >= 18) return "SRP2";
    if (paramShort >= 17) return "SRP1";
    if (paramShort >= 16) return "SRP0";
    if (paramShort >= 15) return "ISECT";
    if (paramShort >= 14) return "SFVTPV";
    if (paramShort >= 13) return "GFV";
    if (paramShort >= 12) return "GPV";
    if (paramShort >= 11) return "SFVFS";
    if (paramShort >= 10) return "SPVFS";
    if (paramShort >= 8) return "SFVTL[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]";
    if (paramShort >= 6) return "SPVTL[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]";
    if (paramShort >= 4) return "SFVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]";
    if (paramShort >= 2) return "SPVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]";
    if (paramShort >= 0) return "SVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]";
    return "????";
  }
  
  public static String getComment(short paramShort) {
    if (paramShort >= 224) return "MIRP[" + ((paramShort & 0x10) == 0 ? "nrp0," : "srp0,") + ((paramShort & 0x8) == 0 ? "nmd," : "md,") + ((paramShort & 0x4) == 0 ? "nrd," : "rd,") + (paramShort & 0x3) + "]\t\tMove Indirect Relative Point";
    if (paramShort >= 192) return "MDRP[" + ((paramShort & 0x10) == 0 ? "nrp0," : "srp0,") + ((paramShort & 0x8) == 0 ? "nmd," : "md,") + ((paramShort & 0x4) == 0 ? "nrd," : "rd,") + (paramShort & 0x3) + "]\t\tMove Direct Relative Point";
    if (paramShort >= 184) return "PUSHW[" + ((paramShort & 0x7) + 1) + "]";
    if (paramShort >= 176) return "PUSHB[" + ((paramShort & 0x7) + 1) + "]";
    if (paramShort >= 142) return "INSTCTRL\tINSTruction Execution ConTRol";
    if (paramShort >= 141) return "SCANTYPE\tSCANTYPE";
    if (paramShort >= 140) return "MIN\t\tMINimum of top two stack elements";
    if (paramShort >= 139) return "MAX\t\tMAXimum of top two stack elements";
    if (paramShort >= 138) return "ROLL\t\tROLL the top three stack elements";
    if (paramShort >= 137) return "IDEF\t\tInstruction DEFinition";
    if (paramShort >= 136) return "GETINFO\tGET INFOrmation";
    if (paramShort >= 134) return "SDPVTL[" + (paramShort & 0x1) + "]\tSet Dual Projection_Vector To Line";
    if (paramShort >= 133) return "SCANCTRL\tSCAN conversion ConTRoL";
    if (paramShort >= 130) return "FLIPRGOFF\tFLIP RanGe OFF";
    if (paramShort >= 129) return "FLIPRGON\tFLIP RanGe ON";
    if (paramShort >= 128) return "FLIPPT\tFLIP PoinT";
    if (paramShort >= 127) return "AA";
    if (paramShort >= 126) return "SANGW\t\tSet Angle _Weight";
    if (paramShort >= 125) return "RDTG\t\tRound Down To Grid";
    if (paramShort >= 124) return "RUTG\t\tRound Up To Grid";
    if (paramShort >= 122) return "ROFF\t\tRound OFF";
    if (paramShort >= 121) return "JROF\t\tJump Relative On False";
    if (paramShort >= 120) return "JROT\t\tJump Relative On True";
    if (paramShort >= 119) return "S45ROUND\tSuper ROUND 45 degrees";
    if (paramShort >= 118) return "SROUND\tSuper ROUND";
    if (paramShort >= 117) return "DELTAC3\tDELTA exception C3";
    if (paramShort >= 116) return "DELTAC2\tDELTA exception C2";
    if (paramShort >= 115) return "DELTAC1\tDELTA exception C1";
    if (paramShort >= 114) return "DELTAP3\tDELTA exception P3";
    if (paramShort >= 113) return "DELTAP2\tDELTA exception P2";
    if (paramShort >= 112) return "WCVTF\t\tWrite Control Value Table in FUnits";
    if (paramShort >= 108) return "NROUND[" + (paramShort & 0x3) + "]";
    if (paramShort >= 104) return "ROUND[" + (paramShort & 0x3) + "]";
    if (paramShort >= 103) return "CEILING\tCEILING";
    if (paramShort >= 102) return "FLOOR\t\tFLOOR";
    if (paramShort >= 101) return "NEG\t\tNEGate";
    if (paramShort >= 100) return "ABS\t\tABSolute value";
    if (paramShort >= 99) return "MUL\t\tMULtiply";
    if (paramShort >= 98) return "DIV\t\tDIVide";
    if (paramShort >= 97) return "SUB\t\tSUBtract";
    if (paramShort >= 96) return "ADD\t\tADD";
    if (paramShort >= 95) return "SDS\t\tSet Delta_Shift in the graphics state";
    if (paramShort >= 94) return "SDB\t\tSet Delta_Base in the graphics state";
    if (paramShort >= 93) return "DELTAP1\tDELTA exception P1";
    if (paramShort >= 92) return "NOT\t\tlogical NOT";
    if (paramShort >= 91) return "OR\t\t\tlogical OR";
    if (paramShort >= 90) return "AND\t\tlogical AND";
    if (paramShort >= 89) return "EIF\t\tEnd IF";
    if (paramShort >= 88) return "IF\t\t\tIF test";
    if (paramShort >= 87) return "EVEN";
    if (paramShort >= 86) return "ODD";
    if (paramShort >= 85) return "NEQ\t\tNot EQual";
    if (paramShort >= 84) return "EQ\t\t\tEQual";
    if (paramShort >= 83) return "GTEQ\t\tGreater Than or Equal";
    if (paramShort >= 82) return "GT\t\t\tGreater Than";
    if (paramShort >= 81) return "LTEQ\t\tLess Than or Equal";
    if (paramShort >= 80) return "LT\t\t\tLess Than";
    if (paramShort >= 79) return "DEBUG";
    if (paramShort >= 78) return "FLIPOFF\tSet the auto_flip Boolean to OFF";
    if (paramShort >= 77) return "FLIPON\tSet the auto_flip Boolean to ON";
    if (paramShort >= 76) return "MPS\t\tMeasure Point Size";
    if (paramShort >= 75) return "MPPEM\t\tMeasure Pixels Per EM";
    if (paramShort >= 73) return "MD[" + (paramShort & 0x1) + "]\t\t\tMeasure Distance";
    if (paramShort >= 72) return "SCFS\t\tSets Coordinate From the Stack using projection_vector and freedom_vector";
    if (paramShort >= 70) return "GC[" + (paramShort & 0x1) + "]\t\t\tGet Coordinate projected onto the projection_vector";
    if (paramShort >= 69) return "RCVT\t\tRead Control Value Table";
    if (paramShort >= 68) return "WCVTP\t\tWrite Control Value Table in Pixel units";
    if (paramShort >= 67) return "RS\t\t\tRead Store";
    if (paramShort >= 66) return "WS\t\t\tWrite Store";
    if (paramShort >= 65) return "NPUSHW";
    if (paramShort >= 64) return "NPUSHB";
    if (paramShort >= 62) return "MIAP[" + ((paramShort & 0x1) == 0 ? "nrd+nci" : "rd+ci") + "]\t\tMove Indirect Absolute Point";
    if (paramShort >= 61) return "RTDG\t\tRound To Double Grid";
    if (paramShort >= 60) return "ALIGNRP\tALIGN Relative Point";
    if (paramShort >= 58) return "MSIRP[" + (paramShort & 0x1) + "]\t\tMove Stack Indirect Relative Point";
    if (paramShort >= 57) return "IP\t\t\tInterpolate Point by the last relative stretch";
    if (paramShort >= 56) return "SHPIX\t\tSHift point by a PIXel amount";
    if (paramShort >= 54) return "SHZ[" + (paramShort & 0x1) + "]\t\tSHift Zone by the last pt";
    if (paramShort >= 52) return "SHC[" + (paramShort & 0x1) + "]\t\tSHift Contour by the last point";
    if (paramShort >= 50) return "SHP\t\tSHift Point by the last point";
    if (paramShort >= 48) return "IUP[" + ((paramShort & 0x1) == 0 ? "y" : "x") + "]\t\tInterpolate Untouched Points through the outline";
    if (paramShort >= 46) return "MDAP[" + ((paramShort & 0x1) == 0 ? "nrd" : "rd") + "]\t\tMove Direct Absolute Point";
    if (paramShort >= 45) return "ENDF\t\tEND Function definition";
    if (paramShort >= 44) return "FDEF\t\tFunction DEFinition ";
    if (paramShort >= 43) return "CALL\t\tCALL function";
    if (paramShort >= 42) return "LOOPCALL\tLOOP and CALL function";
    if (paramShort >= 41) return "UTP\t\tUnTouch Point";
    if (paramShort >= 39) return "ALIGNPTS\tALIGN Points";
    if (paramShort >= 38) return "MINDEX\tMove the INDEXed element to the top of the stack";
    if (paramShort >= 37) return "CINDEX\tCopy the INDEXed element to the top of the stack";
    if (paramShort >= 36) return "DEPTH\t\tReturns the DEPTH of the stack";
    if (paramShort >= 35) return "SWAP\t\tSWAP the top two elements on the stack";
    if (paramShort >= 34) return "CLEAR\t\tClear the entire stack";
    if (paramShort >= 33) return "POP\t\tPOP top stack element";
    if (paramShort >= 32) return "DUP\t\tDuplicate top stack element";
    if (paramShort >= 31) return "SSW\t\tSet Single-width";
    if (paramShort >= 30) return "SSWCI\t\tSet Single_Width_Cut_In";
    if (paramShort >= 29) return "SCVTCI\tSet Control Value Table Cut In";
    if (paramShort >= 28) return "JMPR\t\tJuMP";
    if (paramShort >= 27) return "ELSE";
    if (paramShort >= 26) return "SMD\t\tSet Minimum_ Distance";
    if (paramShort >= 25) return "RTHG\t\tRound To Half Grid";
    if (paramShort >= 24) return "RTG\t\tRound To Grid";
    if (paramShort >= 23) return "SLOOP\t\tSet LOOP variable";
    if (paramShort >= 22) return "SZPS\t\tSet Zone PointerS";
    if (paramShort >= 21) return "SZP2\t\tSet Zone Pointer 2";
    if (paramShort >= 20) return "SZP1\t\tSet Zone Pointer 1";
    if (paramShort >= 19) return "SZP0\t\tSet Zone Pointer 0";
    if (paramShort >= 18) return "SRP2\t\tSet Reference Point 2";
    if (paramShort >= 17) return "SRP1\t\tSet Reference Point 1";
    if (paramShort >= 16) return "SRP0\t\tSet Reference Point 0";
    if (paramShort >= 15) return "ISECT\t\tmoves point p to the InterSECTion of two lines";
    if (paramShort >= 14) return "SFVTPV\tSet Freedom_Vector To Projection Vector";
    if (paramShort >= 13) return "GFV\t\tGet Freedom_Vector";
    if (paramShort >= 12) return "GPV\t\tGet Projection_Vector";
    if (paramShort >= 11) return "SFVFS\t\tSet Freedom_Vector From Stack";
    if (paramShort >= 10) return "SPVFS\t\tSet Projection_Vector From Stack";
    if (paramShort >= 8) return "SFVTL[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]\t\tSet Freedom_Vector To Line";
    if (paramShort >= 6) return "SPVTL[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]\t\tSet Projection_Vector To Line";
    if (paramShort >= 4) return "SFVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]\tSet Freedom_Vector to Coordinate Axis";
    if (paramShort >= 2) return "SPVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]\tSet Projection_Vector To Coordinate Axis";
    if (paramShort >= 0) return "SVTCA[" + ((paramShort & 0x1) == 0 ? "y-axis" : "x-axis") + "]\t\tSet freedom and projection Vectors To Coordinate Axis";
    return "????";
  }
}
