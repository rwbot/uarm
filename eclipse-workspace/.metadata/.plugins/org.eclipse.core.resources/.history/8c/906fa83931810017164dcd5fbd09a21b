package processing.core;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferInt;
import java.awt.image.PixelGrabber;
import java.awt.image.WritableRaster;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Iterator;
import javax.imageio.IIOImage;
import javax.imageio.ImageIO;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataNode;



































































public class PImage
  implements PConstants, Cloneable
{
  public int format;
  public int[] pixels;
  public int pixelDensity = 1;
  



  public int pixelWidth;
  


  public int pixelHeight;
  


  public int width;
  


  public int height;
  


  public PApplet parent;
  


  protected boolean modified;
  


  protected int mx1;
  


  protected int my1;
  


  protected int mx2;
  


  protected int my2;
  


  public boolean loaded = false;
  
  private int fracU;
  
  private int ifU;
  
  private int fracV;
  
  private int ifV;
  
  private int u1;
  
  private int u2;
  
  private int v1;
  
  private int v2;
  
  private int sX;
  
  private int sY;
  
  private int iw;
  
  private int iw1;
  
  private int ih1;
  
  private int ul;
  
  private int ll;
  private int ur;
  private int lr;
  private int cUL;
  private int cLL;
  private int cUR;
  private int cLR;
  private int srcXOffset;
  private int srcYOffset;
  private int r;
  private int g;
  private int b;
  private int a;
  private int[] srcBuffer;
  static final int PRECISIONB = 15;
  static final int PRECISIONF = 32768;
  static final int PREC_MAXVAL = 32767;
  static final int PREC_ALPHA_SHIFT = 9;
  static final int PREC_RED_SHIFT = 1;
  private int blurRadius;
  private int blurKernelSize;
  private int[] blurKernel;
  private int[][] blurMult;
  public static final int ALPHA_MASK = -16777216;
  public static final int RED_MASK = 16711680;
  public static final int GREEN_MASK = 65280;
  public static final int BLUE_MASK = 255;
  private static final int RB_MASK = 16711935;
  private static final int GN_MASK = 65280;
  
  public PImage()
  {
    format = 2;
    pixelDensity = 1;
  }
  





  public PImage(int width, int height)
  {
    init(width, height, 1, 1);
  }
  













  public PImage(int width, int height, int format)
  {
    init(width, height, format, 1);
  }
  
  public PImage(int width, int height, int format, int factor)
  {
    init(width, height, format, factor);
  }
  



  public void init(int width, int height, int format)
  {
    init(width, height, format, 1);
  }
  







  public void init(int width, int height, int format, int factor)
  {
    this.width = width;
    this.height = height;
    this.format = format;
    pixelDensity = factor;
    
    pixelWidth = (width * pixelDensity);
    pixelHeight = (height * pixelDensity);
    pixels = new int[pixelWidth * pixelHeight];
  }
  



  protected void checkAlpha()
  {
    if (pixels == null) { return;
    }
    for (int i = 0; i < pixels.length; i++)
    {

      if ((pixels[i] & 0xFF000000) != -16777216) {
        format = 2;
        break;
      }
    }
  }
  












  public PImage(Image img)
  {
    format = 1;
    if ((img instanceof BufferedImage)) {
      BufferedImage bi = (BufferedImage)img;
      width = bi.getWidth();
      height = bi.getHeight();
      int type = bi.getType();
      if ((type == 5) || 
        (type == 6)) {
        pixels = new int[width * height];
        bi.getRGB(0, 0, width, height, pixels, 0, width);
        if (type == 6) {
          format = 2;
        } else {
          opaque();
        }
      } else {
        DataBuffer db = bi.getRaster().getDataBuffer();
        if ((db instanceof DataBufferInt)) {
          pixels = ((DataBufferInt)db).getData();
          if (type == 2) {
            format = 2;
          } else if (type == 1) {
            opaque();
          }
        }
      }
    }
    

    if (pixels == null) {
      width = img.getWidth(null);
      height = img.getHeight(null);
      pixels = new int[width * height];
      PixelGrabber pg = 
        new PixelGrabber(img, 0, 0, width, height, pixels, 0, width);
      try {
        pg.grabPixels();
      } catch (InterruptedException localInterruptedException) {}
    }
    pixelDensity = 1;
    pixelWidth = width;
    pixelHeight = height;
  }
  





  public Image getImage()
  {
    return (Image)getNative();
  }
  



  public Object getNative()
  {
    loadPixels();
    int type = format == 1 ? 
      1 : 2;
    BufferedImage image = new BufferedImage(pixelWidth, pixelHeight, type);
    WritableRaster wr = image.getRaster();
    wr.setDataElements(0, 0, pixelWidth, pixelHeight, pixels);
    return image;
  }
  





  public boolean isModified()
  {
    return modified;
  }
  
  public void setModified()
  {
    modified = true;
    mx1 = 0;
    my1 = 0;
    mx2 = pixelWidth;
    my2 = pixelHeight;
  }
  
  public void setModified(boolean m)
  {
    modified = m;
  }
  
  public int getModifiedX1()
  {
    return mx1;
  }
  
  public int getModifiedX2()
  {
    return mx2;
  }
  
  public int getModifiedY1()
  {
    return my1;
  }
  
  public int getModifiedY2()
  {
    return my2;
  }
  

























  public void loadPixels()
  {
    if ((pixels == null) || (pixels.length != pixelWidth * pixelHeight)) {
      pixels = new int[pixelWidth * pixelHeight];
    }
    setLoaded();
  }
  
  public void updatePixels()
  {
    updatePixels(0, 0, pixelWidth, pixelHeight);
  }
  































  public void updatePixels(int x, int y, int w, int h)
  {
    int x2 = x + w;
    int y2 = y + h;
    
    if (!modified) {
      mx1 = PApplet.max(0, x);
      mx2 = PApplet.min(pixelWidth, x2);
      my1 = PApplet.max(0, y);
      my2 = PApplet.min(pixelHeight, y2);
      modified = true;
    }
    else {
      if (x < mx1) mx1 = PApplet.max(0, x);
      if (x > mx2) mx2 = PApplet.min(pixelWidth, x);
      if (y < my1) my1 = PApplet.max(0, y);
      if (y > my2) { my2 = PApplet.min(pixelHeight, y);
      }
      if (x2 < mx1) mx1 = PApplet.max(0, x2);
      if (x2 > mx2) mx2 = PApplet.min(pixelWidth, x2);
      if (y2 < my1) my1 = PApplet.max(0, y2);
      if (y2 > my2) { my2 = PApplet.min(pixelHeight, y2);
      }
    }
  }
  












  public Object clone()
    throws CloneNotSupportedException
  {
    return get();
  }
  























  public void resize(int w, int h)
  {
    if ((w <= 0) && (h <= 0)) {
      throw new IllegalArgumentException("width or height must be > 0 for resize");
    }
    
    if (w == 0) {
      float diff = h / height;
      w = (int)(width * diff);
    } else if (h == 0) {
      float diff = w / width;
      h = (int)(height * diff);
    }
    
    BufferedImage img = 
      shrinkImage((BufferedImage)getNative(), w * pixelDensity, h * pixelDensity);
    
    PImage temp = new PImage(img);
    pixelWidth = width;
    pixelHeight = height;
    

    pixels = pixels;
    
    width = (pixelWidth / pixelDensity);
    height = (pixelHeight / pixelDensity);
    

    updatePixels();
  }
  






  private static BufferedImage shrinkImage(BufferedImage img, int targetWidth, int targetHeight)
  {
    int type = img.getTransparency() == 1 ? 
      1 : 2;
    BufferedImage outgoing = img;
    BufferedImage scratchImage = null;
    Graphics2D g2 = null;
    int prevW = outgoing.getWidth();
    int prevH = outgoing.getHeight();
    boolean isTranslucent = img.getTransparency() != 1;
    


    int w = img.getWidth();
    int h = img.getHeight();
    do
    {
      if (w > targetWidth) {
        w /= 2;
        
        if (w < targetWidth) {
          w = targetWidth;
        }
      } else if (targetWidth >= w) {
        w = targetWidth;
      }
      if (h > targetHeight) {
        h /= 2;
        if (h < targetHeight) {
          h = targetHeight;
        }
      } else if (targetHeight >= h) {
        h = targetHeight;
      }
      if ((scratchImage == null) || (isTranslucent))
      {

        scratchImage = new BufferedImage(w, h, type);
        g2 = scratchImage.createGraphics();
      }
      g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, 
        RenderingHints.VALUE_INTERPOLATION_BILINEAR);
      g2.drawImage(outgoing, 0, 0, w, h, 0, 0, prevW, prevH, null);
      prevW = w;
      prevH = h;
      outgoing = scratchImage;
    } while ((w != targetWidth) || (h != targetHeight));
    
    if (g2 != null) {
      g2.dispose();
    }
    


    if ((targetWidth != outgoing.getWidth()) || 
      (targetHeight != outgoing.getHeight())) {
      scratchImage = new BufferedImage(targetWidth, targetHeight, type);
      g2 = scratchImage.createGraphics();
      g2.drawImage(outgoing, 0, 0, null);
      g2.dispose();
      outgoing = scratchImage;
    }
    return outgoing;
  }
  





  public boolean isLoaded()
  {
    return loaded;
  }
  
  public void setLoaded()
  {
    loaded = true;
  }
  
  public void setLoaded(boolean l)
  {
    loaded = l;
  }
  
























































  public int get(int x, int y)
  {
    if ((x < 0) || (y < 0) || (x >= pixelWidth) || (y >= pixelHeight)) { return 0;
    }
    switch (format) {
    case 1: 
      return pixels[(y * pixelWidth + x)] | 0xFF000000;
    
    case 2: 
      return pixels[(y * pixelWidth + x)];
    
    case 4: 
      return pixels[(y * pixelWidth + x)] << 24 | 0xFFFFFF;
    }
    return 0;
  }
  




  public PImage get(int x, int y, int w, int h)
  {
    int targetX = 0;
    int targetY = 0;
    int targetWidth = w;
    int targetHeight = h;
    boolean cropped = false;
    
    if (x < 0) {
      w += x;
      targetX = -x;
      cropped = true;
      x = 0;
    }
    if (y < 0) {
      h += y;
      targetY = -y;
      cropped = true;
      y = 0;
    }
    
    if (x + w > pixelWidth) {
      w = pixelWidth - x;
      cropped = true;
    }
    if (y + h > pixelHeight) {
      h = pixelHeight - y;
      cropped = true;
    }
    
    if (w < 0) {
      w = 0;
    }
    if (h < 0) {
      h = 0;
    }
    
    int targetFormat = format;
    if ((cropped) && (format == 1)) {
      targetFormat = 2;
    }
    
    PImage target = new PImage(targetWidth / pixelDensity, 
      targetHeight / pixelDensity, 
      targetFormat, pixelDensity);
    parent = parent;
    if ((w > 0) && (h > 0)) {
      getImpl(x, y, w, h, target, targetX, targetY);
    }
    return target;
  }
  






  public PImage get()
  {
    return get(0, 0, pixelWidth, pixelHeight);
  }
  
  public PImage copy()
  {
    return get(0, 0, pixelWidth, pixelHeight);
  }
  








  protected void getImpl(int sourceX, int sourceY, int sourceWidth, int sourceHeight, PImage target, int targetX, int targetY)
  {
    int sourceIndex = sourceY * pixelWidth + sourceX;
    int targetIndex = targetY * pixelWidth + targetX;
    for (int row = 0; row < sourceHeight; row++) {
      System.arraycopy(pixels, sourceIndex, pixels, targetIndex, sourceWidth);
      sourceIndex += pixelWidth;
      targetIndex += pixelWidth;
    }
  }
  































  public void set(int x, int y, int c)
  {
    if ((x < 0) || (y < 0) || (x >= pixelWidth) || (y >= pixelHeight)) return;
    pixels[(y * pixelWidth + x)] = c;
    updatePixels(x, y, 1, 1);
  }
  








  public void set(int x, int y, PImage img)
  {
    int sx = 0;
    int sy = 0;
    int sw = pixelWidth;
    int sh = pixelHeight;
    
    if (x < 0) {
      sx -= x;
      sw += x;
      x = 0;
    }
    if (y < 0) {
      sy -= y;
      sh += y;
      y = 0;
    }
    if (x + sw > pixelWidth) {
      sw = pixelWidth - x;
    }
    if (y + sh > pixelHeight) {
      sh = pixelHeight - y;
    }
    

    if ((sw <= 0) || (sh <= 0)) { return;
    }
    setImpl(img, sx, sy, sw, sh, x, y);
  }
  







  protected void setImpl(PImage sourceImage, int sourceX, int sourceY, int sourceWidth, int sourceHeight, int targetX, int targetY)
  {
    int sourceOffset = sourceY * pixelWidth + sourceX;
    int targetOffset = targetY * pixelWidth + targetX;
    
    for (int y = sourceY; y < sourceY + sourceHeight; y++) {
      System.arraycopy(pixels, sourceOffset, pixels, targetOffset, sourceWidth);
      sourceOffset += pixelWidth;
      targetOffset += pixelWidth;
    }
    

    updatePixels(targetX, targetY, sourceWidth, sourceHeight);
  }
  










  @Deprecated
  public void mask(int[] maskArray)
  {
    loadPixels();
    
    if (maskArray.length != pixels.length) {
      throw new IllegalArgumentException("mask() can only be used with an image that's the same size.");
    }
    for (int i = 0; i < pixels.length; i++) {
      pixels[i] = ((maskArray[i] & 0xFF) << 24 | pixels[i] & 0xFFFFFF);
    }
    format = 2;
    updatePixels();
  }
  



































  public void mask(PImage img)
  {
    img.loadPixels();
    mask(pixels);
  }
  






  public void filter(int kind)
  {
    loadPixels();
    
    switch (kind)
    {


    case 11: 
      filter(11, 1.0F);
      break;
    
    case 12: 
      if (format == 4)
      {
        for (int i = 0; i < pixels.length; i++) {
          int col = 255 - pixels[i];
          pixels[i] = (0xFF000000 | col << 16 | col << 8 | col);
        }
        format = 1;

      }
      else
      {

        for (int i = 0; i < pixels.length; i++) {
          int col = pixels[i];
          



          int lum = 77 * (col >> 16 & 0xFF) + 151 * (col >> 8 & 0xFF) + 28 * (col & 0xFF) >> 8;
          pixels[i] = (col & 0xFF000000 | lum << 16 | lum << 8 | lum);
        }
      }
      break;
    
    case 13: 
      for (int i = 0; i < pixels.length; i++)
      {
        pixels[i] ^= 0xFFFFFF;
      }
      break;
    
    case 15: 
      throw new RuntimeException("Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)");
    

    case 14: 
      for (int i = 0; i < pixels.length; i++) {
        pixels[i] |= 0xFF000000;
      }
      format = 1;
      break;
    
    case 16: 
      filter(16, 0.5F);
      break;
    

    case 17: 
      erode();
      break;
    
    case 18: 
      dilate();
    }
    
    updatePixels();
  }
  





















































  public void filter(int kind, float param)
  {
    loadPixels();
    
    switch (kind) {
    case 11: 
      if (format == 4) {
        blurAlpha(param);
      } else if (format == 2) {
        blurARGB(param);
      } else
        blurRGB(param);
      break;
    
    case 12: 
      throw new RuntimeException("Use filter(GRAY) instead of filter(GRAY, param)");
    

    case 13: 
      throw new RuntimeException("Use filter(INVERT) instead of filter(INVERT, param)");
    

    case 14: 
      throw new RuntimeException("Use filter(OPAQUE) instead of filter(OPAQUE, param)");
    

    case 15: 
      int levels = (int)param;
      if ((levels < 2) || (levels > 255)) {
        throw new RuntimeException("Levels must be between 2 and 255 for filter(POSTERIZE, levels)");
      }
      
      int levels1 = levels - 1;
      for (int i = 0; i < pixels.length; i++) {
        int rlevel = pixels[i] >> 16 & 0xFF;
        int glevel = pixels[i] >> 8 & 0xFF;
        int blevel = pixels[i] & 0xFF;
        rlevel = (rlevel * levels >> 8) * 255 / levels1;
        glevel = (glevel * levels >> 8) * 255 / levels1;
        blevel = (blevel * levels >> 8) * 255 / levels1;
        pixels[i] = 
        

          (0xFF000000 & pixels[i] | rlevel << 16 | glevel << 8 | blevel);
      }
      break;
    
    case 16: 
      int thresh = (int)(param * 255.0F);
      for (int i = 0; i < pixels.length; i++) {
        int max = Math.max((pixels[i] & 0xFF0000) >> 16, 
          Math.max((pixels[i] & 0xFF00) >> 8, 
          pixels[i] & 0xFF));
        pixels[i] = 
          (pixels[i] & 0xFF000000 | (max < thresh ? 0 : 16777215));
      }
      break;
    

    case 17: 
      throw new RuntimeException("Use filter(ERODE) instead of filter(ERODE, param)");
    
    case 18: 
      throw new RuntimeException("Use filter(DILATE) instead of filter(DILATE, param)");
    }
    
    updatePixels();
  }
  

  protected void opaque()
  {
    for (int i = 0; i < pixels.length; i++) {
      pixels[i] = (0xFF000000 | pixels[i]);
    }
  }
  







  protected void buildBlurKernel(float r)
  {
    int radius = (int)(r * 3.5F);
    radius = radius < 248 ? radius : radius < 1 ? 1 : 248;
    if (blurRadius != radius) {
      blurRadius = radius;
      blurKernelSize = (1 + blurRadius << 1);
      blurKernel = new int[blurKernelSize];
      blurMult = new int[blurKernelSize]['Ä€'];
      



      int i = 1; for (int radiusi = radius - 1; i < radius; i++) { int bki;
        int tmp114_112 = (bki = radiusi * radiusi);blurKernel[radiusi] = tmp114_112;blurKernel[(radius + i)] = tmp114_112;
        int[] bm = blurMult[(radius + i)];
        int[] bmi = blurMult[(radiusi--)];
        for (int j = 0; j < 256; j++) {
          int tmp159_158 = (bki * j);bmi[j] = tmp159_158;bm[j] = tmp159_158;
        } }
      int bk = blurKernel[radius] = radius * radius;
      int[] bm = blurMult[radius];
      for (int j = 0; j < 256; j++) {
        bm[j] = (bk * j);
      }
    }
  }
  

  protected void blurAlpha(float r)
  {
    int[] b2 = new int[pixels.length];
    int yi = 0;
    
    buildBlurKernel(r);
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) {
        int sum;
        int cb = sum = 0;
        int read = x - blurRadius;
        int bk0; if (read < 0) {
          int bk0 = -read;
          read = 0;
        } else {
          if (read >= pixelWidth)
            break;
          bk0 = 0;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (read >= pixelWidth)
            break;
          int c = pixels[(read + yi)];
          int[] bm = blurMult[i];
          cb += bm[(c & 0xFF)];
          sum += blurKernel[i];
          read++;
        }
        int ri = yi + x;
        b2[ri] = (cb / sum);
      }
      yi += pixelWidth;
    }
    
    yi = 0;
    int ym = -blurRadius;
    int ymi = ym * pixelWidth;
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) { int sum;
        int cb = sum = 0;
        int read; int bk0; int ri; int read; if (ym < 0) { int ri;
          int bk0 = ri = -ym;
          read = x;
        } else {
          if (ym >= pixelHeight)
            break;
          bk0 = 0;
          ri = ym;
          read = x + ymi;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (ri >= pixelHeight)
            break;
          int[] bm = blurMult[i];
          cb += bm[b2[read]];
          sum += blurKernel[i];
          ri++;
          read += pixelWidth;
        }
        pixels[(x + yi)] = (cb / sum);
      }
      yi += pixelWidth;
      ymi += pixelWidth;
      ym++;
    }
  }
  


  protected void blurRGB(float r)
  {
    int[] r2 = new int[pixels.length];
    int[] g2 = new int[pixels.length];
    int[] b2 = new int[pixels.length];
    int yi = 0;
    
    buildBlurKernel(r);
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) { int sum;
        int cr; int cg; int cb = cg = cr = sum = 0;
        int read = x - blurRadius;
        int bk0; if (read < 0) {
          int bk0 = -read;
          read = 0;
        } else {
          if (read >= pixelWidth) {
            break;
          }
          bk0 = 0;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (read >= pixelWidth) {
            break;
          }
          int c = pixels[(read + yi)];
          int[] bm = blurMult[i];
          cr += bm[((c & 0xFF0000) >> 16)];
          cg += bm[((c & 0xFF00) >> 8)];
          cb += bm[(c & 0xFF)];
          sum += blurKernel[i];
          read++;
        }
        int ri = yi + x;
        r2[ri] = (cr / sum);
        g2[ri] = (cg / sum);
        b2[ri] = (cb / sum);
      }
      yi += pixelWidth;
    }
    
    yi = 0;
    int ym = -blurRadius;
    int ymi = ym * pixelWidth;
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) { int sum;
        int cr; int cg; int cb = cg = cr = sum = 0;
        int read; int bk0; int ri; int read; if (ym < 0) { int ri;
          int bk0 = ri = -ym;
          read = x;
        } else {
          if (ym >= pixelHeight) {
            break;
          }
          bk0 = 0;
          ri = ym;
          read = x + ymi;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (ri >= pixelHeight) {
            break;
          }
          int[] bm = blurMult[i];
          cr += bm[r2[read]];
          cg += bm[g2[read]];
          cb += bm[b2[read]];
          sum += blurKernel[i];
          ri++;
          read += pixelWidth;
        }
        pixels[(x + yi)] = (0xFF000000 | cr / sum << 16 | cg / sum << 8 | cb / sum);
      }
      yi += pixelWidth;
      ymi += pixelWidth;
      ym++;
    }
  }
  


  protected void blurARGB(float r)
  {
    int wh = pixels.length;
    int[] r2 = new int[wh];
    int[] g2 = new int[wh];
    int[] b2 = new int[wh];
    int[] a2 = new int[wh];
    int yi = 0;
    
    buildBlurKernel(r);
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) { int sum;
        int ca; int cr; int cg; int cb = cg = cr = ca = sum = 0;
        int read = x - blurRadius;
        int bk0; if (read < 0) {
          int bk0 = -read;
          read = 0;
        } else {
          if (read >= pixelWidth) {
            break;
          }
          bk0 = 0;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (read >= pixelWidth) {
            break;
          }
          int c = pixels[(read + yi)];
          int[] bm = blurMult[i];
          ca += bm[((c & 0xFF000000) >>> 24)];
          cr += bm[((c & 0xFF0000) >> 16)];
          cg += bm[((c & 0xFF00) >> 8)];
          cb += bm[(c & 0xFF)];
          sum += blurKernel[i];
          read++;
        }
        int ri = yi + x;
        a2[ri] = (ca / sum);
        r2[ri] = (cr / sum);
        g2[ri] = (cg / sum);
        b2[ri] = (cb / sum);
      }
      yi += pixelWidth;
    }
    
    yi = 0;
    int ym = -blurRadius;
    int ymi = ym * pixelWidth;
    
    for (int y = 0; y < pixelHeight; y++) {
      for (int x = 0; x < pixelWidth; x++) { int sum;
        int ca; int cr; int cg; int cb = cg = cr = ca = sum = 0;
        int read; int bk0; int ri; int read; if (ym < 0) { int ri;
          int bk0 = ri = -ym;
          read = x;
        } else {
          if (ym >= pixelHeight) {
            break;
          }
          bk0 = 0;
          ri = ym;
          read = x + ymi;
        }
        for (int i = bk0; i < blurKernelSize; i++) {
          if (ri >= pixelHeight) {
            break;
          }
          int[] bm = blurMult[i];
          ca += bm[a2[read]];
          cr += bm[r2[read]];
          cg += bm[g2[read]];
          cb += bm[b2[read]];
          sum += blurKernel[i];
          ri++;
          read += pixelWidth;
        }
        pixels[(x + yi)] = (ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum);
      }
      yi += pixelWidth;
      ymi += pixelWidth;
      ym++;
    }
  }
  




  protected void dilate()
  {
    int index = 0;
    int maxIndex = pixels.length;
    int[] outgoing = new int[maxIndex];
    int maxRowIndex;
    for (; 
        index < maxIndex; 
        

        index < maxRowIndex)
    {
      int curRowIndex = index;
      maxRowIndex = index + pixelWidth;
      continue;
      int orig = pixels[index];
      int result = orig;
      int idxLeft = index - 1;
      int idxRight = index + 1;
      int idxUp = index - pixelWidth;
      int idxDown = index + pixelWidth;
      if (idxLeft < curRowIndex) {
        idxLeft = index;
      }
      if (idxRight >= maxRowIndex) {
        idxRight = index;
      }
      if (idxUp < 0) {
        idxUp = index;
      }
      if (idxDown >= maxIndex) {
        idxDown = index;
      }
      
      int colUp = pixels[idxUp];
      int colLeft = pixels[idxLeft];
      int colDown = pixels[idxDown];
      int colRight = pixels[idxRight];
      

      int currLum = 
        77 * (orig >> 16 & 0xFF) + 151 * (orig >> 8 & 0xFF) + 28 * (orig & 0xFF);
      int lumLeft = 
        77 * (colLeft >> 16 & 0xFF) + 151 * (colLeft >> 8 & 0xFF) + 28 * (colLeft & 0xFF);
      int lumRight = 
        77 * (colRight >> 16 & 0xFF) + 151 * (colRight >> 8 & 0xFF) + 28 * (colRight & 0xFF);
      int lumUp = 
        77 * (colUp >> 16 & 0xFF) + 151 * (colUp >> 8 & 0xFF) + 28 * (colUp & 0xFF);
      int lumDown = 
        77 * (colDown >> 16 & 0xFF) + 151 * (colDown >> 8 & 0xFF) + 28 * (colDown & 0xFF);
      
      if (lumLeft > currLum) {
        result = colLeft;
        currLum = lumLeft;
      }
      if (lumRight > currLum) {
        result = colRight;
        currLum = lumRight;
      }
      if (lumUp > currLum) {
        result = colUp;
        currLum = lumUp;
      }
      if (lumDown > currLum) {
        result = colDown;
        currLum = lumDown;
      }
      outgoing[(index++)] = result;
    }
    
    System.arraycopy(outgoing, 0, pixels, 0, maxIndex);
  }
  
  protected void erode()
  {
    int index = 0;
    int maxIndex = pixels.length;
    int[] outgoing = new int[maxIndex];
    int maxRowIndex;
    for (; 
        index < maxIndex; 
        

        index < maxRowIndex)
    {
      int curRowIndex = index;
      maxRowIndex = index + pixelWidth;
      continue;
      int orig = pixels[index];
      int result = orig;
      int idxLeft = index - 1;
      int idxRight = index + 1;
      int idxUp = index - pixelWidth;
      int idxDown = index + pixelWidth;
      if (idxLeft < curRowIndex) {
        idxLeft = index;
      }
      if (idxRight >= maxRowIndex) {
        idxRight = index;
      }
      if (idxUp < 0) {
        idxUp = index;
      }
      if (idxDown >= maxIndex) {
        idxDown = index;
      }
      
      int colUp = pixels[idxUp];
      int colLeft = pixels[idxLeft];
      int colDown = pixels[idxDown];
      int colRight = pixels[idxRight];
      

      int currLum = 
        77 * (orig >> 16 & 0xFF) + 151 * (orig >> 8 & 0xFF) + 28 * (orig & 0xFF);
      int lumLeft = 
        77 * (colLeft >> 16 & 0xFF) + 151 * (colLeft >> 8 & 0xFF) + 28 * (colLeft & 0xFF);
      int lumRight = 
        77 * (colRight >> 16 & 0xFF) + 151 * (colRight >> 8 & 0xFF) + 28 * (colRight & 0xFF);
      int lumUp = 
        77 * (colUp >> 16 & 0xFF) + 151 * (colUp >> 8 & 0xFF) + 28 * (colUp & 0xFF);
      int lumDown = 
        77 * (colDown >> 16 & 0xFF) + 151 * (colDown >> 8 & 0xFF) + 28 * (colDown & 0xFF);
      
      if (lumLeft < currLum) {
        result = colLeft;
        currLum = lumLeft;
      }
      if (lumRight < currLum) {
        result = colRight;
        currLum = lumRight;
      }
      if (lumUp < currLum) {
        result = colUp;
        currLum = lumUp;
      }
      if (lumDown < currLum) {
        result = colDown;
        currLum = lumDown;
      }
      outgoing[(index++)] = result;
    }
    
    System.arraycopy(outgoing, 0, pixels, 0, maxIndex);
  }
  


































  public void copy(int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh)
  {
    blend(this, sx, sy, sw, sh, dx, dy, dw, dh, 0);
  }
  





  public void copy(PImage src, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh)
  {
    blend(src, sx, sy, sw, sh, dx, dy, dw, dh, 0);
  }
  





















































































  public static int blendColor(int c1, int c2, int mode)
  {
    switch (mode) {
    case 0:  return c2;
    case 1:  return blend_blend(c1, c2);
    case 2: 
      return blend_add_pin(c1, c2);
    case 4:  return blend_sub_pin(c1, c2);
    case 8: 
      return blend_lightest(c1, c2);
    case 16:  return blend_darkest(c1, c2);
    case 32: 
      return blend_difference(c1, c2);
    case 64:  return blend_exclusion(c1, c2);
    case 128: 
      return blend_multiply(c1, c2);
    case 256:  return blend_screen(c1, c2);
    case 1024: 
      return blend_hard_light(c1, c2);
    case 2048:  return blend_soft_light(c1, c2);
    case 512:  return blend_overlay(c1, c2);
    case 4096: 
      return blend_dodge(c1, c2);
    case 8192:  return blend_burn(c1, c2);
    }
    return 0;
  }
  

  public void blend(int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, int mode)
  {
    blend(this, sx, sy, sw, sh, dx, dy, dw, dh, mode);
  }
  






































































  public void blend(PImage src, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, int mode)
  {
    int sx2 = sx + sw;
    int sy2 = sy + sh;
    int dx2 = dx + dw;
    int dy2 = dy + dh;
    
    loadPixels();
    if (src == this) {
      if (intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {
        blit_resize(get(sx, sy, sw, sh), 
          0, 0, sw, sh, 
          pixels, pixelWidth, pixelHeight, dx, dy, dx2, dy2, mode);
      }
      else {
        blit_resize(src, sx, sy, sx2, sy2, 
          pixels, pixelWidth, pixelHeight, dx, dy, dx2, dy2, mode);
      }
    } else {
      src.loadPixels();
      blit_resize(src, sx, sy, sx2, sy2, 
        pixels, pixelWidth, pixelHeight, dx, dy, dx2, dy2, mode);
    }
    
    updatePixels();
  }
  




  private boolean intersect(int sx1, int sy1, int sx2, int sy2, int dx1, int dy1, int dx2, int dy2)
  {
    int sw = sx2 - sx1 + 1;
    int sh = sy2 - sy1 + 1;
    int dw = dx2 - dx1 + 1;
    int dh = dy2 - dy1 + 1;
    
    if (dx1 < sx1) {
      dw += dx1 - sx1;
      if (dw > sw) {
        dw = sw;
      }
    } else {
      int w = sw + sx1 - dx1;
      if (dw > w) {
        dw = w;
      }
    }
    if (dy1 < sy1) {
      dh += dy1 - sy1;
      if (dh > sh) {
        dh = sh;
      }
    } else {
      int h = sh + sy1 - dy1;
      if (dh > h) {
        dh = h;
      }
    }
    return (dw > 0) && (dh > 0);
  }
  












  private void blit_resize(PImage img, int srcX1, int srcY1, int srcX2, int srcY2, int[] destPixels, int screenW, int screenH, int destX1, int destY1, int destX2, int destY2, int mode)
  {
    if (srcX1 < 0) srcX1 = 0;
    if (srcY1 < 0) srcY1 = 0;
    if (srcX2 > pixelWidth) srcX2 = pixelWidth;
    if (srcY2 > pixelHeight) { srcY2 = pixelHeight;
    }
    int srcW = srcX2 - srcX1;
    int srcH = srcY2 - srcY1;
    int destW = destX2 - destX1;
    int destH = destY2 - destY1;
    
    boolean smooth = true;
    
    if (!smooth) {
      srcW++;srcH++;
    }
    
    if ((destW <= 0) || (destH <= 0) || 
      (srcW <= 0) || (srcH <= 0) || 
      (destX1 >= screenW) || (destY1 >= screenH) || 
      (srcX1 >= pixelWidth) || (srcY1 >= pixelHeight)) {
      return;
    }
    
    int dx = (int)(srcW / destW * 32768.0F);
    int dy = (int)(srcH / destH * 32768.0F);
    
    srcXOffset = (destX1 < 0 ? -destX1 * dx : srcX1 * 32768);
    srcYOffset = (destY1 < 0 ? -destY1 * dy : srcY1 * 32768);
    
    if (destX1 < 0) {
      destW += destX1;
      destX1 = 0;
    }
    if (destY1 < 0) {
      destH += destY1;
      destY1 = 0;
    }
    
    destW = min(destW, screenW - destX1);
    destH = min(destH, screenH - destY1);
    
    int destOffset = destY1 * screenW + destX1;
    srcBuffer = pixels;
    
    if (smooth)
    {
      iw = pixelWidth;
      iw1 = (pixelWidth - 1);
      ih1 = (pixelHeight - 1);
      
      switch (mode)
      {
      case 1: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++)
          {
            destPixels[(destOffset + x)] = 
              blend_blend(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 2: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_add_pin(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 4: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_sub_pin(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 8: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_lightest(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 16: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_darkest(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 0: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = filter_bilinear();
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 32: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_difference(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 64: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_exclusion(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 128: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_multiply(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 256: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_screen(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 512: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_overlay(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 1024: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_hard_light(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 2048: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_soft_light(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      

      case 4096: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_dodge(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 8192: 
        for (int y = 0; y < destH; y++) {
          filter_new_scanline();
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_burn(destPixels[(destOffset + x)], filter_bilinear());
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
      
      }
      
    }
    else
    {
      switch (mode)
      {
      case 1: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++)
          {
            destPixels[(destOffset + x)] = 
              blend_blend(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 2: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_add_pin(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 4: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_sub_pin(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 8: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_lightest(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 16: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_darkest(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 0: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = srcBuffer[(sY + (sX >> 15))];
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 32: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_difference(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 64: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_exclusion(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 128: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_multiply(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 256: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_screen(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 512: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_overlay(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 1024: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_hard_light(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 2048: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_soft_light(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      

      case 4096: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_dodge(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
        break;
      
      case 8192: 
        for (int y = 0; y < destH; y++) {
          sX = srcXOffset;
          sY = ((srcYOffset >> 15) * pixelWidth);
          for (int x = 0; x < destW; x++) {
            destPixels[(destOffset + x)] = 
              blend_burn(destPixels[(destOffset + x)], 
              srcBuffer[(sY + (sX >> 15))]);
            sX += dx;
          }
          destOffset += screenW;
          srcYOffset += dy;
        }
      }
      
    }
  }
  

  private void filter_new_scanline()
  {
    sX = srcXOffset;
    fracV = (srcYOffset & 0x7FFF);
    ifV = (32767 - fracV + 1);
    v1 = ((srcYOffset >> 15) * iw);
    v2 = (min((srcYOffset >> 15) + 1, ih1) * iw);
  }
  
  private int filter_bilinear()
  {
    fracU = (sX & 0x7FFF);
    ifU = (32767 - fracU + 1);
    ul = (ifU * ifV >> 15);
    ll = (ifU - ul);
    ur = (ifV - ul);
    lr = (32768 - ul - ll - ur);
    u1 = (sX >> 15);
    u2 = min(u1 + 1, iw1);
    

    cUL = srcBuffer[(v1 + u1)];
    cUR = srcBuffer[(v1 + u2)];
    cLL = srcBuffer[(v2 + u1)];
    cLR = srcBuffer[(v2 + u2)];
    
    r = 
    
      (ul * ((cUL & 0xFF0000) >> 16) + ll * ((cLL & 0xFF0000) >> 16) + ur * ((cUR & 0xFF0000) >> 16) + lr * ((cLR & 0xFF0000) >> 16) << 1 & 0xFF0000);
    
    g = 
    
      (ul * (cUL & 0xFF00) + ll * (cLL & 0xFF00) + ur * (cUR & 0xFF00) + lr * (cLR & 0xFF00) >>> 15 & 0xFF00);
    
    b = 
    
      (ul * (cUL & 0xFF) + ll * (cLL & 0xFF) + ur * (cUR & 0xFF) + lr * (cLR & 0xFF) >>> 15);
    
    a = 
    
      (ul * ((cUL & 0xFF000000) >>> 24) + ll * ((cLL & 0xFF000000) >>> 24) + ur * ((cUR & 0xFF000000) >>> 24) + lr * ((cLR & 0xFF000000) >>> 24) << 9 & 0xFF000000);
    
    return a | r | g | b;
  }
  






  private static int min(int a, int b)
  {
    return a < b ? a : b;
  }
  
  private static int max(int a, int b)
  {
    return a > b ? a : b;
  }
  


































































































  private static int blend_blend(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + (src & 0xFF00FF) * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + (src & 0xFF00) * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_add_pin(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    
    int rb = (dst & 0xFF00FF) + ((src & 0xFF00FF) * s_a >>> 8 & 0xFF00FF);
    int gn = (dst & 0xFF00) + ((src & 0xFF00) * s_a >>> 8);
    
    return min((dst >>> 24) + a, 255) << 24 | 
      min(rb & 0xFFFF0000, 16711680) | 
      min(gn & 0xFFFF00, 65280) | 
      min(rb & 0xFFFF, 255);
  }
  




  private static int blend_sub_pin(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    
    int rb = (src & 0xFF00FF) * s_a >>> 8;
    int gn = (src & 0xFF00) * s_a >>> 8;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      max((dst & 0xFF0000) - (rb & 0xFF0000), 0) | 
      max((dst & 0xFF00) - (gn & 0xFF00), 0) | 
      max((dst & 0xFF) - (rb & 0xFF), 0);
  }
  




  private static int blend_lightest(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int rb = max(src & 0xFF0000, dst & 0xFF0000) | 
      max(src & 0xFF, dst & 0xFF);
    int gn = max(src & 0xFF00, dst & 0xFF00);
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_darkest(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int rb = min(src & 0xFF0000, dst & 0xFF0000) | 
      min(src & 0xFF, dst & 0xFF);
    int gn = min(src & 0xFF00, dst & 0xFF00);
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_difference(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int r = (dst & 0xFF0000) - (src & 0xFF0000);
    int b = (dst & 0xFF) - (src & 0xFF);
    int g = (dst & 0xFF00) - (src & 0xFF00);
    
    int rb = (r < 0 ? -r : r) | 
      (b < 0 ? -b : b);
    int gn = g < 0 ? -g : g;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  





  private static int blend_exclusion(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_rb = dst & 0xFF00FF;
    int d_gn = dst & 0xFF00;
    
    int s_gn = src & 0xFF00;
    
    int f_r = (dst & 0xFF0000) >> 16;
    int f_b = dst & 0xFF;
    
    int rb_sub = 
      ((src & 0xFF0000) * (f_r + (f_r >= 127 ? 1 : 0)) | 
      (src & 0xFF) * (f_b + (f_b >= 127 ? 1 : 0))) >>> 
      7 & 0x1FF01FF;
    int gn_sub = s_gn * (d_gn + (d_gn >= 32512 ? 256 : 0)) >>> 
      15 & 0x1FF00;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      d_rb * d_a + (d_rb + (src & 0xFF00FF) - rb_sub) * s_a >>> 8 & 0xFF00FF | 
      d_gn * d_a + (d_gn + s_gn - gn_sub) * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_multiply(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_gn = dst & 0xFF00;
    
    int f_r = (dst & 0xFF0000) >> 16;
    int f_b = dst & 0xFF;
    
    int rb = 
      ((src & 0xFF0000) * (f_r + 1) | 
      (src & 0xFF) * (f_b + 1)) >>> 
      8 & 0xFF00FF;
    int gn = 
      (src & 0xFF00) * (d_gn + 256) >>> 
      16 & 0xFF00;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      d_gn * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  





  private static int blend_screen(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_rb = dst & 0xFF00FF;
    int d_gn = dst & 0xFF00;
    
    int s_gn = src & 0xFF00;
    
    int f_r = (dst & 0xFF0000) >> 16;
    int f_b = dst & 0xFF;
    
    int rb_sub = 
      ((src & 0xFF0000) * (f_r + 1) | 
      (src & 0xFF) * (f_b + 1)) >>> 
      8 & 0xFF00FF;
    int gn_sub = s_gn * (d_gn + 256) >>> 
      16 & 0xFF00;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      d_rb * d_a + (d_rb + (src & 0xFF00FF) - rb_sub) * s_a >>> 8 & 0xFF00FF | 
      d_gn * d_a + (d_gn + s_gn - gn_sub) * s_a >>> 8 & 0xFF00;
  }
  





  private static int blend_overlay(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_r = dst & 0xFF0000;
    int d_g = dst & 0xFF00;
    int d_b = dst & 0xFF;
    
    int s_r = src & 0xFF0000;
    int s_g = src & 0xFF00;
    int s_b = src & 0xFF;
    
    int r = d_r < 8388608 ? 
      d_r * ((s_r >>> 16) + 1) >>> 7 : 
      16711680 - ((256 - (s_r >>> 16)) * (16711680 - d_r) >>> 7);
    int g = d_g < 32768 ? 
      d_g * (s_g + 256) >>> 15 : 
      65280 - ((65536 - s_g) * (65280 - d_g) >>> 15);
    int b = d_b < 128 ? 
      d_b * (s_b + 1) >>> 7 : 
      65280 - ((256 - s_b) * (255 - d_b) << 1) >>> 8;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + ((r | b) & 0xFF00FF) * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + (g & 0xFF00) * s_a >>> 8 & 0xFF00;
  }
  







  private static int blend_hard_light(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_r = dst & 0xFF0000;
    int d_g = dst & 0xFF00;
    int d_b = dst & 0xFF;
    
    int s_r = src & 0xFF0000;
    int s_g = src & 0xFF00;
    int s_b = src & 0xFF;
    
    int r = s_r < 8388608 ? 
      s_r * ((d_r >>> 16) + 1) >>> 7 : 
      16711680 - ((256 - (d_r >>> 16)) * (16711680 - s_r) >>> 7);
    int g = s_g < 32768 ? 
      s_g * (d_g + 256) >>> 15 : 
      65280 - ((65536 - d_g) * (65280 - s_g) >>> 15);
    int b = s_b < 128 ? 
      s_b * (d_b + 1) >>> 7 : 
      65280 - ((256 - d_b) * (255 - s_b) << 1) >>> 8;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + ((r | b) & 0xFF00FF) * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + (g & 0xFF00) * s_a >>> 8 & 0xFF00;
  }
  






  private static int blend_soft_light(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int d_r = dst & 0xFF0000;
    int d_g = dst & 0xFF00;
    int d_b = dst & 0xFF;
    
    int s_r1 = src & 0xFF;
    int s_g1 = src & 0xFF;
    int s_b1 = src & 0xFF;
    
    int d_r1 = (d_r >> 16) + (s_r1 < 7.0F ? 1 : 0);
    int d_g1 = (d_g >> 8) + (s_g1 < 7.0F ? 1 : 0);
    int d_b1 = d_b + (s_b1 < 7.0F ? 1 : 0);
    
    int r = (s_r1 * d_r >> 7) + 255 * d_r1 * (d_r1 + 1) - (
      s_r1 * d_r1 * d_r1 << 1) & 0xFF0000;
    int g = (s_g1 * d_g << 1) + 255 * d_g1 * (d_g1 + 1) - (
      s_g1 * d_g1 * d_g1 << 1) >>> 8 & 0xFF00;
    int b = (s_b1 * d_b << 9) + 255 * d_b1 * (d_b1 + 1) - (
      s_b1 * d_b1 * d_b1 << 1) >>> 16;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + (r | b) * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + g * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_dodge(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int r = (dst & 0xFF0000) / (256 - ((src & 0xFF0000) >> 16));
    int g = ((dst & 0xFF00) << 8) / (256 - ((src & 0xFF00) >> 8));
    int b = ((dst & 0xFF) << 8) / (256 - (src & 0xFF));
    
    int rb = 
      (r > 65280 ? 16711680 : r << 8 & 0xFF0000) | 
      (b > 255 ? 255 : b);
    int gn = 
      g > 65280 ? 65280 : g & 0xFF00;
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  




  private static int blend_burn(int dst, int src)
  {
    int a = src >>> 24;
    
    int s_a = a + (a >= 127 ? 1 : 0);
    int d_a = 256 - s_a;
    
    int r = (16711680 - (dst & 0xFF0000)) / (1 + (src & 0xFF));
    int g = (65280 - (dst & 0xFF00) << 8) / (1 + (src & 0xFF));
    int b = (255 - (dst & 0xFF) << 8) / (1 + (src & 0xFF));
    
    int rb = 16711935 - (
      r > 65280 ? 16711680 : r << 8 & 0xFF0000) - (
      b > 255 ? 255 : b);
    int gn = 65280 - (
      g > 65280 ? 65280 : g & 0xFF00);
    
    return min((dst >>> 24) + a, 255) << 24 | 
      (dst & 0xFF00FF) * d_a + rb * s_a >>> 8 & 0xFF00FF | 
      (dst & 0xFF00) * d_a + gn * s_a >>> 8 & 0xFF00;
  }
  






  static byte[] TIFF_HEADER = {
    77, 77, 0, 42, 0, 0, 0, 8, 0, 9, 0, -2, 0, 4, 0, 0, 0, 1, 
    0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 3, 0, 0, 0, 1, 
    0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 122, 1, 6, 0, 3, 
    0, 0, 0, 1, 0, 2, 0, 0, 1, 17, 0, 4, 0, 0, 0, 1, 0, 0, 3, 0, 1, 21, 
    0, 3, 0, 0, 0, 1, 0, 3, 0, 0, 1, 22, 0, 3, 0, 0, 0, 1, 
    0, 0, 0, 0, 1, 23, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 08 };
  
  static final String TIFF_ERROR = "Error: Processing can only read its own TIFF files.";
  
  protected String[] saveImageFormats;
  
  protected static PImage loadTIFF(byte[] tiff)
  {
    if ((tiff[42] != tiff[102]) || 
      (tiff[43] != tiff[103])) {
      System.err.println("Error: Processing can only read its own TIFF files.");
      return null;
    }
    
    int width = 
      (tiff[30] & 0xFF) << 8 | tiff[31] & 0xFF;
    int height = 
      (tiff[42] & 0xFF) << 8 | tiff[43] & 0xFF;
    
    int count = 
      (tiff[114] & 0xFF) << 24 | 
      (tiff[115] & 0xFF) << 16 | 
      (tiff[116] & 0xFF) << 8 | 
      tiff[117] & 0xFF;
    if (count != width * height * 3) {
      System.err.println("Error: Processing can only read its own TIFF files. (" + width + ", " + height + ")");
      return null;
    }
    

    for (int i = 0; i < TIFF_HEADER.length; i++) {
      if ((i != 30) && (i != 31) && (i != 42) && (i != 43) && 
        (i != 102) && (i != 103) && 
        (i != 114) && (i != 115) && (i != 116) && (i != 117))
      {
        if (tiff[i] != TIFF_HEADER[i]) {
          System.err.println("Error: Processing can only read its own TIFF files. (" + i + ")");
          return null;
        }
      }
    }
    PImage outgoing = new PImage(width, height, 1);
    int index = 768;
    count /= 3;
    for (int i = 0; i < count; i++) {
      pixels[i] = 
        (0xFF000000 | 
        (tiff[(index++)] & 0xFF) << 16 | 
        (tiff[(index++)] & 0xFF) << 8 | 
        tiff[(index++)] & 0xFF);
    }
    return outgoing;
  }
  






  protected boolean saveTIFF(OutputStream output)
  {
    try
    {
      byte[] tiff = new byte['Ì€'];
      System.arraycopy(TIFF_HEADER, 0, tiff, 0, TIFF_HEADER.length);
      
      tiff[30] = ((byte)(pixelWidth >> 8 & 0xFF));
      tiff[31] = ((byte)(pixelWidth & 0xFF)); byte 
        tmp66_65 = ((byte)(pixelHeight >> 8 & 0xFF));tiff[102] = tmp66_65;tiff[42] = tmp66_65; byte 
        tmp84_83 = ((byte)(pixelHeight & 0xFF));tiff[103] = tmp84_83;tiff[43] = tmp84_83;
      
      int count = pixelWidth * pixelHeight * 3;
      tiff[114] = ((byte)(count >> 24 & 0xFF));
      tiff[115] = ((byte)(count >> 16 & 0xFF));
      tiff[116] = ((byte)(count >> 8 & 0xFF));
      tiff[117] = ((byte)(count & 0xFF));
      

      output.write(tiff);
      
      for (int i = 0; i < pixels.length; i++) {
        output.write(pixels[i] >> 16 & 0xFF);
        output.write(pixels[i] >> 8 & 0xFF);
        output.write(pixels[i] & 0xFF);
      }
      output.flush();
      return true;
    }
    catch (IOException e) {
      e.printStackTrace();
    }
    return false;
  }
  


















  protected boolean saveTGA(OutputStream output)
  {
    byte[] header = new byte[18];
    
    if (format == 4) {
      header[2] = 11;
      header[16] = 8;
      header[17] = 40;
    }
    else if (format == 1) {
      header[2] = 10;
      header[16] = 24;
      header[17] = 32;
    }
    else if (format == 2) {
      header[2] = 10;
      header[16] = 32;
      header[17] = 40;
    }
    else {
      throw new RuntimeException("Image format not recognized inside save()");
    }
    
    header[12] = ((byte)(pixelWidth & 0xFF));
    header[13] = ((byte)(pixelWidth >> 8));
    header[14] = ((byte)(pixelHeight & 0xFF));
    header[15] = ((byte)(pixelHeight >> 8));
    try
    {
      output.write(header);
      
      int maxLen = pixelHeight * pixelWidth;
      int index = 0;
      
      int[] currChunk = new int['Â€'];
      


      if (format == 4) {
        while (index < maxLen) {
          isRLE = false;
          rle = 1; int 
            tmp206_205 = (pixels[index] & 0xFF);col = tmp206_205;currChunk[0] = tmp206_205;
          while (index + rle < maxLen) {
            if ((col != (pixels[(index + rle)] & 0xFF)) || (rle == 128)) {
              isRLE = rle > 1;
              break;
            }
            rle++;
          }
          if (isRLE) {
            output.write(0x80 | rle - 1);
            output.write(col);
          }
          else {
            rle = 1;
            while (index + rle < maxLen) {
              cscan = pixels[(index + rle)] & 0xFF;
              if (((col != cscan) && (rle < 128)) || (rle < 3)) {
                int tmp343_341 = cscan;col = tmp343_341;currChunk[rle] = tmp343_341;
              } else {
                if (col != cscan) break; rle -= 2;
                break;
              }
              rle++;
            }
            output.write(rle - 1);
            for (i = 0; i < rle; i++) output.write(currChunk[i]);
          }
          index += rle;
        }
      } else {
        while (index < maxLen) { boolean isRLE;
          int rle; int col; int cscan; int i; boolean isRLE = false; int 
            tmp437_436 = pixels[index];int col = tmp437_436;currChunk[0] = tmp437_436;
          int rle = 1;
          

          while (index + rle < maxLen) {
            if ((col != pixels[(index + rle)]) || (rle == 128)) {
              isRLE = rle > 1;
              break;
            }
            rle++;
          }
          if (isRLE) {
            output.write(0x80 | rle - 1);
            output.write(col & 0xFF);
            output.write(col >> 8 & 0xFF);
            output.write(col >> 16 & 0xFF);
            if (format == 2) output.write(col >>> 24 & 0xFF);
          }
          else {
            rle = 1;
            while (index + rle < maxLen) {
              if (((col != pixels[(index + rle)]) && (rle < 128)) || (rle < 3)) {
                int tmp624_623 = pixels[(index + rle)];col = tmp624_623;currChunk[rle] = tmp624_623;
              }
              else
              {
                if (col != pixels[(index + rle)]) break; rle -= 2;
                break;
              }
              rle++;
            }
            
            output.write(rle - 1);
            if (format == 2) {
              for (int i = 0; i < rle; i++) {
                col = currChunk[i];
                output.write(col & 0xFF);
                output.write(col >> 8 & 0xFF);
                output.write(col >> 16 & 0xFF);
                output.write(col >>> 24 & 0xFF);
              }
            } else {
              for (int i = 0; i < rle; i++) {
                col = currChunk[i];
                output.write(col & 0xFF);
                output.write(col >> 8 & 0xFF);
                output.write(col >> 16 & 0xFF);
              }
            }
          }
          index += rle;
        }
      }
      output.flush();
      return true;
    }
    catch (IOException e) {
      e.printStackTrace(); }
    return false;
  }
  





  protected boolean saveImageIO(String path)
    throws IOException
  {
    try
    {
      int outputFormat = format == 2 ? 
        2 : 1;
      
      String extension = 
        path.substring(path.lastIndexOf('.') + 1).toLowerCase();
      



      if ((extension.equals("bmp")) || (extension.equals("jpg")) || (extension.equals("jpeg"))) {
        outputFormat = 1;
      }
      
      BufferedImage bimage = new BufferedImage(pixelWidth, pixelHeight, outputFormat);
      bimage.setRGB(0, 0, pixelWidth, pixelHeight, pixels, 0, pixelWidth);
      
      File file = new File(path);
      
      ImageWriter writer = null;
      ImageWriteParam param = null;
      IIOMetadata metadata = null;
      
      if (((extension.equals("jpg")) || (extension.equals("jpeg"))) && 
        ((writer = imageioWriter("jpeg")) != null))
      {



        param = writer.getDefaultWriteParam();
        param.setCompressionMode(2);
        param.setCompressionQuality(0.9F);
      }
      

      if ((extension.equals("png")) && 
        ((writer = imageioWriter("png")) != null)) {
        param = writer.getDefaultWriteParam();
      }
      




      if (writer != null) {
        BufferedOutputStream output = 
          new BufferedOutputStream(PApplet.createOutput(file));
        writer.setOutput(ImageIO.createImageOutputStream(output));
        
        writer.write(metadata, new IIOImage(bimage, null, metadata), param);
        writer.dispose();
        
        output.flush();
        output.close();
        return true;
      }
      
      return ImageIO.write(bimage, extension, file);
    }
    catch (Exception e) {
      e.printStackTrace();
      throw new IOException("image save failed.");
    }
  }
  
  private ImageWriter imageioWriter(String extension)
  {
    Iterator<ImageWriter> iter = ImageIO.getImageWritersByFormatName(extension);
    if (iter.hasNext()) {
      return (ImageWriter)iter.next();
    }
    return null;
  }
  

  private IIOMetadata imageioDPI(ImageWriter writer, ImageWriteParam param, double dpi)
  {
    ImageTypeSpecifier typeSpecifier = 
      ImageTypeSpecifier.createFromBufferedImageType(1);
    IIOMetadata metadata = 
      writer.getDefaultImageMetadata(typeSpecifier, param);
    
    if ((!metadata.isReadOnly()) && (metadata.isStandardMetadataFormatSupported()))
    {
      double dotsPerMilli = dpi / 25.4D;
      
      IIOMetadataNode horiz = new IIOMetadataNode("HorizontalPixelSize");
      horiz.setAttribute("value", Double.toString(dotsPerMilli));
      
      IIOMetadataNode vert = new IIOMetadataNode("VerticalPixelSize");
      vert.setAttribute("value", Double.toString(dotsPerMilli));
      
      IIOMetadataNode dim = new IIOMetadataNode("Dimension");
      dim.appendChild(horiz);
      dim.appendChild(vert);
      
      IIOMetadataNode root = new IIOMetadataNode("javax_imageio_1.0");
      root.appendChild(dim);
      try
      {
        metadata.mergeTree("javax_imageio_1.0", root);
        return metadata;
      }
      catch (IIOInvalidTreeException e) {
        System.err.println("Could not set the DPI of the output image");
        e.printStackTrace();
      }
    }
    return null;
  }
  


















































  public boolean save(String filename)
  {
    boolean success = false;
    
    if (parent != null)
    {
      filename = parent.savePath(filename);
    }
    else {
      File file = new File(filename);
      if (file.isAbsolute())
      {
        PApplet.createPath(file);
      } else {
        String msg = 
          "PImage.save() requires an absolute path. Use createImage(), or pass savePath() to save().";
        
        PGraphics.showException(msg);
      }
    }
    

    loadPixels();
    try
    {
      OutputStream os = null;
      
      if (saveImageFormats == null) {
        saveImageFormats = ImageIO.getWriterFormatNames();
      }
      if (saveImageFormats != null) {
        for (int i = 0; i < saveImageFormats.length; i++) {
          if (filename.endsWith("." + saveImageFormats[i])) {
            if (!saveImageIO(filename)) {
              System.err.println("Error while saving image.");
              return false;
            }
            return true;
          }
        }
      }
      
      if (filename.toLowerCase().endsWith(".tga")) {
        os = new BufferedOutputStream(new FileOutputStream(filename), 32768);
        success = saveTGA(os);
      }
      else {
        if ((!filename.toLowerCase().endsWith(".tif")) && 
          (!filename.toLowerCase().endsWith(".tiff")))
        {
          filename = filename + ".tif";
        }
        os = new BufferedOutputStream(new FileOutputStream(filename), 32768);
        success = saveTIFF(os);
      }
      os.flush();
      os.close();
    }
    catch (IOException e) {
      System.err.println("Error while saving image.");
      e.printStackTrace();
      success = false;
    }
    return success;
  }
}
